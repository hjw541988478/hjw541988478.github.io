[{"title":"27. Remove Element","date":"2018-08-29T09:37:50.000Z","path":"2018/08/27-Remove-Element/","text":"问题https://leetcode.com/problems/remove-element/description/Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example 1:12345Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2.It doesn&apos;t matter what you leave beyond the returned length. Example 2:1234567Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.Note that the order of those five elements can be arbitrary.It doesn&apos;t matter what values are set beyond the returned length. 思路方法一：首先能想到的，从前往后或者从后往前遍历，遇到需要删除的数字，后面的数组整体向前移动一位，直至遍历结束；方法二：使用两个指针，一个用来遍历原数组，另一个记录处理后的结果数组下标，遇到不一样的时候，直接替换后一个指针位置，然后指针位置++； 代码123456789101112131415161718192021222324public int removeElement(int[] nums, int val) &#123; int len = nums.length; for (int i = nums.length - 1; i &gt;= 0; i --) &#123; if (val == nums[i]) &#123; len --; if (i != nums.length - 1) &#123; for (int j = i + 1; j &lt; nums.length; j ++) &#123; nums[j - 1] = nums[j]; &#125; &#125; &#125; &#125; return len;&#125;public int removeElement1(int[] nums, int val) &#123; int i = 0; for (int j = 0; j &lt; nums.length; j++) &#123; if (nums[j] != val) &#123; nums[i++] = nums[j]; &#125; &#125; return i;&#125;","tags":[{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://hjw541988478.github.io/tags/TwoPointers/"}]},{"title":"24. Swap Nodes in Pairs","date":"2018-08-24T08:00:26.000Z","path":"2018/08/24-Swap-Nodes-in-Pairs/","text":"问题https://leetcode.com/problems/swap-nodes-in-pairs/description/Given a linked list, swap every two adjacent nodes and return its head. Example:1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Note: Your algorithm should use only constant extra space. You may not modify the values in the list’s nodes, only nodes itself may be changed. 思路利用双节点的前个节点作为转接结点，交换位置后，依次处理下个双节点，最后使之成为新的链表。 代码1234567891011121314public ListNode swapPairs(ListNode head) &#123; ListNode dummy = new ListNode(-1); dummy.next = head; ListNode current = dummy; while (current.next != null &amp;&amp; current.next.next != null) &#123; ListNode first = current.next; ListNode second = current.next.next; first.next = second.next; second.next = first; current.next = second; current = current.next.next; &#125; return dummy.next;&#125;","tags":[{"name":"LinkedList","slug":"LinkedList","permalink":"https://hjw541988478.github.io/tags/LinkedList/"}]},{"title":"22. Generate Parentheses","date":"2018-08-24T03:01:19.000Z","path":"2018/08/22-Generate-Parentheses/","text":"问题https://leetcode.com/problems/generate-parenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is:1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 思路方法一：遍历所有可能的组合情况，对于符合条件的加入到结果中，不满足的忽略；方法二：利用DFS的思想，递归左括号小于右括号且用完了所有的括号的所有情况，直接加入到结果中； 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c : s.toCharArray()) &#123; if (c == '(') &#123; stack.push(')'); &#125; else if (c == '&#123;') &#123; stack.push('&#125;'); &#125; else if (c == '[') &#123; stack.push(']'); &#125; else if (stack.isEmpty() || stack.pop() != c) &#123; return false; &#125; &#125; return stack.isEmpty();&#125;public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if (n &lt;= 0) &#123; return res; &#125; genParenthesis(res, new StringBuilder(), 0, n * 2); return res;&#125;private void genParenthesis(List&lt;String&gt; res, StringBuilder sb, int index, int n) &#123; if (sb.length() == n) &#123; if (isValid(sb.toString())) &#123; res.add(sb.toString()); &#125; return; &#125; sb.append('('); genParenthesis(res, sb, index + 1, n); sb.deleteCharAt(sb.length() - 1); sb.append(')'); genParenthesis(res, sb, index + 1, n); sb.deleteCharAt(sb.length() - 1);&#125;public void dfs(List&lt;String&gt; res, String cur, int l, int r) &#123; System.out.println(\"res:\" + cur); if(l == 0 &amp;&amp; r == 0) &#123; res.add(cur); return; &#125; if(l &gt; 0) &#123; dfs(res, cur + \"(\", l - 1, r); &#125; if(l &lt; r) &#123; dfs(res, cur + \")\", l, r -1); &#125;&#125;public List&lt;String&gt; generateParenthesis2(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(n &lt;= 0) &#123; return res; &#125; dfs(res, \"\", n , n); return res;&#125;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"https://hjw541988478.github.io/tags/Backtracking/"},{"name":"DFS","slug":"DFS","permalink":"https://hjw541988478.github.io/tags/DFS/"},{"name":"Recursion","slug":"Recursion","permalink":"https://hjw541988478.github.io/tags/Recursion/"}]},{"title":"23. Merge k Sorted Lists","date":"2018-08-23T08:39:59.000Z","path":"2018/08/23-Merge-k-Sorted-Lists/","text":"问题https://leetcode.com/problems/merge-k-sorted-lists/description/Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example:1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 思路至少3种方法：方法一：在上一题合并两条有序链表的基础上的扩展，逐条合并到最后一条；方法二：利用优先级队列的特点，自动排好序，只要逐个加入到目标节点就行；方法三：利用分治法的思想，分成左半边和右半边，直至左半边和右半边都被合并成一条有序的链表，再合并成一条解决问题； 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 方法一public ListNode mergeKLists3(ListNode[] lists) &#123; if(lists == null || lists.length == 0) &#123; return null; &#125; ListNode first = lists[0]; for(int i = 1; i &lt; lists.length; i ++) &#123; first = mergeTwoLists(first, lists[i]); &#125; return first;&#125;private ListNode mergeTwoLists(ListNode one, ListNode two) &#123; ListNode res = new ListNode(-1), head = res; while(one != null &amp;&amp; two != null) &#123; if(one.val &lt; two.val) &#123; res.next = one; one = one.next; &#125; else &#123; res.next = two; two = two.next; &#125; res = res.next; &#125; if(one != null) &#123; res.next = one; &#125; if(two != null) &#123; res.next = two; &#125; return head.next;&#125;// 方法二public ListNode mergeKLists2(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(lists.length, new Comparator&lt;ListNode&gt;() &#123; @Override public int compare(ListNode l1, ListNode l2) &#123; return l1.val - l2.val; &#125; &#125;); for (ListNode node : lists) &#123; if (node != null) &#123; queue.offer(node); &#125; &#125; ListNode head = new ListNode(-1), res = head; while (!queue.isEmpty()) &#123; head.next = queue.poll(); head = head.next; if (head.next != null) &#123; queue.offer(head.next); &#125; &#125; return res;&#125;// 方法三public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; return sort(lists, 0, lists.length - 1);&#125;private ListNode sort(ListNode[] lists, int lo, int hi) &#123; if (lo &gt;= hi) &#123; return lists[lo]; &#125; int mid = lo + (hi - lo) / 2; ListNode l1 = sort(lists, lo, mid); ListNode l2 = sort(lists, mid + 1, hi); return merge(l1, l2);&#125;private ListNode merge(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; if (l1.val &lt; l2.val) &#123; l1.next = merge(l1.next, l2); return l1; &#125; l2.next = merge(l1, l2.next); return l2;&#125;","tags":[{"name":"MergeSort","slug":"MergeSort","permalink":"https://hjw541988478.github.io/tags/MergeSort/"},{"name":"Recursion","slug":"Recursion","permalink":"https://hjw541988478.github.io/tags/Recursion/"},{"name":"PriorityQueue","slug":"PriorityQueue","permalink":"https://hjw541988478.github.io/tags/PriorityQueue/"},{"name":"DivideAndConquer","slug":"DivideAndConquer","permalink":"https://hjw541988478.github.io/tags/DivideAndConquer/"}]},{"title":"21. Merge Two Sorted Lists","date":"2018-08-22T07:32:59.000Z","path":"2018/08/21-Merge-Two-Sorted-Lists/","text":"问题https://leetcode.com/problems/merge-two-sorted-lists/description/Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.1234Example:Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路方法一：在两条有序链表的前提下，逐个比较小的放在前面，大的放在后面，最后还有剩下的某条直接放在最后面即可；方法二：使用递归的思路解决，小的放在前面，剩下的和另一条做比较，直到递归结束，值得注意的是输入数据很长时可能会StackOverFlow； 代码12345678910111213141516171819202122232425262728293031323334353637public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(-1), res; res = head; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt; l2.val) &#123; head.next = l1; l1 = l1.next; &#125; else &#123; head.next = l2; l2 = l2.next; &#125; head = head.next; &#125; if (l1 != null) &#123; head.next = l1; &#125; if (l2 != null) &#123; head.next = l2; &#125; return res.next;&#125;public ListNode mergeTwoLists2(ListNode l1, ListNode l2)&#123; if(l1 == null) &#123; return l2; &#125; if(l2 == null) &#123; return l1; &#125; if(l1.val &lt; l2.val)&#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else&#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125;","tags":[{"name":"MergeSort","slug":"MergeSort","permalink":"https://hjw541988478.github.io/tags/MergeSort/"},{"name":"Recursion","slug":"Recursion","permalink":"https://hjw541988478.github.io/tags/Recursion/"}]},{"title":"20. Valid Parentheses","date":"2018-08-21T09:06:01.000Z","path":"2018/08/20-Valid-Parentheses/","text":"问题https://leetcode.com/problems/valid-parentheses/description/Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1:12Input: &quot;()&quot;Output: true Example 2:12Input: &quot;()[]&#123;&#125;&quot;Output: true 思路使用Stack后进先出的特点，对于入栈的符号查看栈顶是否配对，配对则移除栈顶元素，否则入栈，最终查看栈是否为空，有两种实现方式。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546public boolean isValid(String s) &#123; if (s == null || s.length() == 0) &#123; return true; &#125; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); i ++) &#123; Character topChar = stack.isEmpty() ? null : stack.peek(); char curChar = s.charAt(i); if (topChar != null) &#123; if (topChar.charValue() == '(') &#123; if (curChar == ')') &#123; stack.pop(); continue; &#125; &#125; else if (topChar.charValue() == '&#123;') &#123; if (curChar == '&#125;') &#123; stack.pop(); continue; &#125; &#125; else if (topChar.charValue() == '[') &#123; if (curChar == ']') &#123; stack.pop(); continue; &#125; &#125; &#125; stack.push(Character.valueOf(curChar)); &#125; return stack.isEmpty();&#125;public boolean isValid2(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c : s.toCharArray()) &#123; if (c == '(') &#123; stack.push(')'); &#125; else if (c == '&#123;') &#123; stack.push('&#125;'); &#125; else if (c == '[') &#123; stack.push(']'); &#125; else if (stack.isEmpty() || stack.pop() != c) &#123; return false; &#125; &#125; return stack.isEmpty();&#125;","tags":[{"name":"Stack","slug":"Stack","permalink":"https://hjw541988478.github.io/tags/Stack/"}]},{"title":"19. Remove Nth Node From End of List","date":"2018-08-21T07:24:21.000Z","path":"2018/08/19-Remove-Nth-Node-From-End-of-List/","text":"问题https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/Given a linked list, remove the n-th node from the end of list and return its head. Example:123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. 思路方法一：第一遍找到链表长度，找到长度后可以找到长度-n的位置，直接进行删除操作；方法二：采用两个游标，前一个先走n步，此后后一个同时开始走，知道前一个走到结束位置，此时位置就是待删除节点的前一个位置，直接进行删除操作； 代码12345678910111213141516171819202122232425262728293031323334353637383940public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; int length = 0; ListNode first = head; while (first != null) &#123; length++; first = first.next; &#125; length -= n; first = dummy; while (length &gt; 0) &#123; length--; first = first.next; &#125; first.next = first.next.next; return dummy.next; &#125;/** * 1 pass algorithm */public ListNode removeNthFromEnd2(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; int length = 0; ListNode first = head; while (first != null) &#123; length++; first = first.next; &#125; length -= n; first = dummy; while (length &gt; 0) &#123; length--; first = first.next; &#125; first.next = first.next.next; return dummy.next;&#125;","tags":[{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://hjw541988478.github.io/tags/TwoPointers/"}]},{"title":"17. Letter Combinations of a Phone Number","date":"2018-08-20T10:15:53.000Z","path":"2018/08/17-Letter-Combinations-of-a-Phone-Number/","text":"问题https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example:12Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 思路方法一：如果只有2组我们可以直接找出所有的组合，所以只要遍历出前面的N-1位的所有组合再与最后1位组合就可以找到所有的可能;方法二：采用DFS(深度优先遍历)实现，使用回溯的思想，递归所有的可能组合； 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private static final String[] table = &#123; \"\", \"\",\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\",\"pqrs\",\"tuv\", \"wxyz\"&#125;;// 方法一public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; digits.length(); i ++) &#123; String nextNumberLetters = table[Character.getNumericValue(digits.charAt(i))]; if (i == 0) &#123; for (int j = 0; j &lt; nextNumberLetters.length(); j ++ ) &#123; res.add(String.valueOf(nextNumberLetters.charAt(j))); &#125; &#125; else &#123; res = letterCombine(res, nextNumberLetters); &#125; &#125; return res;&#125;private List&lt;String&gt; letterCombine(List&lt;String&gt; left, String right) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; left.size(); i ++) &#123; for (int j = 0; j &lt; right.length(); j ++) &#123; String combinedStr = left.get(i) + right.charAt(j); res.add(combinedStr); &#125; &#125; return res;&#125;// 方法二public List&lt;String&gt; letterCombinations2(String digits) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); letterCombine2(digits, res, new StringBuilder(), 0); return res;&#125;private void letterCombine2(String digits, List&lt;String&gt; res, StringBuilder sb, int index) &#123; if (sb.length() == digits.length()) &#123; res.add(sb.toString()); return; &#125; String curNumberPanel = table[Character.getNumericValue(digits.charAt(index))]; for (int i = 0; i &lt; curNumberPanel.length(); i ++) &#123; sb.append(curNumberPanel.charAt(i)); letterCombine2(digits, res, sb, index + 1); sb.deleteCharAt(sb.length() - 1); &#125;&#125;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"https://hjw541988478.github.io/tags/Backtracking/"},{"name":"DFS","slug":"DFS","permalink":"https://hjw541988478.github.io/tags/DFS/"}]},{"title":"18.4Sum","date":"2018-08-18T16:08:56.000Z","path":"2018/08/18-4Sum/","text":"问题https://leetcode.com/problems/4sum/description/Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example:12345678Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 思路沿用3sum的思路，将数组升序后，逐个比较，第一层遍历到倒数第4个数，第二层遍历到倒数第3个数，最后两个只要找到求2Sum的方法便可以找到所有的情况，注意此处也可以优化的地方，重复的可以跳过比较。 代码123456789101112131415161718192021222324252627282930313233343536public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums == null || nums.length &lt; 4) &#123; return res; &#125; Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 3; i ++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; for (int j = i + 1; j &lt; nums.length - 2; j ++) &#123; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123; continue; &#125; int l = j + 1, r = nums.length - 1; while (l &lt; r) &#123; if (nums[i] + nums[j] + nums[l] + nums[r] == target) &#123; res.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r])); l ++; r --; while (l &lt; r &amp;&amp; nums[l] == nums[l - 1]) &#123; l ++; &#125; while (l &lt; r &amp;&amp; nums[r] == nums[r + 1]) &#123; r --; &#125; &#125; else if (nums[i] + nums[j] + nums[l] + nums[r] &lt; target) &#123; l ++; &#125; else &#123; r --; &#125; &#125; &#125; &#125; return res; &#125;","tags":[{"name":"3sum","slug":"3sum","permalink":"https://hjw541988478.github.io/tags/3sum/"}]},{"title":"16.3Sum Closet","date":"2018-08-18T16:03:56.000Z","path":"2018/08/16-3Sum-Closet/","text":"问题https://leetcode.com/problems/3sum-closest/description/Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example:12Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 思路先升序排序，从头和尾往中靠拢，如果三数之和大于target，则右边缩进一位，否则左边扩大一位，边遍历的同时检查是否有更合适的数并记录。 代码12345678910111213141516171819public int threeSumClosest(int[] num, int target) &#123; int result = num[0] + num[1] + num[num.length - 1]; Arrays.sort(num); for (int i = 0; i &lt; num.length - 2; i++) &#123; int start = i + 1, end = num.length - 1; while (start &lt; end) &#123; int sum = num[i] + num[start] + num[end]; if (sum &gt; target) &#123; end--; &#125; else &#123; start++; &#125; if (Math.abs(sum - target) &lt; Math.abs(result - target)) &#123; result = sum; &#125; &#125; &#125; return result;&#125;","tags":[{"name":"3sum","slug":"3sum","permalink":"https://hjw541988478.github.io/tags/3sum/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://hjw541988478.github.io/tags/TwoPointers/"}]},{"title":"设计模式之单例模式","date":"2017-08-02T12:52:00.000Z","path":"2017/08/设计模式之单例模式/","text":"模式介绍模式定义确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 使用场景确保某个类只有一个对象的场景，例如日志类，访问 IO 和数据库资源。 UML图 单例模式UML图 代码实现单例模式的实现有很多种不同的方式，包括饿汉式、懒汉式、双重锁式、静态内部类式、枚举式、容器式。 饿汉式12345678910111213141516/** * 静态单例，提前在类加载的时候初始化，保证线程安全。 */ public final class IvoryTower &#123; /** * 私有构造函数，保证外部没法初始化 */ private IvoryTower() &#123;&#125; /** * 静态初始化对象 */ private static final IvoryTower INSTANCE = new IvoryTower(); public static IvoryTower getInstance() &#123; return INSTANCE; &#125; &#125; 懒汉式12345678910111213141516/*** 线程安全，延迟加载，需要 synchronization 加锁同步*/public final class ThreadSafeLazyLoadedIvoryTower &#123; private static ThreadSafeLazyLoadedIvoryTower instance; private ThreadSafeLazyLoadedIvoryTower() &#123;&#125; /** * 延迟加载，只有在被调用时，才会初始化 */ public static synchronized ThreadSafeLazyLoadedIvoryTower getInstance() &#123; if (instance == null) &#123; instance = new ThreadSafeLazyLoadedIvoryTower(); &#125; return instance; &#125;&#125; 双重加锁式123456789101112131415161718192021222324252627282930313233343536373839404142434445/*** 双重加锁式* &lt;p/&gt;* http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html* &lt;p/&gt;* Broken under Java 1.4.** @author mortezaadi@gmail.com*/public final class ThreadSafeDoubleCheckLocking &#123; // 被volatile修饰的变量的值，不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而 // 保证线程正确的处理该变量。 private static volatile ThreadSafeDoubleCheckLocking instance; /** * 私有构造方法防止外部初始化 */ private ThreadSafeDoubleCheckLocking() &#123; // 防止反射初始化 if (instance != null) &#123; throw new IllegalStateException(\"Already initialized.\"); &#125; &#125; /** * 获取单例的入口 */ public static ThreadSafeDoubleCheckLocking getInstance() &#123; // 本地变量能改善25%的性能 // Joshua Bloch \"Effective Java, Second Edition\", p. 283-284 ThreadSafeDoubleCheckLocking result = instance; // 检查单例是否创建，如果已创建直接返回 if (result == null) &#123; // 检查到单例还未创建，但不保证其他线程可能已经创建了单例，因此需要加锁同步再次检查 synchronized (ThreadSafeDoubleCheckLocking.class) &#123; // 再次给本地变量赋值，检查是否已被其他线程创建，由于当前线程已被阻塞，如果此时不为空，直接将已创建的对象返回即可 result = instance; if (result == null) &#123; // 此时实例还未初始化，所以在此处进行初始化，实现单例 instance = result = new ThreadSafeDoubleCheckLocking(); &#125; &#125; &#125; return result; &#125;&#125; 静态内部类式1234567891011121314/*** 延迟初始化线程安全的单例，充分利用了类初始化的特点，也无需其他类似 volatile、synchronized 关键词限定，只有调用了 getInstance 的时候才会初始化。**/public final class InitializingOnDemandHolderIdiom &#123; private InitializingOnDemandHolderIdiom() &#123;&#125; public static InitializingOnDemandHolderIdiom getInstance() &#123; return HelperHolder.INSTANCE; &#125; private static class HelperHolder &#123; private static final InitializingOnDemandHolderIdiom INSTANCE = new InitializingOnDemandHolderIdiom(); &#125;&#125; 枚举式1234567891011/*** 枚举式单例，写法简单，线程安全。* Effective Java 2nd Edition (Joshua Bloch) p. 18*/public enum EnumIvoryTower &#123; INSTANCE; @Override public String toString() &#123; return getDeclaringClass().getCanonicalName() + \"@\" + hashCode(); &#125;&#125; 容器式123456789101112/** * 注册到容器, 根据key获取对象.一般都会有多种相同属性类型的对象会注册到一个map中，典型的是在对 WMS，AMS 系统服务的获取能够体现。 */private static Map&lt;String, Singleton&gt; objMap = new HashMap&lt;string Singleton&gt;();public static void registerService(String key, Singleton instance) &#123; if (!objMap.containsKey(key) ) &#123; objMap.put(key, instance) ; &#125;&#125;public static Singleton getService(String key) &#123; return objMap.get(key) ;&#125; Android 源码实现各种各样的系统服务，我们在使用到时采用的是context.getSystemService(xxx)的形式，其初始化和获取的实现类通过跟踪源码可以到ContextImpl中查看。1234567891011121314151617181920212223242526272829303132333435class ContextImpl extends Contex &#123; // 1 : service容器 private static final HashMap&lt;String, ServiceFetcher&gt; SYSTEM_SERVICE_MAP = new HashMap&lt;String, ServiceFetcher&gt;(); private static int sNextPerContextServiceCacheIndex = 0; // 2: 注册服务器 private static void registerService(String serviceName, ServiceFetcher fetcher) &#123; if (!(fetcher instanceof StaticServiceFetcher)) &#123; fetcher.mContextCacheIndex = sNextPerContextServiceCacheIndex++; &#125; SYSTEM_SERVICE_MAP.put(serviceName, fetcher); &#125; // 3: 静态语句块, 第一次加载该类时执行 ( 只执行一次, 保证实例的唯一性. ) static &#123; // 代码省略 // 注册Activity Servicer registerService(ACTIVITY_SERVICE, new ServiceFetcher() &#123; public Object createService(ContextImpl ctx) &#123; return new ActivityManager(ctx.getOuterContext(), ctx.mMainThread.getHandler()); &#125;&#125;); // 注册LayoutInflater service registerService(LAYOUT_INFLATER_SERVICE, new ServiceFetcher() &#123; public Object createService(ContextImpl ctx) &#123; return PolicyManager.makeNewLayoutInflater(ctx.getOuterContext()); &#125;&#125;); // 代码省略 &#125; // 4: 根据key获取对应的服务, @Override public Object getSystemService(String name) &#123; // 根据name来获取服务 ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name); return fetcher == null ? null : fetcher.getService(this); &#125;&#125; ContextImpl 类为 Context 的实现类，在虚拟机第一次加载时会注册各种用到的服务，这些服务以键值对的形势存储在一个 HashMap 中，用户使用时只需要根据 key 来获取到对应的服务。系统核心服务以单例形式存在，减少资源消耗。 总结单例模式实现的核心在于，将构造函数私有化，同时保证类在多线程、序列化和反序列化时能够只获取到唯一的实例。 由于需要控制类的创建和生命周期，违背了 SRP（单一职责） 设计原则； 使用唯一的全局访问点，优化共享资源； 太够耦合，难以测试； 几乎无法实现单例类的子类，难以扩展； Android 中持有 Context 对象，可能导致内存泄露； 参考 Android 设计模式源码解析之单例模式 java-design-patterns 开源库","tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://hjw541988478.github.io/tags/DesignPattern/"},{"name":"Singleton","slug":"Singleton","permalink":"https://hjw541988478.github.io/tags/Singleton/"}]},{"title":"设计模式之七大基本原则","date":"2017-07-31T11:52:00.000Z","path":"2017/07/设计模式之七大基本原则/","text":"概述 七大原则 职责单一职责原则单一职责原则（SRP）用于在类的粒度上，一个类只负责一个功能领域中相应职责。同时也应该看到一个类不应该承担太多的职责，这意味着被复用的可能性越小。当其中一个职责变化时，可能会影响到其他职责的运作，因此需要将不同的职责封装在不同的类中，如果多个职责总是同时发生改变，则可以将它们封装在同一类中。作为高内聚、低耦合的指导，需要设计人员发现类的不同职责并将其分离，发现类的多重职责需要较强的分析设计能力。 开闭原则开闭原则（OCP）表示的是一个软件实体应该对扩展开放，对修改关闭，即软件实体应尽量在不修改原代码的情况下进行扩展。软件实体可以指一个软件模块、一个由多各类组成的局部结构或一个独立的类。在软件的重构阶段或者需求的迭代阶段，使用抽象化设计，抽象化在具体的编程语言中可以是使用接口或者抽象类，无须修改已有的代码，灵活地对系统进行扩展，使得软件拥有良好的系统稳定性和延续性。 里氏代换原则里氏代换原则（LSP）指所有引用基类的地方必须能透明替换使用其子类的对象。在软件中将一个基类对象替换成其子类对象，那么程序将不会发生任何错误，反过来则不成立。里氏代换原则是实现OCP的重要方式之一，由于使用基类对象的地方可以使用子类对象，因此可以使用基类类型来对对象定义，在运行时确定其子类类型，用子类对象来替换父类对象。需要注意的点： 子类所有方法必须在父类中声明，为了系统的扩展性，如果父类没有子类方法的声明，那么无法使用父类类型的对象使用该方法； 尽量把父类设计成抽象类或者接口，让子类继承父类或实现父接口，然后在运行时进行替换； Java在编译时期会对程序进行是否符合 LSP ，这只是纯语法意义上的检查； 依赖倒转原则依赖倒转原则（DIP）是系统抽象化的具体实现，抽象不依赖于细节，细节应当依赖于抽象，也就是说针对接口编程。一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多的方法，否则无法调用子类中增加的新方法。在实现依赖倒转原则时，需要针对抽象层编程，将具体类的对象通过 DI 的方式注入其他对象中，DI 是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象，常用的注入方式有：构造注入、Setter 注入和接口注入。构造注入指通过构造函数来传入具体类的对象，Setter 注入指通过 Setter 方法来传入具体类的对象，接口注入指通过接口中声明的业务方法来传入具体类对象。 接口隔离原则接口隔离原则（ISP）指使用多个专门的接口，而不使用单一的总接口，即实现类不应该依赖不需要的对象。当一个接口太大时，应该把它分割成更细小的接口，使用该接口的类只需要知道与之相关的方法。对于接口的理解： 按逻辑上划分可以看成一个类型所提供的所有方法特征的集合。接口的划分直接带来类型的划分，可以把接口理解成角色，一个接口代表一个角色，这个原则叫角色隔离原则； 注意控制接口的粒度，太小会导致系统中接口泛滥，当然也不能太大会违背接口隔离原则，一般而言，接口中只包含为某一类用户定制的方法。 合成复用原则又称为组合/聚合原则（CARP），尽量使用组合，而不是继承达到复用目的。在 OOD 中，可以选择组合或通过继承来实现，但首先应该考虑的是组合，组合使系统更加灵活，降低类与类之间的耦合度，其次才考虑继承，使用继承时需要遵循里氏代换原则，降低复杂度。继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，那么如果基类发生变化，子类的实现也不得不发生改变，缺乏足够的灵活性。 迪米特法则迪米特法则（LoD）指在一个软件实体应当尽可能少地与其他实体发生相互作用。一个对象只能与直接“朋友”交互，不要与非“朋友”直接交互，这样会降低系统的耦合度，一个对象的改变不会给太多其他对象的影响。迪米特法则要求我们在设计系统时，应该尽可能减少对象之间的交互，如果两个对象不必彼此直接通信，那么这两个对象就不应该发生任何直接相互作用，如果其中 一个对象需要调用另一个对象的某一个方法，可以通过第三者转发这个调用。在类的划分时，应当尽量创建松耦合的类，类之间耦合度越低越利于复用，在类的设计上，只要有可能，应当设计成不变类，在对其他类引用上，一个对象对其他对象的引用应当降到最低。 引用 设计模式Java版","tags":[{"name":"DesignPattern","slug":"DesignPattern","permalink":"https://hjw541988478.github.io/tags/DesignPattern/"}]},{"title":"SO库热修复探究(Part3)","date":"2017-07-25T13:50:00.000Z","path":"2017/07/SO库热修复探究-Part3/","text":"SO 库加载原理Java 提供两个接口加载 so 库： System.loadLibrary(String libName)：参数为so库名称，位于 apk 压缩文件中的 libs 目录，最后复制到 apk 安装目录下； System.load(String pathName)：参数为 so 库在磁盘中完整的路径，可以加载自定义外部 so 库文件；其实最终都会调用 nativeLoad 这个 native 方法，这个方法参数为 so 库在磁盘中完整路径名。在 JNI 编程中，动态注册的 native 方法必须实现 JNI_OnLoad 方法，同时实现一个 JNINativeMethod[ ] 数组，静态注册的 native 方法必须是 Java+类完整路径+方法名 的格式。 12native void test() -&gt;(JNI_OnLoad nativeMethods[] 匹配映射) -&gt; 动态注册 void test(env,jobject);native void test() -&gt;(1. test第一次执行dvmResolvedNativeCass 2. hashtable中查找匹配findMethodInLib) -&gt; 静态注册 void Java_包名_类名_test(env,jobject); 动态注册的 native 方法映射通过加载 so 库过程中调用 JNI_OnLoad 方法调用完成； 静态注册的 native 方法映射在 native 方法第一次执行的时候完成映射，当然前提是 so 库已经 load 过。 SO 库热部署实时生效分析动态注册 native 方法实时生效动态注册的 native 方法调用一次 JNI_OnLoad 方法都会重新完成一次映射，所以我们可以先加载原来的 so 库，再加载补丁 so 库，就能完成 Java 层 native 方法到 native 层 patch 后新方法的映射，实测 art 是没问题的，但是 Dalvik 无法实时生效，原因在于 Dalvik 第二次 load 补丁 so 库执行的仍然是原来 so 库的 JNI_OnLoad 方法，而非补丁 so 库的。定位到主要的两个方法： dlopen()：返回给我们一个动态链接库的句柄； dlsym()：通过 dlopen 得到动态链接库句柄，来查找一个 symbol；在 Dalvik 中 dlopen 的实现，源码在 /bionic/linker/dlfcn.cpp 中，调用关系：dlopen -&gt; do_dlopen -&gt; find_library -&gt; find_library_internal，其中有：123456soinfo* si = find_loaded_library(name);if (si != NULL) &#123; if (si -&gt; flags &amp; FLAG_LINKED) &#123; return si; &#125;&#125; find_loaded_library 方法判断 name 表示的 so 库是否加载过，如果加载过直接返回，如果没有加载过则进行加载。而其中判断是否已经加载过的是依赖 so 库的文件名作为 key，那么补丁 so 库的路径与原来 so 库就算不一样，也会看作是同一 so 库，这样执行的还是原来 so 库的 JNI_OnLoad 方法，ART是以完整路径作为 key 去查找加载的，自然也不存在这种问题。所以解决 Dalvik 下的这个问题，可以对 so 进行改名，自然会重新加载。 静态注册 native 方法生效静态注册 native 方法的映射是在 native 方法第一次执行的时候就完成了映射，系统 JNI API 提供了解注册的接口，UnregisterNatives 函数会把 jclazz 所在类的所有 native 方法都重新指向为 dvmResolveNativeMethod，所以调用了 UnRegisterNatives 之后，不管静态注册还是动态注册的 native 方法都会重新去做映射。123static void patchNativeMethod(JNIEnv *env, jclass clz) &#123; env -&gt; UnregisterNatives(clz);&#125; 如果我们知道了哪个类需要解注册 native 方法，然后 load 补丁 so 库之后，再次指向该 native 方法，但实际上，java 层的 native 方法可能映射到原 so 库方法，也有可能映射到补丁 so 库的新方法。如果静态注册的 native 方法从未执行，首先尝试解析该方法，或者调用了 unregisterJNINativeMethods 解注册方法，那么该方法指向 meth -&gt; nativeFunc = dvmResolveNativeMethod，实际运行该方法的时候，执行的是 dvmResolveNativeMethod 函数，该函数主要完成 java 层 native 方法到 native 层的映射。其中具体涉及到的关键变量为 gDvm.nativeLibs ，它是一个全局变量，是一个 hashtable，存放着整个虚拟机加载 so 库的 SharedLib 结构指针，通过它找到对应 native 函数指针，如果找到就直接 return。 c.hashtable 与 java.hashtable 异同点：共同点：都是数组实现，容量超过默认值会进行扩容，都是对 key 进行 hash 计算后与 hashtable 的长度进行取模作为 bucket；不同点：Dalvik 下 hashtable put/get 操作方法比 java hashmap 简单一些，java hashmap 要处理 hash 冲突的情况，一般情况下增加一个链表处理冲突，然后 get 实现会遍历这个链表 通过 equals 方法比较 value 是否一致进行查找，而在 dalvik 下 hashtable 的 put 实&gt; 现只是简单 的把指针下移直到下一个空节点，get实现则是根据 hash 值计算出 bucket 位置，通过 cmpFunc 比较值是否一致，不一致指针下移。如果在对补丁 so 库重命名后，补丁 so 库在 hashtable 中的位置比原 so 库靠前，就可以修复，否则就无法修复。 SO 库实时生效方案总结 so 库为了兼容 Dalvik 动态注册的 native 方法的实时生效，必须对 so 文件改名； 针对 so 库静态注册的 native 方法的实时生效，需要先解注册静态注册的 native 方法，难点在于无法知道哪几个 native 方法发生了变更。假设我们知道静态注册的 native 方法需要解注册，重新 load 补丁 so 库有可能也无法生效不被修复； 如果补丁 so 库足够多足够大，在加载过程中，可能导致 JNI 层的 OOM； 如果补丁 so 库新增动态注册方法，而 dex 中没有相应方法，直接去加载会报 NoSuchMethodError 异常，具体逻辑在 dvmRegisterJNIMethod 中。此时只能冷启动生效。 SO 库冷部署重启生效方案接口调用替换方案使用SOPatchManager.loadLibrary接口加载 so 库优先尝试加载 sdk 指定目录下的补丁 so： 如果存在，则加载补丁 so 库而不去加载 apk 目录下的 so 库； 如果不存在 so，那么调用 System.loadLibrary 加载 apk 目录下的 so 库。这个方案的优缺点： 优点：不需要对不同 sdk 版本兼容，因为所有 sdk 版本都有 System.loadLibrary 这个接口； 缺点：调用方需要替换 System 默认加载 so 库接口为 sdk 提供的接口，如果是已经编译混淆好的三方库的 so 库 patch，很难做到接口替换，无法修复三方包 so 库； 反射注入方案System.loadLibrary(&quot;native-lib&quot;)，在加载过程中，最终传给 native 方法执行的参数是 so 库在磁盘中的完整路径，比如：/data/app-lib/com.test.jni/libnative-lib.so，so 库会在 DexPathList.nativeLibraryDirectories/nativeLibraryPathElements 变量所表示的目录下遍历搜索。12345678910111213//sdk &lt; 23, DexPathList.javaprivate final FIle[] nativeLibararyDirectories;public String findLibrary(String libraryName) &#123; String fileName = System.mapLibraryName(libraryName); for (File directory : nativeLibraryDirectories) &#123; String path = new File(directory, fileName).getPath(); // path文件存在同时可读，返回 if (IoUtils.canOpenReadOnly(path)) &#123; return path; &#125; &#125; return null;&#125; IoUtils.canOpenReadOnly(path)返回 true 的前提必须 path 表示的 so 文件存在，我们可以采用反射注入方式，把我们补丁 so 库的路径插入到 nativeLibraryDirectories 数组的最前面，就可以达到加载的是补丁 so 库而不是原来 so 库。1234567891011// sdk&gt;=23 DexPathList.javaprivate final Element[] nativeLibraryPathElements;public String findLibrary(String libraryName) &#123; String fileName = System.mapLibraryName(libraryName); for (Element element : nativeLibraryPathElements) &#123; String path = element.findNativeLibrary(fileName); if (path != null) &#123; return path; &#125; &#125;&#125; 在 sdk23 以上使用的是Element类，与上面类似，我们只需要把补丁 so 库完整路径作为参数构建一个 Element 对象，插入到 nativeLibraryPathElements 数组最前面。这种方案的特点： 可以修复三方库的 so 库，同时接入方不需要强制侵入用户接口调用； 需要对 sdk 做兼容适配，以 sdk23 为分界线，findLibrary 接口实现已经发生变化； 如何正确复制补丁 SO 库如果支持64位并且 apk 文件 libs 目录中存在 arm64-v8a，则 使用 arm64-v8a，否则检查是否是 32 位系统，如果存在 armabi-v7a，则使用 armabi-v7a，否则只能使用 armabi，具体可以参考 PMS 加载 SO 库的过程。补丁 so 库文件放到补丁包的 libs 目录，libs 目录和 .dex 文件和 res 资源文件打包成一个压缩文件作为补丁包，libs 目录可能包含多个 abis 目录，所以需要选择最合适的 primaryCpuAbi，然后从 libs 目录下选择 primaryCpuAbi 子目录插入到 nativeLibraryDirectories/nativeLibraryPathElements 数组中。所以关键点在于如何选取 primaryCpuAbi，在 sdk 中： sdk&gt;=21 时，直接反射拿到 Application 对象的 primaryCpuAbi 即可； sdk&lt;21 时，由于不支持 64 位，所以把 Build.CPU_ABI，Build.CPU_ABI2 作为 primaryCpuAbi 即可。此后拿到 primaryCpuAbi 便可可以构造 PathClassLoader 加载 so 库。 总结从稳定性出发，使用反射注入的方案进行 SO 库修复，重启生效，更具有普遍性，但是实时生效的需求也可以做到部分，只是存在着限制。 参考 Android 动态链接库加载原理及 HotFix 方案介绍 阿里Android热修复技术原理.pdf","tags":[{"name":"HotFix","slug":"HotFix","permalink":"https://hjw541988478.github.io/tags/HotFix/"},{"name":"SoLibHotFix","slug":"SoLibHotFix","permalink":"https://hjw541988478.github.io/tags/SoLibHotFix/"}]},{"title":"资源热修复探究(Part2)","date":"2017-07-21T13:43:00.000Z","path":"2017/07/资源热修复探究-Part2/","text":"资源热修复原理InstantRun分两步 构造新的 AssetManager，并反射调用 addAssetPath，把完整资源包加入到 AssetManager 中，这样得到一个含有所有新资源的 AssetManager； 找到所有之前引用到原有 AssetManager 地方，通过反射，把引用处替换为新的 AssetManager；addAssetPath 在 native 层由 c++ 实现，通过传入资源包路径，先得到 resources.arsc，然后解析它的格式，存放在底层的 AssetManager 的 mResources 成员中：1mutable ResTable* mResources; mResources 是一个 ResTable 结构体，其成员 mPackageGroups 为资源包的实体，包含所有解析过的资源包的集合，任何一个资源包都含有 resources.arsc，它记录了所有资源 id 分配情况以及资源中的所有字符串，以二进制形式存储，底层的AssetManager就是用来解析这个文件，把相关信息存储到 mPackageGroups 中。 资源文件的格式resources.arsc 文件实际上是一个个 ResChunk 拼接起来的，其结构：12345struct ResChunk_header &#123; uint16_t type; uint16_t headerSize; uint32_t size;&#125; 通过 type 字段可以知道这个 chunk 是什么类型的，从而知道如何解析这个 chunk，解析完成后，从chunk+size 的位置开始，得到下一个 chunk 的起始位置，这样一次读完整个文件的数据内容。一般来说，一个 resources.arsc 包含若干个 package，不过默认情况下只含有一个 package，包含了所有的资源信息。在 Android 中，资源编号是唯一的，由一个32位数字，十六进制如 0xPPTTEEEE，PP为 package id，TT为 type id，EEEE 为 entery id。 package id：每个 package 对应类型为 RES_TABLE_PACKAGE_TYPE 的 ResTable_package 结构体，其 id 表示它的 package id； type id：对应 RES_TATBLE_TYPE_SPEC_TYPE 的 ResTable_typeSpec 结构体，具体什么类型需要在 Type String Pool 中解析，一般有 attr、drawable、mipmap、layout字符串，一次对应的 id 为 1、2、3、4； entry id：表示一个资源项，比如第一个为 0x000，第二个为 0x001，依次自动编号； 运行时资源解析默认aapt工具打包的资源包的 package id 为 0x7f，系统资源包为 0x01，在 app 运行之前，系统已经为我们添加了：123456789# android.app.ResourceMananger.javaResources getTopLevelResources(....) &#123; AssestManager assets = new AssetManager (); if ( resDir != null） &#123; if ( assets.addAssetPath(resDir) == 0 ) &#123; return null; &#125; &#125;&#125; 这样，这个 AssetManager 里面就已经包含了系统资源包和 app 的安装包，也就是 package id 为 0x01 和 0x 7f 的app安装包资源。如果再次调用 addAssetPath 完整补丁包，由于补丁包也是 package id 也是 0x7f ，会发生什么呢？在 Android L 之后是没问题的，会把后来的包添加到之前的包的同一个 PackageGroup 下面。而在解析的时候，会与之前的包比较同一个 type id 对应的类型，如果资源项目数不一致，会打出一条 warning log，但是仍旧加入到该类型的 TypeList 中。在获取某个 Type 的资源时，从前往后遍历，也就是先获取原有安装包的资源，除非后面资源的 config 比前面更详细才会覆盖，而对于同一个 config 而言，补丁包的资源就永远无法生效了，所以在 Android L 以上版本，在原有的 AssetManager 直接加入补丁包是不起效的。而在 Android 4.4 以及以下版本， addAssetPath 只是把路径添加到 mAssetPath 中，真正解析资源包的逻辑在 app 第一次执行 AssetManager::getResTable 的时候 。而在执行到加载补丁代码的时候，getResTable以及执行过无数次了，所以也只是将路径添加到了 mAssetPath，并不会发生解析，也就是说，一定要一个全新的 AssetManager ，然后加入完整的资源包，替换掉原有的才行。 资源修复解决方案既要保证补丁包足够小，不在运行时占用资源，又有不侵入打包流程。即：构造一个 package id 在 0x01~0x7f 之间的资源包，只包含改变的资源项，然后在原有的 AssetManager 中 addAssetPath 这个包。 对于新增的资源，直接加入补丁包，然后在新代码里引用就可以了； 对于减少的资源，不使用就行； 对于修改的资源，视为新增资源，在打入补丁的时候，代码在引用处也会修改，也就是把原来使用的旧资源 id 变成新 id。 新增资源及其导致 id 偏移新增资源会导致所属 type 中在它们之后的资源 id 发生位移，比如 id 由 0x7f020002 变为 0x7f020003。新资源插入的位置是随机的，与 aapt 打包时解析 xml 的顺序有关，发生位移的资源不会加入 patch，但是在 patch 的代码中会调整 id 的引用处。 内容发生改变的资源重新编号新的 id ，并加入到 patch 中。 删除了的资源不影响补丁包。 对于 type 的影响如果 type0x01 的资源没有变化，那么 type0x01 的资源就不会加入到 patch 中，会使得后面的 type 的 id 往前移一位，因此 Type String Pool 的字符串也要修正，使得 0x01 的 type 指向 drawable，而不是原来的 attr。所以复杂的地方在于如何构造 patch，分析流程：把新旧的资源包解开，分别解析 resources.arsc 文件，对比不同，然后重新打成带有新 package id 的资源包。 优雅替换 AssetManager在 Android L 以后，直接在原有 AssetManager 上应用 patch 就行，这样省去反射替换操作，提高效率，但在 Android KK 以下版本， addAssetPath 不会加载资源，但我们也不想重新构造 AssetManager 的方式加入 patch，所以看看源码：12345# android/content/res/AssetManager.javapublic final class AssetManager &#123; private native final void init ( ); private native final void destroy ( ) ;&#125; init 方法用于在 native 层创建一个没有添加过的资源，并且 mResources 没有初始化的 AssetManager，然后再 addAssetPath，由于 mResources 没有初始化，这样就可以正常走到解析 mResources 逻辑，然后把资源 add 进去了；destroy 方法用于释放加载了资源，析构它所有的成员；实现代码：1234567891011121314151617Method initMeth = assetManagerMethod(\"init\");Method destroyMeth = assetManagerMethod(\"destroy\");Method addAssetPathMeth = assetManagerMethod(\"addAssetPath\", String.class);// 析构 AssetManagerdestroyMeth.invoke(am);// 重新构造 AssetManagerinitMeth.invoke(am);// 置空 mStringBlocksassetManagerField(\"mStringBlocks\").set(am, null);// 重新添加原有 AssetManager 中加载过的资源路径for (String path : loadedPaths) &#123; addAssetPathMeth.invke(am, path);&#125;// 添加 patch 资源路径addAssetPathMeth.invoke(am, patchPath);// 重新对 mStringBlocks 赋值assetManagerMethod(\"ensureStringBlocks\").invoke(am); mStringBlocks 记录着加载过得所有资源包的 String Pool，因此很多访问字符串是通过它找到的，如果不重新构造会崩溃。直接对原有 AssetManager 进行析构和重构，引用没有发生改变，避免了频繁修改，Instant Run 也是有优化空间的。 总结上述流程的优势： 不侵入打包流程，直接对比新旧资源产生补丁资源包（对比修改 aapt）； 不下发完整包，补丁包只包含变动资源（对比 Instant Run）； 不需要运行时合成完整包，不占用运行时计算和内存（对比 Tinker）；对资源修复的过程中，有个过程是查找旧的 id，替换成新的 id，如果恰巧使用到了 0x7f** 这样相等的值，那就有可能造成错误替换，但是罕见，不过也要注意它的存在。 参考 阿里Android热修复技术原理.pdf","tags":[{"name":"HotFix","slug":"HotFix","permalink":"https://hjw541988478.github.io/tags/HotFix/"},{"name":"ResourceHotFix","slug":"ResourceHotFix","permalink":"https://hjw541988478.github.io/tags/ResourceHotFix/"}]},{"title":"代码热修复探究(Part1)","date":"2017-07-20T12:22:00.000Z","path":"2017/07/代码热修复探究-Part1/","text":"热修复技术介绍代码修复技术底层替换：已经加载的类直接替换原有方法，由于修改了原来的类，导致方法数的变化，索引无法正常工作，不稳定，可能产生无法预知的结果；类加载：在 app 重新启动后让 classloader 加载新的类，由于已加载的类无法卸载，于是不重启无法加载新类，在重启以后，赶在业务逻辑之前抢先加载补丁的新类，达到热修复的目的。市场主流方案选择： QZoneFix：侵入打包流程，不优雅； QFix：获取底层虚拟机函数，不稳定； Tinker：全量dex加载，粒度过细，性能消耗过大； 资源修复 构造新的 AssetManager，反射调用 addAssetPath，把完整新资源包加入 AssetManager 中； 找到所有引用原 AssetManager 地方，通过反射，把引用处替换成新的。优点： 只使用一个 package id 为 0x66 的资源包，该包只包含了改变了资源，然后直接在原 AssetManager 中 addAssetPath； 不修改 AssetManager 引用处； 不必下发完整包； 不需要在运行时合成完整包；SO库修复SO 库修复本质是对 native 方法的修复和替换。采用类似修复反射注入的方式，把补丁的路径插入到 nativeLibraryDirectories 数组的最前面，达到加载到的 so 库是补丁库，达到修复目的。 代码热修复技术### 底层热替换1memcpy(smeth, dmeth, sizeof(ArtMehod)); 不替换 ArtMethod 的成员，而是整个替换；由于 sizeof 计算可能有偏差，使用内部起止方法的地址差值作为 methSize 便可以解决问题；这里关键点便是，忽略 ArtMethod 结构差异，使用统一的 memcpy，只要保证 ArtMethod 数组以线性结构排列，就可以适配。 权限问题dex2oat 生成 AOT 机器码是会做一些检查和优化的，由于 dex2oat 编译机器码时确认了两个方法属于同一个类，所以便不会存在权限问题。在补丁类访问同包名其他类，会存在权限问题，是因为补丁包使用的类加载器不是原来的 classloader，也只需要设置新类的 classloader 为原来的 classloader 便可以了。 反射调用非静态方法热替换的非静态方法，在反射调用时，由于 VerifyObjectlsClass 新旧类不匹配，导致检验不通过，而静态方法是在类级别上的，也就不需要接收对象实例作为参数，自然不会存在这个问题； 及时生效的限制只支持方法的替换，无法增加或减少方法以及成员字段的增加或减少。是因为补丁类中方法的增加或减少，导致 Dex 方法数的变化，从而导致索引的变化，这样访问方法时无法索引到正确的方法了。总之，2种限制情况： 引起原有类结构变化的修改 修复的非静态方法会被反射调用时 Java知识基础内部类编译内部类会在编译期被编译为跟外部类一样顶级的类，非静态内部类持有外部类引用，而静态内部类不持有。 内部类与外部类互相访问外部类为了访问内部类私有域/方法，编译期会为自动类生产 access&amp;** 方法，用于返回其值或者相关方法给内部类使用； 热部署解决避免自动生成 access&amp;*** 方法： 一个外部类如果有内部类，把所有 method/field 的 private 访问权限改成 protected 或者 default 或者 public； 内部类所有 method/field 的 private 权限改成 protected 或者默认权限； 匿名内部类编译 编译规则匿名内部类的格式一般是外部类 &amp;numble，后面的 numble 是编译期根据该匿名内部类在外部类中出现的先后关系，依次累加命名； 解决方案匿名内部类插入到外部类末尾是允许的，其他都是不可取的； 域编译 静态域与非静态域不支持 修复，这个方法在 Dalvik 虚拟机类加载的时候进行类初始化的时候调用，是 android 编译器自动合成的方法，静态 field 和代码块的初始化会被编译在 中； 静态 field 初始化与静态代码块静态代码块和静态域初始化在 clinit 中的先后关系就是在源码中的先后关系，类加载初始化的时候，一个类仅加载一次，可能会导致加载一个类的情况： new一个类的对象； 调用类的静态方法； 调用静态域的值；执行流程：dvmResolveClass-&gt;dvmLinkClass-&gt;dvmInitClass，类的初始化在第三步，先对父类初始化，然后才调用本来的 clinit 方法； 非静态 field 初始化和非静态代码块被翻译在 默认无参构造函数中，其执行顺序和源码顺序一致。如果是有参构造函数，每个有参构造函数都会执行一个非静态域和非静态代码块的初始化； 在类加载初始化的时候被调用， 在类对象初始化时候被调用，类似下面这样String s = new String(&quot;test&quot;);12new-instance v0, Ljava/lang/String;invke-direct &#123;v0&#125;, Ljava/lang/String; -&gt; &lt;init&gt;()V 首先分配堆内存，如果类没加载过则尝试加载类，然后指令调用类的init构造函数方法进行对象初始化； 热部署解决方案由于不支持 方法热部署，只能冷启动生效。但是非静态 field 和代码块被翻译到 中，可以热部署； final staitic 域编译final static 域并没有翻译到 clinit 方法中； final static 域编译规则 final static 修饰的原始类型和 String 类型域（非引用类型），并不会翻译在 clinit 方法汇总，而是在 initSFields 方法中初始化； final static 修饰的引用类型仍然在 clinit 中； final static 域优化如果一个 field 是常量，那么使用 static 修饰，其实只对原始类型和 String 类型有用，对于引用类型是没有任何优化的； 热部署方案 修改 final static 基本类型或者 String 类型（非引用类型）域，由于编译期间引用基本类型地方被立即数替换，引用到 String 类型（非引用类型）地方被常量池索引 ID 替换，所以可以热更； 修改 final static 引用类型域是不允许的，因为会翻译 clinit 方法，所以没法热部署； 方法编译 应用混淆方法编译除了以上内部类/匿名内部类可能会造成 method 新增，混淆也有可能导致方法的内联和裁剪，导致 method 的增加或减少； 方法内联 方法没有被其他任何地方运用到； 方法简单，比如只有一行会被内联掉； 方法只被一个地方引用，会被替换掉； 方法裁剪有参的方法会被裁剪成无参的方法，那么只能冷启动； 热部署解决加上 -dontoptimize 参数即可；混淆步骤：input jars -&gt;shrink -&gt;optimize -&gt;obfuscate -&gt; preverify -&gt; output jarsoptimize：不是入口的类和方法被设置为 private、static 或 final，无用参数被移除，一些方法可能会被内联或者裁剪，因此最好加上 -dontoptimize 参数；preverification：对 .classs 预校验，在 .class 文件加上 StackMapTable 信息，这样在类校验阶段省去步骤，加载更快，android 中有自己的校验逻辑 dvmVerifyClass，所以最好加上 -dontpreverify 参数； switch case 语句编译一个资源 id 肯定是 const final static 遍历，如果 switch case 语句被翻译成 packed-switch 指令，修改 smali 反编译流程，将 packed-switch 指令强转为 sparese-switch 指令，:pswitch_N 强转为 :sswitch_N 指令，然后替换资源 id，回编译 smali 为 dex，步骤为反编译-&gt;资源id替换-&gt;回编译； 泛型编译泛型完全在编译器中实现，由编译器执行类型检查和类型推断，然后生成普通的非泛型字节码，这种技术叫做擦除，编译器使用泛型类型保证类型安全；Java5 才引入泛型，扩展虚拟机指令集是不可取的，所以采用完全在编译器中实现擦除方法。泛型在编译器实现，生成的字节码是不包含泛型中的类型信息的，使用参数时会在编译时候去掉，这个过程称为类型擦除； 类型擦除与多态的冲突和解决1234567891011121314151617181920212223class A&lt;T&gt; &#123; private T t; public T get() &#123; return t; &#125; public void set(T t) &#123; this.t = t; &#125;&#125;class B extends A&lt;Number&gt; &#123; private Number n; @Override public Number get() &#123;&#125; @Override public void set(Number n) &#123;&#125;&#125;class C extends A &#123; private Number n; @Override public Number get() &#123;&#125; @Override public void set(Number n) &#123;&#125;&#125; @Override表明方法可以重写，也就是子类中的方法与父类的具有相同的方法名，返回类型和参数表。受类型擦除影响，A 类中 set(T t) 在字节码中实际上是 set(Object t)，B的 set(Number n)方法参数不一样，所以此时类 B 的 set 方法为重载，而本意为重写，实现多态，可是类型擦除后变成了重载，这样存在了冲突。 但实际上，JVM 在字节码中使用了 bridge 方法完成重写。可以得到的结论就是：子类中真正完成重写基类方法的是编译器自动合成的 bridge 方法，而类 B 定义的 get 和 set 方法上面的 @Override 只不过是假象，bridge 方法内部实现调用重写的 print 方法。虚拟机巧妙的使用了桥方法解决了冲突问题。一般情况下，方法的重载只能以方法参数表区分而无法以返回类型区分，但虚拟机却允许这么做，是因为编译器为了泛型的多态的实现。 泛型类型转换编译器发现如果有一个变量的申明加上了泛型类型的话，编译器会自动加上 check-cast 类型转换，而不需要在源码中强制类型转换，只是因为类型转换编译器自动帮我们完成了而已。 热部署解决方案在类型擦除中，如果 B extends A 变成了 B extends A，那么会增加对应的桥方法，此时新增方法，只能冷部署。泛型方法内部实际上会生成一个 dalvik/annotation/Signature 系统注解，如果更换签名，泛型的类型擦除，方法的逻辑实际上没有发生任何变化，只是注解发生了变化而已。所以再热部署中，避免这种性能的修复。 Lambda 表达式编译java7 引入的一种表达式，类似匿名内部类，但是也有区别，也有可能导致方法的新增和减少。 Lambda 编译规则函数式接口主要特征，是一个接口，这个接口具有唯一的抽象方法，我们将满足这两个特性的接口称为函数式接口。java.lang.Runnable 和 java.util.Comparator 是典型的函数式接口，与匿名内部类的区别： 关键字 this 匿名类的 this 关键字指向匿名类，而 lambda 表达式的 this 关键字指向包围的 lambda 表达式的类； 编译方式，Java 编译器将 lambda 表达式编译成类的私有方法，使用 invokedynamic 字节码指令动态绑定这个方法，奖匿名内部类编译成外部类 &amp;numble 的新类；比较匿名内部类与 Lambda 表达式的字节码可以发现： 编译期间自动生成私有静态的 lambda$main$*() 方法，这个方法的实现就是 lambda 表达式里面的逻辑； invokedynamic 指令执行 lambda 表达式； 相比较匿名内部类的区别，没有生成外部类 &amp;numble 的新类；invokedynamic 指令：指令执行时，实际上会去调用 java/lang/invke/LambdaMetafactory 的 metafactory 静态方法，这个静态方法实际上会在运行时生成实现函数式接口的具体类，然后具体类会调用私有静态 lambda$main$*() 方法。当然这只是对标准 JVM 的执行而言。android 虚拟机中会先把 javac 编译成 .class，然后再通过 dx 工具优化成适合移动设备的 dex 字节码文件。但是如果要使用 Java8 语言特性，还需要新的 Jack 工具链才行。Jack 将源码编译成 Android 可读取的 Dalvik 可执行字节码，.jack 格式，它可以将源码直接编译成 Dalvik 字节码。对比发现，旧版本的 javac ：javac(.java -&gt; .class) -&gt; dx(.class -&gt; .dex)新版本：Jack(.java -&gt; .jack -&gt; .dex)反编译 .dex 字节码对比 .class 字节码可以看到：共同点：编译期间为外部类合成一个 static 辅助方法，内部逻辑实现 lambda 表达式；不通点：1. class 字节码通过 invokedynamic 指令执行 lambda 表达式，而 .dex 字节码执行 lambda 表达式跟普通方法没差； 2. .class 字节码运行时生成新类，.dex字节码在编译期生成新类； 热部署解决方案新增一个 lambda 表达式，会导致外部类新增一个辅助方法，所以不支持热部署，可以看到合成类名的规则 Test$$Lambda$void_main_java_lang_String_args_LamdaImp10.smali：外部类名+Lambda+Lambda 表达式所在方法的签名+LambdaImpl+出现的顺序号，构成的合成类。所以如果增加或者减少 Lambda 表达式，会导致类方法乱套。那么对于只修改 lambda 内部逻辑，如果 lambda 表达式访问外部类的非静态 field/method 场景，如果生成的辅助类一开始没有持有外部类的引用，而修改后需要持有外部类的引用，这样就会导致热部署失败。 增加/减少一个 lambda 表达式会导致类方法错乱，所以热部署失败； 修改一个 lambda 表达式，可能导致新增 field，也会热部署失败。 访问权限检查对热替换的影响 类加载阶段父类/实现接口访问权限检查一个类的加载，必须经历 resolve -&gt; link -&gt; init 三个阶段，父类/实现接口权限检查发生在 link 阶段。1234567891011bool dvmLinkClass( ) &#123; for(...) &#123; if (!dvmCheckClassAccess(..interface)) &#123; &#125; ... ... ... else if (!dvmCheckClassAccess(..super)) &#123; &#125; &#125;&#125; 通过源码可以看到，会先对实现的接口和父类进行访问权限检查，如果当前类和实现接口/父类是非 public，同时加载两者的 classLoader 不一样的情况下，会 return false。所以如果不进行任何处理的话，那么在类加载阶段就报错。 类校验阶段访问权限检查在单独的补丁 dex 中，如果需要加载这个 dex，必须进行 dexopt，dexopt 会执行 dvmVerifyClass 校验 dex 每个类，方法调用链为：dvmVerifyClass 校验类 -&gt; verifyMethod 校验类中方法 -&gt; (dvmVerifyCodeFlow -&gt; doCodeVerification) 对每个方法逻辑校验 -&gt;verifyInstruction 校验指令。所以可以看到，补丁类中如果引用了非 public 类，那么 verifyInstruction 方法执行的结果会更新为潜在的错误指令码，最后会抛出异常，程序中断。 &lt;clinit&gt;方法如果使用热部署的话，那么就没法改变类结构以及无法改变方法，所以此时只能走冷启动生效。 冷启动类加载原理冷启动实现方案概述qzone：单独放一个帮助类在 dex 中让其他类调用，阻止类被打上 CLASS_ISPREVERIFIED 标志，最后加载补丁 dex 得到 dexFile 对象作为参数构建一个 Element 对象插入到 dexElements 数组最前面。没有合成完整包，产物小。Dalvik 下影响类加载性能，Art 下类地址写死，导致必须包含引用，补丁包大。Tinker：提供 dex 差量包，整体替换 dex 方案。差量得到 patch.dex 与 classes.dex 合并得到完整dex，替换原来的 dexElements 数组。补丁包小，dex merge完成合并操作，不影响性能 dex 消耗在 vm heap 上，容易 OOM，导致合并失败。 dex merge ：在 java 层面的，所有对象分配都是在 java heap 上，如果此时进程申请的 java heap 对象超过了 vm heap 的大小，那么进程可能会发生 OOM，导致合成失败。另外在 jni 层面 C++ new/malloc 申请的内存分配在 native heap 中，native heap 的增长并不受 vm heap 大小限制，如果 ram 不足也会被杀死闪退。如果从 dex merge 方面思考，只在 jni 层面进行 dex merge，可以提高 dex 合并成功率，避免 OOM。 插桩实现前因后果加载一个 dex 文件到本地内存的时候，如果不存在 odex 文件，那么首先会执行 dexopt，dexopt 的入口在 dalvik/opt/OptMain.cpp 的 main 方法中，最后调用 verifyAndOptimizeClass 执行真正的 verify/optimize 操作。123456789101112131415161718static void verifyAndOptimizeClass(....) &#123; if (doVerify) &#123; if (dvmVerifyClass(clazz)) &#123; ( (DexClassDef*) pClassDef) -&gt; accessFlags |= CLASS_ISPREVERIFIED; verified = true; &#125; &#125; if (doOpt) &#123; bool needVerify = (gDvm.dexOptMode == OPTIMIZE_MODE_VERIFIED || gDvm.dexOptMode == OPTIMIZE_MODE_FULL); if (!verified &amp;&amp; needVerify() &#123; .... &#125; else &#123; dvmOptimizeClass(clazz, false); ( (DexClassDef*)pClassDef) -&gt;accessFlags |= CLASS_ISOPTIMIZED; &#125; &#125;&#125; apk 第一次安装的时候，会对原 dex 执行 dexopt，假如只有一个 dex，所以 dvmVerifyClass(clazz) 结果为 true。所以 apk 中所有的类都会被打上 CLASS_ISPREVERIFIED 标志，接下来执行 dvmOptimizeClass，接着被打上 CLASS_ISOPTIMIZED 标志。 dvmVerifyClass：类校验，防止类被篡改，校验类的合法性。如果所有的类的所有方法中直接引用到的类（第一层）和当前类在同一个 dex 中的话，dvmVerifyClass 会返回 true。 dvmOptimizeClass：类优化，把部分指令优化成虚拟机内部指令，比如 invoke- 变成 invoke–quick，quick 指令从类的 vtable 表中直接取，vtable 是类的所有方法的一张大表，加快执行速率。假如 A 类是补丁类，所以补丁 A 类在单独的 dex 中，类 B 中某个方法引用到类 A，所以此时会解析类 A :1234567891011ClassObject * dvmResolveClass( ... ) &#123; ... // 如果类被打上了 CLASS_ISPREVERIFIED 标志 if ( !fromUnverifiedConstant &amp;&amp; IS_CLASS_FLAG_SET(referrer, CLASS_ISPREVERIFIED)) &#123; if (referrer -&gt; pDvmDex != resClassCheck -&gt; pDvmDex &amp;&amp; resClassCheck -&gt; classLoader != null ) &#123; dvmThrowIllegalAccessError(\"Class ref in pre-verified class resolved to unexpected implementation\"); return NULL; &#125; &#125; ...&#125; 由于类 B 被打上了 CLASS_ISPREVERIFIED 标志，接下来 referrer 是类 B，resClassCheck 是补丁类 A，他们属于不同的 dex，所以 dvmThrowIllegalAccessError。为了解决这个问题，一个单独无关帮助类放在一个单独的 dex 中，原 dex 中所有类的构造函数都引用这个类，一般实现方法都是侵入 dex 打包流程，利用 .class 字节码修改技术，在所有 .class 文件的构造函数中引入这个帮助类，插桩由此而来。又由于 dvmVerifyClass 类校验返回 false，原 dex 中所有类都没有 CLASS_ISPREVERIFIED 标志，因此解决运行时的这个异常。但是插桩会带来严重的效率问题，在 Dalvik 虚拟机中，一个类的加载一般分为三个阶段：dvmResolveClass -&gt; dvmLinkClass -&gt; dvmInitClass。dvmInitClass 阶段在类解析完毕开始初始化，这个方法主要完成父类的初始化，当前类的初始化，static 变量初始化赋值等。123456789101112131415bool dvmInitClass(ClassObject* clazz) &#123; if (clazz -&gt; status &lt; CLASS_VERIFIED) &#123; // 如果类还未打上 CLASS_ISPREVERIFIED 标志 clazz -&gt; status = CLASS_VERIFYING; if (!dvmVerifyClass(clazz)) &#123; ... &#125; clazz -&gt; status = CLASS_VERIFIED; &#125; // 如果类还没打上 CLASS_ISOPTIMIZED 标志 if (!IS_CLASS_FLAG_SET(clazz, CLASS_ISOPTIMIZED) &amp;&amp; !gDvm.optimizing) &#123; dvmOptimizeClass(clazz, essentialOnly); SET_CLASS_FLAG(clazz, CLASS_ISOPTIMIZED); &#125; ...&#125; 类在初始化时，如果类未被打上 CLASS_ISPREVERIFIED/CLASS_ISOPTIMIZED 标志，那么会进行 verify 和 optimize 操作。正常情况下，这两个操作是在 apk 第一次安装执行 dexopt 进行的，而类的 verify 是很重的，会对所有方法的所有指令进行校验，如果同时加载大量类的话，耗时会被放大，影响效率了。 插桩导致类加载性能影响 dexopt过程 如果采用插桩所有类非 preverify，导致 verify 和 optimize 会在加载类时出发。经过数据测试发现，平均每个类 verify + optimize 耗时并不长，而且每个类只会有一次，但应用启动时同时加载大量类，容易白屏。 避免插桩的 QFix 方案 dvmResolveClass绕过 想让 dvmDexGetResolvedClass 返回不为 null，只需调用过一次 dvmDexSetResolvedClass(pDvmDex, classIdx, resClass); 就行，举个例子：12345public class B &#123; public static void test () &#123; A.a(); &#125;&#125; 需要 patch 的是类 A，所以类 A 被打入到独立的 dex 中。当执行到类 B 的 test 方法时，会去解析类 A，此时 dvmResolveCLass(const ClassObject* referrer, u4 classIdx, bool fromUnverifiedConstant) : referrer：实际上是类 B classIdx：类 A 在原 dex 文件结构的索引 id fromUnverifiedConstant：是否 const-class/instance-of 指令此时调用 A 的静态 a 方法，invoke-static 指令不属于 const-class/instance-of 任意一个。不做处理的话，dvmDexGetResolvedClass 一开始是 null 的，然后 A 从补丁 dex 解析加载，B 是在原 dex 中，A 在补丁dex 中，所以 B -&gt; pDvmDex != A -&gt; pDvmDex，接下来抛异常。所以需要修改的地方在于，一开始的时候，把补丁 A 类添加到原来 dex(pDvmDex) 的 pResClasses 数组中。具体实现： preResolveClz：需要 patch 的类 A 描述符，为了调试加上而已； refererClz：需要 patch 的类 A 所在 dex 的人和一个类描述符，不限定必须是引用补丁类 A 的某个类，实际上只要是同一个 dex 任何一个即可。 classIdx：需要 patch 的类 A 在原 dex 文件中的索引 id。然后通过 dlopen 拿到 libdvm.so 库的句柄，再通过 dlsym 拿到 so 库的 dvmResolveClass/dvmFindLoadedClass 函数指针。首先需要预加载引用类 android/support/annotation/AnimRes，这样 dvmFindLoadedClass(“android/support/annotation/AnimRes”) 才不会为 null ， dvmFindLoadedClass 执行结果得到的 ClassObject 作为第一个参数执行 dvmResolveClass(AnimRes, 2425, true) 即可。看看解决方案：12345678910111213jboolean resolveColdPatchClasses(JNIEnv *env, jclass clz, jstring preResolveClz, jstring refererClz, jlong classIdx, dexstuff_t *dexstuff) &#123; // 先调用 dvmFindLoadedClass ClassObject *refererObj = dexStuff-&gt;dvmFindLoadedClass_fnPtr(JString2CStr(env, refererClz)); if (strlen(refererObj-&gt;descriptor) == 0) &#123; return JNI_FALSE; &#125; // 再调用 dvmResolveClass ClassObject *resolveClass = dexStuff -&gt; dvmResolveClass_fnPtr(refererObj, classIdx, true); if (strlen(resolveClass-&gt;descriptor) == 0) &#123; return JNI_FALSE; &#125; return JNI_TRUE;&#125; 无需 hook 系统方法，直接在 native 层调用，无需插桩，需要注意的是： dvmResolveClass 的第三个参数 fromUnverifiedConstant 必须为 true； apk 多 dex 情况下，dvmResolveClass 第一个参数 referrer 类必须跟需要 patch 的类在同一个 dex，但是无需存在引用关系，任何一个在同一个 dex 中的类都可以作为 referer； referer 类必须提前加载；然而 QFix 方案是在 dexopt 后进行绕过的，dexopt 会改变原先的很多逻辑，许多 odex 层面的优化会写死字段和方法的访问便宜，会导致严重的 BUG。 Art 下冷启动实现为了减少补丁包的大小，并没有为热部署和冷启动分别准备补丁，而是同一个热部署模式下的补丁能降级走冷启动，所以无需 dex merge。为了解决 Art 下类地址写死的问题， tinker 通过 dex merge 一个新的完整新 dex 替换就的 dexElements 数组。但事实上，Art 虚拟机默认支持多 dex 加载了。来具体分析 DexFile.loadDex 把一个 dex 文件解析到加载到 native 内存都发生了什么，都是调用了 DexFile.openDexFileNative 这个 native 方法。openDexFileNative -&gt; dvmJarFileOpen：Dalvik 下：static const char* kDexInJarName = “classes.dex”，明显 Dalvik 尝试加载一个压缩文件只会把 classes2.dex 加载到内存，如果存在着多 dex，那么会被忽略掉。Art 下：DexFile_openDexFileNative -&gt; openDexFilesFromOat -&gt;LoadDexFiles：Art 下面可以看到默认支持加载多 dex，优先加载 primary dex，即 classes.dex，后续加载其他dex。所以得到的 Art 下冷启动方案：把补丁命名为 classes.dex，原 APK 中的 dex 一次名为 classes(2,3,4..）.dex 就好，然后一起打包成一个压缩文件。然后 DexFile.loadDex 得到 DexFile 对象，最后把 DexFile 对象替换旧的 dexElements 数组就好。 新的Art下补丁包方案 需要注意的是： 补丁 dex 必须命名为 classes.dex； loadDex 得到的 DexFile 完整替换掉 dexElements 数组而不是插入； 其他点DexFile.loadDex 尝试把一个 dex 文件解析并加载到 native 内存，在加载到 native 内存之前，如果 dex 不存在对应的 odex，那么 Dalvik 下会执行 dexopt，Art 下会执行 dexoat，最后得到的都是优化后的 odex，实际上虚拟机执行的也是 odex 而不是 dex。如果 dex 足够大，那么 dexopt/dexoat 是很耗时的，Dalvik 影响比较小，因为 loadDex 仅仅是补丁包，但 Art 影响还是很大的，因为 loadDex 是补丁 dex 和原 dex 合并成的完整压缩包，所以 dexoat 非常耗时，所以如果优化后的 odex 没生成完整的 odex 时，会一直阻塞主线程。所以，我们可以把 loadDex 当做一个事务来看，如果被打断，则删除 odex 文件，重启的时候发现存在 odex 文件，loadDex 完后，反射注入 dexElemens 数组，实现 patch，如果不存在 odex 文件，则重启子线程 loadDex，重启后再生效。再者为了安全性考虑，我们再虚拟机执行 odex 的时候，还需要对 odex 文件进行 md5 完整性校验，如果不匹配，重新生成 odex 文件。 完整方案考虑Dalvik 下采用全量 dex 方案，Art 下，由于默认支持多 dex 加载， 把补丁dex 作为主dex加载。 多态对冷启动类加载影响重新认识多态实现多态的技术叫做动态绑定，指在执行期间判断引用对象的实际类型，根据其实际类型调用相应方法。一般指非静态非 private 方法，field 和 静态方法不具有多态性。1A b = new B()； 我们来分析下一个多态对象的实现，B 是 A 的子类，在执行 new 实例化 B 之后，尝试加载类 B，方法调用链 dvmResolveClass -&gt; dvmLinkClass -&gt; createVtable，此时类 B 创建一个 vtable，其实虚拟机中加载每个类都会为这个类生成一张 vtable 表，vtable 表就是当前类所有 virtual 方法的一个数组，当前类和所有继承父类的 public/protected/default 修饰的方法是可以被继承的。 private static 不属于。也就是说子类 vtable 的大小，等于子类 virtual 方法数 + 父类 vtable 大小： 整个复制父类 vtable 到子类的 vtable； 遍历子类的 virtual 方法集合，如果方法原型一致，说明是重写父类方法，子类重写方法覆盖掉 vtable 中父类方法； 方法原型一致，则追加到 vtable 末尾；如果父类A，vtable 为 vtable[0]=A.a_t1，vtable[1]=A.a_t2，那么子类B vtable为 vtable[0] = B.a_t1，vtable[1] = A.a_t2 ，vtable[2] =B.b_t1；而 field/static 为啥不具有多态性，是因为当前遍历的引用类型查找而不是从实际类型中查找，如果找不到父类才会递归查找。 冷启动方案限制1234567891011public class Demo &#123; public static void test_addMethod() &#123; A obj = new A(); obj.a_t2(); &#125; class A &#123; int a = 0; void a_t1 -&gt; print \"a_t1\"; void a_t2 -&gt; print \"a_t2\"; &#125;&#125; 修复后新增了 a_t1 方法，运行后发现输出的竟然是 “a_t1”，重新分析下原因：dex 文件第一次加载的时候会进行 dexopt，包含了两个过程：verify + optimize；其中 optimize 过程指在优化虚拟机指令，重写 invoke-virtual 为 invoke-virtual-quick，紧接着跟着立即数，就是方法在 vtable 的索引值。invoke-virtual-quick 相比 invoke-virtuak 效率更高，直接从实际类型 vtable 取，省去了 dvmResolveMethod 从变量引用类型到 vtable 索引 id的过程。所以可以理解错乱的原因是因为，在 odex 中，调用此方法的立即数对应了 patch 后的 a_t1 方法。 终极解决方案由于多态的影响，QFix 无法进一步实施，可能也只能像 tinker 一样完整 dex 方案解决了。利用 google 已经开源的 dexmerge 方案，把补丁 dex 和原 dex 合并才完整的 dex，但也要考虑到 65535 方法数异常，内存不足导致失败，毕竟完整的 dex 合成在移动端进行还是相对复杂的。 Dalvik下完整 DEX 方案的探索冷启动类加载修复最早的实现方案是 Q-Zone 提出的 dex 插入方案，主要思想是，插入新 dex 到 ClassLoader 索引路径的最前面，这样在 load 一个 class 的时候，会被优先找到补丁中的。Tinker 和 QFix 在此基础上做了改进，但遇到的共同的问题都是，如何解决在 Dalvik 下类的 pre-verify 问题。比较三大框架： Q-Zone 处理方式是，在每个类中插入一个来自其他 dex 的 hack.class，由此让所有类都无法满足 pre-verified 条件； Tinker 的方式，合成全量 Dex 文件，这样所有 class 都在全量 dex 中解决，消除 class 重复带来的冲突； QFix 的方式，取得虚拟机中某些底层函数，提前 resolve 所有补丁类，绕过 pre-verify 检查；总结可以发现，Q-Zone 方案会侵入打包流程，实现并不优雅，而 QFix 方案需要获取底层虚拟机函数，不够稳定可靠，而且比较大的问题是无法新增 public 函数。现在看来 Tinker 全量合成完整新 dex 是个不错的方案，但是缺点在于粒度过细，实现复杂，性能消耗严重。 新的全量 Dex 方案思路就是原来的 dex 和 patch 里的 dex 重新合并成一个，对于补丁中变动的类，把原来基线包 dex 里面的已有的 class 去掉，也就是补丁 + 去除补丁类的基线包。在 Android 原生的 multi-dex 中，把一个 apk 所有类拆分成 classes.dex、classes2.dex … classesN.dex，每个 dex 只包含了部分类的定义，但单个 dex 也是可以加载的，只要把所有的 dex 都 load 进去，本 dex 中不存在的类就可以在运行期间在其他 dex 中找到。在基线包 dex 里面在去掉了补丁 class 后，基线包 dex 里就只包含不变的 class ，而这些不变的 class 要用到补丁中新 class 时会自动找到补丁dex，补丁包新 class 在需要用到不变的 class 时也会找到基线包 dex 的 class，这样的话，基线包里面不使用补丁类的 class 仍旧可以按照原来的逻辑做 odex ，最大化保证 dexopt 效果。这样的话，我们不再需要像传统合成的思路判断类的增加和修改情况，而且也不需要处理合成时方法数超过的情况，对于 dex 结构也不需要破坏性重构，已经完全把问题简化为了如何在基线包 dex 里面去掉补丁包包含的所有类。观察 DexHeader 结构体，可以取得 dex 的各个属性，取得 class_defs 属性，在我们解析这个 dex 的时候，移除定义的入口，而对于 Class 的具体内容不进行删除，可以最大可能地减少 offset 的修改。一个类所有的 DexClassDef ，也就是类定义，是从 pHeader-&gt;classDefsOff 偏移处开始的，一个接一个地线性排列，一个 dex 里面一共有 pHeader -&gt; classDefsSie 这个类定义。这样我们这可以找到 pHeader-&gt;classDefsOff 偏移处，一个个遍历所有 DexClassDef，如果 DexClassDef 的类名包含在我们补丁中就把它移除。 Dex 中 ClassDef 的移除 接着只要修改 pHeader-&gt;classDefsSize，变成去除补丁类之后的数目即可。而对于类的实体及其他 dex 信息不做移除，这样会把这个被移除类的无用信息残留在 dex 中，并不会有多大影响。 对于 Application 处理Application 作为 app 的入口，在进入到替换完整的 dex 之前，一定会通过 Application 的代码，因此，Application 必然是加载在原来的老 dex 里面，只有在补丁加载后使用的类，会在新的完整 dex 里面找到。因此在加载补丁后，如果 Application 类使用了新 dex 里的类，由于不在同一个 dex ，如果 Application 被打上了 pre-verified 标志，会抛异常：java.lang.IllegalAccessError：Class ref in pre-verified class resolved unexpected implementation. 解决方法为清除 pre-verified 标志，类的标志位于 ClassObject 的accessFlags 成员，而 pre-verified 标志定义是1CLASS_ISPREVERIFIED = (1&lt;&lt;16) // class has been pre-verified. 因此只需要在 jni 层清楚掉它即可：1clazzObj -&gt; accessFlags &amp;= ~CLASS_ISPREVERIFIED; 这样在 dvmResolveClass 找到了新 dex 里的类后，由于 CLASS_ISPREVERIFIED 标志被情况，所以不会判断所在 dex 是否相同，从而成功避免抛出异常。对于这个问题，看看其他方案的做法。Tinker 在 AndroidManifest.xml 声明中要求开发者将自己的 Application 直接替换成 TinkerApplication，而真正的 Application，要在初始化 TinkerApplication 作为参数传入，这样 TinkerApplication 会接管这个传入的 Application，在生命周期回调时通过反射的方式调用实际 Application 的相关逻辑，但接入成本高。Amigo 是在编译过程中，用自定义的 gradle 插件将 app 的 Application 替换成 Amigo 的另一个 Application，并且将原来的 Application 的 name 保存起来，在修复完成之后再调用之前保存的 Application 的 attach(context)，然后将它设回到 loadedApk 中，最后调用其 onCreate()，执行原来 Application 中的逻辑。其实掩耳盗铃，对系统反射替换存在着稳定性的风险。 dvmOptResolveClass 问题与对策上面的清除标志方案并不顺利，在开发工程中，发现如果入口 Application 没有 pre-verified ，反而更有问题。问你是，Dalvik 虚拟机如果发现某个类没有 pre-verified，就会在初始化这个类的时做 verified 操作，这将扫描这个类的所有代码，在扫描过程中对这个类代码里使用到的类都要进行 dvmOptResolveClass 操作。dvmOptResolveClass 会在 Resolve 的时候对使用到的类进行初始化，在一个 app 生命周期中，没有可能比 Application 初始化更早的时期了。在多 dex 时，无法保证 Application 的用到的类和它处在同一个 dex 中，如果只有一个 dex，一般不会有问题。多 dex 中要解决这个问题： 第一种办法，让 Application 用到的所有非系统类和 Application 位于同一个 dex 里，这样保证 pre-verified 标志被打上，避免进入 dvmOptResolveClass，而在补丁加载完后，再清除 pre-verified 标志，保证使用其他类不会报错； 第二种办法，让 Application 里面除了热修复框架代码以外的其他代码都单独放在一个其他类里面，这样使得 Application 不会直接用到过多非系统类，这样保证这个单独拿出来的类和 Application 处于同一个 dex 的几率还是比较大的，如果更保险的方式，Application 可以采用反射方式访问这个类，这样彻底把 Application 和其他类隔绝开。 第一种方法实现，官方 multi-dex 机智就是自动将 Application 用到的类都打包到主 dex 中，因此只要把热修复初始化放在 attachBaseContext 最前面就没有问题了。但是第二种可以一劳永逸地解决问题。 参考 阿里Android热修复技术原理.pdf","tags":[{"name":"HoxFix","slug":"HoxFix","permalink":"https://hjw541988478.github.io/tags/HoxFix/"},{"name":"CodeHotFix","slug":"CodeHotFix","permalink":"https://hjw541988478.github.io/tags/CodeHotFix/"}]},{"title":"Android基础之Activity","date":"2017-07-13T11:52:00.000Z","path":"2017/07/Android基础之Activity/","text":"生命周期 生命周期 onCreate：生命周期只调用一次，用于初始化、必要对象创建等； onStart：界面完全不可见变为可见时调用； onResume：界面可点击交互，不被顶层任何其他Activity遮挡，开始执行界面交互； onPause：界面交互不可点击，部分可见，此时应该停止交互相关的耗资源操作； onStop：界面完全不可见，保存重要数据，在被强杀时onDestroy不会被调用； onDestroy：生命周期只会被调用一次，界面完全被销毁，用于释放资源等； onRestart：界面onStop后重新被打开调用； onPause和onStop调用时机？ 当Activity A打开透明熟悉的 B时，A只会调用onPause，onStop不会调用，A部分可见不可交互，此时按返回键关闭B，只会调用A的onResume，A.onResume -&gt; A.onPause -&gt; B.onCreate -&gt; B.onStart -&gt; B.onResume -&gt; B.onPause -&gt; B.onStop -&gt; A.onResume； 当A打开的不透明的B时，A.onPause -&gt; B.onCreate -&gt; B.onStart -&gt; B.onResume -&gt; A.onStop；可以看到如果在onPause里面做太多的耗时操作，可能导致下一个界面的卡顿； 异常状态下的生命周期 系统配置改变如屏幕旋转、键盘灯，会出发Activity的重建，若需要不触发重启，可以在AndroidManifest配置configChanges熟悉，常用的locale、orentation、keyboardHidden和screenSize。 系统资源不足Activity优先级分为： 前台：可交互； 可见非前台：打开Dialog或者透明Activity； 后台：跳转到其他Activity；内存不足由3到1进行销毁； 状态保存与恢复由于内存不足系统回收，可以使用Bundle进行数据存储与恢复； 保存：在onStop之前调用onSaveInstanceState，在此处存储； 恢复：在onCreate方法里恢复，首先判断bundle是否为空，也可以在onRestoreSaveInstance里面完成； 启动模式设置方法AndroidManifest配置：无法配置clear_top标识；intent中追加addFlags方法，以代码动态设置为准，无法设置singleInstance模式； Activity任务栈 存放Activity，采用后进先出的结构； 从栈A启动到栈B，按返回键，先将栈B回退到空，再入栈A Activity任务栈 查看命令： adb shel dumpsys activity 4种类型 standard：标准模式，每次启动新的Activity并加入到当前栈的顶部； singleTop：栈顶复用模式，若打开的Activity位于栈顶，直接复用，按照onPause -&gt; onNewIntent -&gt; onResume 顺序出发，可以在onNewIntent内处理业务； singleTask：栈内复用模式：Activity A在栈S1，若A打开singleTask模式的Activity B；B目标栈为S2，S2不存在，则创建S2，将B入栈S2；B目标栈为S1，S1存在且无B，则将B放入栈顶；B目标栈为S1，S1存在且有B，复用B，将B上面的Activity出栈，回调onNewIntent方法； singleInstance：单例模式，单独位于一个任务栈中，栈中不会有其他Activity； 标识FLAGS FLAG_ACTIVITY_NEW_TASK：不等同于singleTask；目标栈不存在，则创建栈并入栈；目标栈存在，若Activity未打开过，创建放入栈顶；目标栈存在，若Activity已打开过，将目标栈移动到前台，不会创建新的； FLAG_ACTIVITY_SINGLE_TOP：等同于singleTop； FLAG_ACTIVITY_CLEAR_TOP：singleTask自带该效果； FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：不出现在多任务列表中； Activity到底进入哪个栈 ？ taskAffinity：亲和关系，表示更倾向于进入哪个栈，所以并不是设置了该属性，就一定位于这个栈中； taskAffinity不设置时，默认为包名； 当A启动standard、singleTop的B时，且不带FLAG_ACIVITY_NEW_TASK，则B加入A所在的栈顶； 只有singleTask、singleInstance或者带FLAG_ACTIVITY_NEW_TASK才能让taskAffinity生效； allowTaskReparenting这个属性会让taskAffinity生效，如A启动带taskAffinity的B，B肯定放入taskAffinity声明的栈中； ##参考 Activity你该懂的","tags":[{"name":"Activity","slug":"Activity","permalink":"https://hjw541988478.github.io/tags/Activity/"}]},{"title":"Java常用线程池理解","date":"2017-06-14T10:32:00.000Z","path":"2017/06/Java常用线程池理解/","text":"why ？ 创建和销毁线程伴随着系统开销，如果频繁创建销毁线程，影响处理效率；（创建时间T1，执行任务T2，销毁T3。如果T1+T3&gt;T2，那就划不来） 线程并发数量过多，抢占系统资源导致阻塞；（线程共享系统资源，如果同时执行线程过多，导致系统资源不多而产生阻塞） 能对线程进行简单管理；（延时执行，定时循环执行） what ？?主要是Executor接口，实现类为ThreadPoolExecutor，对线程池的配置主要在于构造参数的配置；12345public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) 还有ThreadFactory，RejectedExecutionHandler参数的构造，略有不同而已： int corePoolSize：核心线程数最大值；线程池新建线程时，如果当前线程总数小于corePoolSize，则新建的是核心线程，否则是非核心线程，核心线程默认情况下会一直存活在线程池中，即使是闲置状态。如果指定了allowCoreThreadTimeOut为true，那么超时后就会被销毁掉。 int maximumPoolSize：线程池总数最大值； long keepAliveTime：非核心线程闲置超时时长，如果设置了allowCoreThreadTimeOut=true，则会作用于核心线程； TimeUnit unit：超时时长的单位，可以是1纳秒，微秒，毫秒，秒分别为1000的单位； BlockingQueue workQueue：线程池中的任务队列，维护着等待执行的Runnable对象，常用的： SynchronousQueue：收到任务后直接交给线程处理，如果线程都在工作则新建线程，但不得超过最大数量，所以使用该任务队列时，一般指定最大线程数量为无限大； LinkedBlockingQueue：收到任务后，如果线程数小于核心线程数，则新建核心线程处理，如果等于核心线程数，则进入队列等待，也就是说，超过核心线程数的任务永远被加入队列中等待，同时导致maximusPoolSize失效； ArrayBlockingQueue：限定任务队列长度，收到任务后，如果没有达到corePoolSize，则新建coreThread处理，如果等于corePoolSize，则入队等候，如果队列已满，则新建非coreThread执行任务，如果达到了maximumPoolSize且队列已满，则发生错误； DelayQueue：队列内元素必须实现Dealay接口，接收到任务时，先入队，达到指定延时时间才会执行任务； ThreadFactory：创建线程的接口，一般不用； RejectedExecutionHandler handler：发生错误，用来抛出异常； 小结 线程数量未达到corePoolSize，则新建核心线程执行任务； 线程数量达到了corePools，则将任务移入队列等待 ； 队列已满，则新建线程非核心线程处理； 队列已满并且总线程数达到了maximumPoolSize，则抛出异常； 常见四种线程池CachedThreadPool： 无核心线程，没有工作的线程60s会自动被销毁； 线程数无限制； 有空线程则复用，无则新建线程；12public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; FixedThreadPool： 最大线程并发数等于核心线程数； 小于核心线程数时，不会复用闲置线程，超出核心线程数时会等待； 最多同时执行定长的线程；12public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; ScheduledThreadPool： 支持定时以及周期性任务； 优先复用闲置线程；1234public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); &#125;scheduleAtFixedRate()：延迟n秒后，每隔m秒执行任务；scheduleWithFixedDelay()：延迟n秒后，任务完成后隔m秒执行任务； SingleThreadPool： 有且仅有1个工作线程执行任务； 遵循队列规则执行；12public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 参考 线程池，这一篇或许就够了","tags":[{"name":"MultiThread","slug":"MultiThread","permalink":"https://hjw541988478.github.io/tags/MultiThread/"},{"name":"ThreadPool","slug":"ThreadPool","permalink":"https://hjw541988478.github.io/tags/ThreadPool/"}]},{"title":"Android插件化原理探索","date":"2017-05-16T14:01:00.000Z","path":"2017/05/Android插件化原理探索/","text":"代理模式（委托模式）限制对象的直接访问，保护内部对象； 静态代理AIDL中asInterface方法中有应用到静态代理，如果不在同一进程就会返回Proxy对象，而且几乎所有系统服务采用代理模式。 动态代理运行时指定代理类，实现InvocationHandler接口，重写invoke方法，通过Proxy.newInstance返回代理对象。分为jdk动态代理和cglib动态代理； jdk动态代理：基于类的反射机制，而且目标类基于同一的接口，Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理； cglib动态代理：借助asm实现，没有jdk动态代理的限制； Hook机制对一些方法进行拦截，当这些方法被调用时，能够执行我们自定义的代码，大致思路： 找到需要拦截的方法；利用代理模式来代理系统类的运行拦截我们需要拦截的方法；使用反射方法把系统类替换成你的代理类； ##反射机制java的反射机制是在运行态中，对于任意一个类都能知道其属性和方法，对于任意一个对象都能调用其方法和属性，这种动态获取信息以及动态调用对象的方法称为反射机制； 实例化对象 1Class.forNmae(完整类名); 获取父类 12Class&lt;?&gt; clazz = Class.forName(完整类名);Class&lt;?&gt; superClass = clazz.getSuperclass(); 获取实现接口 12Class&lt;?&gt; clazz = Class.forName(完整类名);Class&lt;?&gt;[] interfaces = clazz.getInterfaces(); 获取指定参数构造函数以及实例化 12345Class&lt;?&gt; clazz = Class.forName(完整类名);Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); // 公共构造for( .. ) &#123; Class&lt;?&gt; clazzs[] = constructor.getParameterTypes(); // 获取参数类型&#125; 无参数实例化 12Class&lt;?&gt; clazz = Class.forName(完整类名);clazz.newInstance(); 获取字段修改字段 123456Class&lt;?&gt; clazz = Class.forName(完整类名);Field field = clazz.getField(name); // 获取公共字段Field[] fields = clazz.getFields(); // 获取所有公共字段Field field = clazz.getDeclaredField(\"heihei\");field.setAccessible(true);//设置java取消访问检查，也就是说如果是私有的也可以访问,field.set(obj, \"Java反射机制\"); 获取方法运行方法 123Method method = clazz.getMethod(\"add\",int.class, int.class);method.setAccessiable(true);method.invoke(clazz.newInstance(), 20, 30); 获取数组或者list中的类型 1Class&lt;?&gt; componentType = clazz.getComponentType(); 以hook剪切板服务为例：12345678910111213141516Context.getSystemService(CLIPBOARD_SERVICE) -&gt;ContextImpl.getSystemService() -&gt;SystemServiceRegistry.getSystemService() -&gt;SYSTEM_SERVICE_FETCHERS.get() -&gt;ServiceManager.getService()获取IBinder -&gt;IBinder.asInterface()获取到远程服务接口 -&gt;public static android.content.IClipboard asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); // Hook点 if (((iin != null) &amp;&amp; (iin instanceof android.content.IClipboard))) &#123; return ((android.content.IClipboard) iin); &#125; return new android.content.IClipboard.Stub.Proxy(obj);&#125; 具体实现： 剪切板服务，是在系统的ServiceManager中的getSerVice方法中得到的，我们先拿到ServiceManager 1Class&lt;?&gt; serviceMangerClass = Class.forName(\"android.os.ServiceManager\"); 拿到getService方法 1Method getServiceMethod = serviceMangerClass.getDeclaredMethod(\"getService\", String.class); 通过这个方法，拿到原本的系统服务代理对象 1IBinder binder = (IBinder) getServiceMethod.invoke(null,\"clipboard\"); 我们通过这个对象，创建我们自己的代理对象，瞒天过海骗过系统 12IBinder myBinder = (IBinder) Proxy.newProxyInstance(serviceMangerClass.getClassLoader(), new Class[]&#123;IBinder.class&#125;,new MyClipProxy(binder)); 拿到 ServiceManager 中的数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Field field = serviceMangerClass.getDeclaredField(\"sCache\");field.setAccessible(true);Map&lt;String, IBinder&gt; map = (Map) field.get(null);//将我们的服务类存入mapmap.put(\"clipboard\",myBinder);public class MyClipProxy implements InvocationHandler &#123; private final IBinder mBase; public MyClipProxy(IBinder binder) &#123; mBase = binder;//这里传入的是原系统的代理类 &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //拦截原系统类查询本地是否有这个代理的方法 if(\"queryLocalInterface\".equals(method.getName()))&#123; //我们这里要创建我们自己的系统类，然后返回 //1.拿到系统的aidl类中的stub，因为这个对象本来就是个代理,而且源码执行了// static private IClipboard getService() &#123;// synchronized (sStaticLock) &#123;// if (sService != null) &#123;// return sService;// &#125;// IBinder b = ServiceManager.getService(\"clipboard\");// sService = IClipboard.Stub.asInterface(b);// return sService;// &#125;// &#125; Class&lt;?&gt; mStubClass = Class.forName(\"android.content.IClipboard$Stub\"); //2.在拿到IClipboard本地对象类 Class&lt;?&gt; mIClipboard = Class.forName(\"android.content.IClipboard\"); //3.创建我们自己的代理 return Proxy.newProxyInstance(mStubClass.getClassLoader(), new Class[]&#123;mIClipboard&#125;, new MyClip(mBase,mStubClass)); &#125; //不是这个方法还是返回原系统的执行 return method.invoke(mBase,args); &#125;&#125;public class MyClip implements InvocationHandler &#123; private Object mBase; public MyClip(IBinder base, Class stub) &#123; //拿到asInteface方法，因为源码中执行了这一句，我们也要执行这一句 try &#123; Method asInterface = stub.getDeclaredMethod(\"asInterface\", IBinder.class); mBase = asInterface.invoke(null,base); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //这里我们拦截粘贴的方法， if(\"getPrimaryClip\".equals(method.getName()))&#123; return ClipData.newPlainText(null,\"我是刘镓旗，我改了系统源码，哈哈哈\"); &#125; //再拦截是否有复制的方法，放系统认为一直都有 if(\"hasPrimaryClip\".equals(method.getName()))&#123; return true; &#125; //其他启动还是返回原有的 return method.invoke(mBase,args); &#125;&#125; Binder机制AIDL（以ActivityManager为例）：ActivityManager其实是AMS在主进程中的一个代理包装类，内部使用AMN.getDefault()进行操作： asInterface() 123456789101112131415161718 /** &#123;@hide&#125; */public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123; /** * Cast a Binder object into an activity manager interface, generating * a proxy if needed. */ static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj); &#125; onTransact() 1234567891011121314151617181920212223242526@Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case START_ACTIVITY_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app = ApplicationThreadNative.asInterface(b); String callingPackage = data.readString(); Intent intent = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); IBinder resultTo = data.readStrongBinder(); String resultWho = data.readString(); int requestCode = data.readInt(); int startFlags = data.readInt(); ProfilerInfo profilerInfo = data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null; Bundle options = data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null; int result = startActivity(app, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options); reply.writeNoException(); reply.writeInt(result); return true; &#125; 其实ActivityManagerNative相当于IActivityManager的代理内部类Stub，当不是一个进程会使用代理类Proxy来操作，将创建好的参数写入data中，当前线程挂起发起远程调用mRemote.transact()方法，此时调用服务端的onTransact()方法，直到有返回结果，然后从reply中取result；服务端请求走到onTransact方法时，通过code确定是属于哪个方法，然后从data取出需要的参数，并调用相应方法，将返回值写入reply。 ClassLoader官方MultiDex方案一个APK包含多个dex文件，除了第一个dex文件以外，其他dex文件是以资源形式加载的，也就是说，Application初始化前，将dex文件注入到系统的ClassLoader中，在Android的类加载机制中，同一个类只会被加载一次，为了让修复后的类替换原有的类，必须让补丁包优先加载，也就是插入到原有dex之前。 ClassLoaderAndroid中有主要的两个ClassLoader，PathClassLoader和DexClassLoader，它们都继承自BaseDexClassLoader，具体加载方法是findClass： PathClassLoader：加载系统类和主dex，也就意味着optimiszedDirectory为null，通过注释可知，被用来加载本地文件系统上的文件或目录，不能从网络加载；DexClassLoader：用于加载其他dex文件中的类。其构造：12345678public DexClassLoader(String dexPath, String optimizedDirectory,String libraryPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), libraryPath, parent);&#125;//dexPath：需要被加载的dex文件地址；//optimizedDirectory：dex文件被编译器优化后的存放路径，禁止为null，应该提供应用私有路径；//libraryPath：包含本地库的列表；//parent：父类构造器 为啥PathClassLoader的optimizedDirectory可以为null？在初始化时，会构造一个叫pathList的DexPathList对象，在findClass的时候使用pathList调用findClass，查看DexPathList源码发现，如果optimizedDirectory为空则使用系统默认的文件夹，我们的应用已经安装并优化了，优化后的dex存在于/data/dalvik-cache目录下，这样就无法修改该optimizedDirectory；在DexClassLoader初始化时，会将参数中的dex文件都保存在Element数组中，这样在findClass的时候，只需要遍历dexElements，从中查找目标类并返回便停止遍历。 Activity启动流程分析Launcher.startActivityForSafely() -&gt; Activity.startActivity() -&gt; startActivityForResult() -&gt; Instrumention.execStartActiviy() -&gt; ActivityMangerNative.getDefault().startActivity() -&gt;（先调用checkStartActivityResult()来检查Activity是否有效合法）-&gt; AMS.startActivity()/AMS代理类请求AMS启动一个Activity -&gt; AMS.startActivityAsUser()-&gt;ActivityStarter.startActivityMayWait() -&gt;ActivityStackSupervisor.realStartActivityLocked() -&gt; app.thread.scheduleLaunchActivity()/调用ActivityThread的内部类ApplicationThread，其中ApplicationThread是IApplicationThread子类，是Binder对象 -&gt; ActivityThread.scheduleLaunchActivity()-&gt; sendMessage()/发送消息到内部类H中 -&gt; H.handleMessage() -&gt;handleLaunchActivity() -&gt; performLaunchActivity() -&gt; Instrumention.newActivity( )/1.创建Activity -&gt; ActivityClientRecord.package.makeApplication()/2. 创建Application，如果Application已经创建则直接返回，否则创建并调用callApplicationOnCreate() -&gt; createBaseContextForActivity()/activity.attach()/mInstrumention.callActivityOnCreate()/3.创建Context对象并attach，onCrerate方法； Activity启动流程总结 待启动的Activity会去AMS中校验是否合法； 回调ActivityThread中内部类ApplicationThread的scheduleLaunchActivity发送到内部类H中，H继承于Handler； 反射创建Activity以及Application并回调相应生命周期方法； 简单插件化实现思路 加载插件的ClassLoader通过LoadedApk对象获得的，通过我们构建一个LoadedApk对象，修改其中的ClassLoader对象，创建自己的ClassLoader对象，全面接管加载过程，再使用hook的方式把构建的LoaderApk对象存入mPackages的map中，这样会优先获取缓存也能获取到插件的LoadedApk了。不过需要hook系统中的很多方法，因为创建loadedapk需要ApplicationInfo对象，这个对象从AndroidManifest红来，还需要手动解析AndroidManifest，这个过程相对复杂很多，360的DroidPlugin采用的这种方法。 既然启动插件需要classloader，那也可以将我们的插件apk告诉系统classloader，让系统ClassLoader来接管创建，系统通过PathClassLoader加载系统类和主Dex类，DexClassLoader则用于加载其他dex中的类。 代码动态加载apk被安装后，apk文件代码以及资源会被放在/data/app/package_name/base-1.apk中，系统进行类加载的时候，会自动在这个路径去寻找，当然未安装的apk是没办法做到的。既然类加载是通过BaseDexClassLoader的findClass方法，最终调用的是DexPathList类里面的findClass，而实际上使用的是此类里面的dexElements数组，这个数组就是用来存放dex文件的数组，我们只需要将插件apk中的dex文件插入到dexElements数组中就可以实现，让系统自动加载并创建类了。对于Activity而言稍有不一样，因为AMS会检查待启动的Activity是否又在AndroidManifest中注册，而插件apk却是灵活的，因此需要hook代理startActivity，采用占坑方式，在校验的时候使用占坑activity通过校验，在真正启动的时候hookActivity创建方法，替换回来启动真正的Activity；总结下需要注意的点： startActivity最终走到AMS的startActivity； AMS验证activity是否合法； Activity创建时使用的ClassLoader为PathClassLoader； 分析ClassLoader可以知道，在装载类的时候最终使用的是BaseDexClassloader维护的dexElements数组来进行findClass的； 实现实现插件DexClassLoader，并合宿主的pathList：12345678910111213DexClassLoader pluginClassLoader = new DexClassLoader(apkPath, cacheDir, cacheDir, getClassLoader());PathClassLoader hostClassLoader = (PathClassLoader) getContext().getClassLoader();Object pluginElements = getDexElements(pluginClassLoader);Object hostElements = getDexElements(hostClassLoader);Object mergedElements = Array.newInstance(Element.class, totalLen);for(int k=0; k &lt; totalLen; k ++) &#123; if(k &lt; hostLen) &#123; Array.set(mergedElements,k,Array.get(host, k); &#125; else &#123; Array.set(mergedElements,k,Array.get(plugin, k - hostLen); &#125;&#125;setField(\"dexElements\", mergedElements); 此时对于普通的插件Class便可以达到加载的目的了，而对于Activity还需要做一些微小的工作； 代理启动Activity，在AMS验证的时候需要先将Activity替换成占坑的Activity，分析源码可知，在AMS验证之前的一步操作是ActivityManagerNative.getDefault().startActivity()，使用ActivityManger的本地代理类来启动Activity，这里的Hook点便在此： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//获取ActivityManagerNative的类Class&lt;?&gt; activityManagerNativeClass = Class.forName(\"android.app.ActivityManagerNative\");//拿到gDefault字段Field gDefaultField = activityManagerNativeClass.getDeclaredField(\"gDefault\");gDefaultField.setAccessible(true);//从gDefault字段中取出这个对象的值Object gDefault = gDefaultField.get(null);// gDefault是一个 android.util.Singleton对象; 我们取出这个单例里面的字段Class&lt;?&gt; singleton = Class.forName(\"android.util.Singleton\");//这个gDefault是一个Singleton类型的，我们需要从Singleton中再取出这个单例的AMS代理Field mInstanceField = singleton.getDeclaredField(\"mInstance\");mInstanceField.setAccessible(true);//ams的代理对象Object rawIActivityManager = mInstanceField.get(gDefault);// 创建一个这个对象的代理对象, 然后替换这个字段, 让我们的代理对象帮忙干活,这里我们使用动态代理,//动态代理依赖接口，而ams实现与IActivityManagerClass&lt;?&gt; iActivityManagerInterface = Class.forName(\"android.app.IActivityManager\");//返回代理对象,IActivityManagerHandler是我们自己的代理对象，具体代码请下载demoObject proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),new Class&lt;?&gt;[] &#123; iActivityManagerInterface &#125;, new IActivityManagerHandler(rawIActivityManager));//将我们的代理设值给singleton的单例mInstanceField.set(gDefault, proxy);代理IActivityManager的类如下，只是拦截了startActivity并使用占坑的Activity顺带把插件Activity存入Intent：class IActivityManagerHandler implements InvocationHandler &#123;...@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;if (\"startActivity\".equals(method.getName())) &#123;Log.e(\"Main\",\"startActivity方法拦截了\");// 找到参数里面的第一个Intent 对象Intent raw;int index = 0;for (int i = 0; i &lt; args.length; i++) &#123;if (args[i] instanceof Intent) &#123;index = i;break;&#125;&#125;raw = (Intent) args[index];//创建一个要被掉包的IntentIntent newIntent = new Intent();// 替身Activity的包名, 也就是我们自己的\"包名\"String stubPackage = MyApplication.getContext().getPackageName();// 这里我们把启动的Activity临时替换为 ZhanKengActivitiyComponentName componentName = new ComponentName(stubPackage, ZhanKengActivitiy.class.getName());newIntent.setComponent(componentName);// 把我们原始要启动的TargetActivity先存起来newIntent.putExtra(AMSHookHelper.EXTRA_TARGET_INTENT, raw);// 替换掉Intent, 达到欺骗AMS的目的args[index] = newIntent;Log.e(\"Main\",\"startActivity方法 hook 成功\");Log.e(\"Main\",\"args[index] hook = \" + args[index]);return method.invoke(mBase, args);&#125;return method.invoke(mBase, args);&#125;&#125; 在检查完之后，还需要在ActivityThread中的H中替换需要启动的Activity，也就是Hook点： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263先获取到当前的ActivityThread对象Class&lt;?&gt; activityThreadClass = Class.forName(\"android.app.ActivityThread\");//他有一个方法返回了自己Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(\"currentActivityThread\");currentActivityThreadMethod.setAccessible(true);//执行方法得到ActivityThread对象Object currentActivityThread = currentActivityThreadMethod.invoke(null);// 由于ActivityThread一个进程只有一个,我们获取这个对象的mH字段，也就是H这个HandlerField mHField = activityThreadClass.getDeclaredField(\"mH\");mHField.setAccessible(true);//得到H这个HandlerHandler mH = (Handler) mHField.get(currentActivityThread);//创建一个我们的CallBack并赋值给mHField mCallBackField = Handler.class.getDeclaredField(\"mCallback\");mCallBackField.setAccessible(true);//设置我们自己的CallBackField，具体替换信息代码请下载demo查看mCallBackField.set(mH, new ActivityThreadHandlerCallback(mH));同样的，需要代理H类的mCallback对象，在startActivity时恢复插件的Activity：public class ActivityThreadHandlerCallback implements Handler.Callback &#123;Handler mBase;public ActivityThreadHandlerCallback(Handler base) &#123;mBase = base;&#125;@Overridepublic boolean handleMessage(Message msg) &#123;Log.e(\"Main\",\"handleMessage what = \" + msg.what);switch (msg.what) &#123;// ActivityThread里面 \"LAUNCH_ACTIVITY\" 这个字段的值是100// 本来使用反射的方式获取最好, 这里为了简便直接使用硬编码case 100:handleLaunchActivity(msg);break;&#125;mBase.handleMessage(msg);return true;&#125;private void handleLaunchActivity(Message msg) &#123;// 这里简单起见,直接取出TargetActivity;Log.e(\"Main\",\"handleLaunchActivity方法 拦截\");Object obj = msg.obj;// 根据源码:// 这个对象是 ActivityClientRecord 类型// 我们修改它的intent字段为我们原来保存的即可.// switch (msg.what) &#123;// case LAUNCH_ACTIVITY: &#123;// Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\");// final ActivityClientRecord r = (ActivityClientRecord) msg.obj;// r.packageInfo = getPackageInfoNoCheck(// r.activityInfo.applicationInfo, r.compatInfo);// handleLaunchActivity(r, null);try &#123;// 把替身恢复成真身Field intent = obj.getClass().getDeclaredField(\"intent\");intent.setAccessible(true);Intent raw = (Intent) intent.get(obj);Intent target = raw.getParcelableExtra(AMSHookHelper.EXTRA_TARGET_INTENT);raw.setComponent(target.getComponent());Log.e(\"Main\",\"target = \" + target);&#125; catch (Exception e) &#123;throw new RuntimeException(\"hook launch activity failed\", e);&#125;&#125;&#125; 插件Activity为啥就有生命周期了呢？AMS与ActivityThread之间对于Activity的生命周期的交互，并没有直接使用Activity对象进行交互，而是使用一个token来标识，这个token是binder对象，因此可以方便地跨进程传递。Activity里面有一个成员变量mToken代表的就是它，token可以唯一地标识一个Activity对象，这里我们只不过替换了要启动Activity的信息，并没有替换这个token，所以系统并不知道运行的这个Activity并不是原来的那个。 资源动态加载系统资源加载分析宿主应用中正常情况下是无法访问插件资源，例如使用R或者getResource()的方式，因此如果如果宿主如果不存在资源ID，应用便会crash。LoadedApk对象表示了apk文件在内存中的表示，包括代码和资源，回顾LoadedApk的构建，其中需要ApplicationInfo作为参数，而这个ApplicationInfo是宿主的并不是插件的，而宿主的资源中并没有插件资源，因此插件apk无法使用插件的资源。在代码中使用资源的形式一般都是R类或者getResources()这两种方式，其实R文件查找也是通过context.getResources()来查找ID来完成的，而context具体的实现类为ContextImpl：1234@Overridepublic Resources getResources() &#123; return mResources;&#125; 可以看到只是仅仅返回mResources成员变量，查找其如何创建：12345678910111213141516171819202122//这里拿到了一个ResourcesManager,单例的，说明我们应用当中使用的都是同一套资源mResourcesManager = ResourcesManager.getInstance();...//LoadedApk对象中得到Resources对象Resources resources = packageInfo.getResources(mainThread);Resources resources = packageInfo.getResources(mainThread);if (resources != null) &#123;if (activityToken != null|| displayId != Display.DEFAULT_DISPLAY|| overrideConfiguration != null|| (compatInfo != null &amp;&amp; compatInfo.applicationScale!= resources.getCompatibilityInfo().applicationScale)) &#123;//给resource赋值resources = mResourcesManager.getTopLevelResources(packageInfo.getResDir(),packageInfo.getSplitResDirs(), packageInfo.getOverlayDirs(),packageInfo.getApplicationInfo().sharedLibraryFiles, displayId,overrideConfiguration, compatInfo, activityToken);&#125;&#125;//给mResources赋值mResources = resources; ResourcesManager.getInstance()是单例的这样保证了我们每个Context获取的都是同样的资源，resources通过getTopLevelResources方法赋值，而getTopLevelResources方法真正的获取资源的步骤，但主要分三步来创建Resources： 创建AssetManager对象； 通过隐藏的addAssetPath方法将资源路径添加给AssetManager； 拿到AssetManager对象后，便可以创建真正的Resources对象； 插件如何拿到创建好的Resources资源呢 ？ 在使用前初始化好Resources资源 ： 123456789101112131415//创建我们自己的ResourceString apkPath = Environment.getExternalStorageDirectory().getAbsolutePath() + \"/chajian_demo.apk\";//创建AssetManagerassetManager = AssetManager.class.newInstance();Method addAssetPathMethod = assetManager.getClass().getDeclaredMethod(\"addAssetPath\", String.class);addAssetPathMethod.setAccessible(true);addAssetPathMethod.invoke(assetManager, apkPath);Method ensureStringBlocks = AssetManager.class.getDeclaredMethod(\"ensureStringBlocks\");ensureStringBlocks.setAccessible(true);ensureStringBlocks.invoke(assetManager);Resources supResource = getResources();Log.e(\"Main\", \"supResource = \" + supResource);newResource = new Resources(assetManager, supResource.getDisplayMetrics(), supResource.getConfiguration());mTheme = newResource.newTheme();mTheme.setTo(super.getTheme()) 重写getResources和getAssets方法： 12345678@Overridepublic AssetManager getAssets() &#123;return assetManager == null ? super.getAssets() : assetManager;&#125;@Overridepublic Resources getResources() &#123;return newResource == null ? super.getResources() : newResource;&#125; 在插件Activity中记得重写getResources方法，毕竟默认使用宿主的Resource： 1234567891011121314@Overridepublic AssetManager getAssets() &#123;if(getApplication() != null &amp;&amp; getApplication().getAssets() != null)&#123;return getApplication().getAssets();&#125;return super.getAssets();&#125;@Overridepublic Resources.Theme getTheme() &#123;if(getApplication() != null &amp;&amp; getApplication().getTheme() != null)&#123;return getApplication().getTheme();&#125;return super.getTheme();&#125; 参考 插件化系列基础","tags":[{"name":"MultiProcess","slug":"MultiProcess","permalink":"https://hjw541988478.github.io/tags/MultiProcess/"},{"name":"AIDL","slug":"AIDL","permalink":"https://hjw541988478.github.io/tags/AIDL/"},{"name":"插件化","slug":"插件化","permalink":"https://hjw541988478.github.io/tags/插件化/"}]},{"title":"AIDL基本使用理解","date":"2017-04-24T12:39:00.000Z","path":"2017/04/AIDL基本使用理解/","text":"AIDL基本使用主要用于IPC，首先建立aidl文件：1234package aidl;interface IMyInterface &#123; String getTestStr(String s);&#125; 然后，sync一下便可以看到生成的java文件，保持这样的结构，可以分析下具体用到的接口：123456789101112131415161718192021222324252627public interface android.os.IBinder &#123; public IInterface queryLocalInterface(String descriptor);&#125;public class android.os.Binder implements android.os.IBinder &#123; &#125;public interface android.os.Interface &#123; IBinder asBinder();&#125;// 自动生成的接口类public interface IMyInterface extends android.os.IInterface &#123; public String getTestStr(String s); public static abstract class Stub extends android.os.Binder implements IMyInterface &#123; public static IMyInterface asInterface(IBinder binder) &#123; &#125; public void onTransact(..) &#123; &#125; private static class Proxy implements implements IMyInterface &#123; public void transact()&#123; &#125; &#125; &#125;&#125; 接着创建文明需要的Service：12345678910111213141516171819public class MyService extends Service &#123; public final static String TAG = \"MyService\"; private IBinder binder = new IMyInterface.Stub() &#123; @Override public String getTestStr(String s) throws RemoteException &#123; Log.i(TAG, s); return \"我是 Service 返回的字符串\"; &#125; &#125;; @Overrid public void onCreate() &#123; super.onCreate(); Log.i(TAG, \"onCreat\"); &#125; @Override public IBinder onBind(Intent intent) &#123; return binder; &#125;&#125; 对IMyInterface.Stub进行实例化转形成IBinder，然后在onBinder中返回，其中对我们定义的getTestStr进行了实现，由于我们需要实现的是IPC，因此也需要在AndroidManifest文件中配置成新的进程：123&lt;service android:name=\".server.MyService\" android:process=\"com.mathiasluo.remote\" /&gt; 注意process属性，默认进程就为包名，如果需要新的名字，则需要完整的包名来配置；Service配置好后，回到Activity中去绑定和启动：1234567891011121314151617181920212223242526272829303132public class MainActivity extends AppCompatActivity &#123; public final static String TAG = \"MainActivity\"; private IMyInterface myInterface; private ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; myInterface = IMyInterface.Stub.asInterface(service); Log.i(TAG, \"连接Service 成功\"); try &#123; String s = myInterface.getTestStr(\"我是Activity传来的字符串\"); Log.i(TAG, \"从Service得到的字符串：\" + s); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.e(TAG, \"连接Service失败\"); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); startAndBindService(); &#125; private void startAndBindService() &#123; Intent service = new Intent(MainActivity.this, MyService.class); //startService(service); bindService(service, serviceConnection, Context.BIND_AUTO_CREATE); &#125;&#125; 关键点在于ServiceConnection，当服务启动成功后，从onServiceConnected回调方法中拿到服务接口，IMyInterface.stub.asInterface(binder)拿到本地的代理对象，便可以远程调用相关方法。 AIDL剖析Service中实例化的IBinder可以看到，IMyInterface.Stub类是静态抽象类，继承了Binder，并且实现了IMyInterface接口，可以解释为啥实例化时为啥需要重新实现接口中的方法，以及可以向上转型成IBinder。 Activity中的IMyInterface在服务连接并成功回调onServiceConnected后，通过IMyInterface.Stub.asInterface(service)转换成IMyInterface，核心在于asInterface方法：1234567891011121314public static abstract class Stub extends android.os.Binder implements aidl.IMyInterface &#123; .......... public static aidl.IMyInterface asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; //检查Binder是不是在当前进程 android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof aidl.IMyInterface))) &#123; return ((aidl.IMyInterface) iin); &#125; return new aidl.IMyInterface.Stub.Proxy(obj); &#125;&#125; 如果Binder在当前进程，则直接返回IMyInterface，否则返回Proxy，其中Proxy构造时需要把在Service中实例化的IBinder带过去，作为服务的代理。当客户端调用服务的接口时，最后会进入mRemote.transact()方法，把数据传输给服务端，然后我们的实例化的Stub类回调onTransact()，再把得到的数据写入返回值发送给客户端，客户端读取值后就返回了。","tags":[{"name":"MultiProcess","slug":"MultiProcess","permalink":"https://hjw541988478.github.io/tags/MultiProcess/"},{"name":"AIDL","slug":"AIDL","permalink":"https://hjw541988478.github.io/tags/AIDL/"}]},{"title":"LeakCanary源码浅析","date":"2017-03-02T12:22:00.000Z","path":"2017/03/LeakCanary源码浅析/","text":"两步使用12345dependencies &#123; debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5.1&apos; releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&apos; testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&apos;&#125; 123456789101112public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) &#123; // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return; &#125; LeakCanary.install(this); &#125;&#125; LeakCanary.install(this) ?12RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);ActivityRefWatcher.installOnIcsPlus(application, refWatcher); 显然可以看到，RefWatcher用来监控引用的工具，而installOnIcsPlus只是创建了ActivityRefWatcher以及向application注册了一个ActivityLifecycleCallbacks回调函数，最后只在onDestroy处理。 引用队列：我们常用一个WeakReference&lt;Activity&gt; reference = new WeakReference(activity);，这里我们创建了一个reference来弱引用到某个activity，当这个activity被垃圾回收器回收后，这个reference会被放入内部的ReferenceQueue中。也就是说，从队列ReferenceQueue取出来的所有reference，它们指向的真实对象都已经成功被回收了。 RefWatcher监控Activity是否被回收 ?123456789101112131415161718192021222324public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener, ExcludedRefs excludedRefs) &#123; AndroidHeapDumper heapDumper = new AndroidHeapDumper(context, leakDirectoryProvider); heapDumper.cleanup(); int watchDelayMillis = 5000; AndroidWatchExecutor executor = new AndroidWatchExecutor(watchDelayMillis); return new RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,heapDumpListener, excludedRefs);&#125;// 其中AndroidHeapDumper用来dump堆内存状态，AndoidWatchExecutor用来watch一个引用的监听器。private final Set&lt;String&gt; retainedKeys;public void watch(Object activity, String referenceName) &#123; String key = UUID.randomUUID().toString(); retainedKeys.add(key); final KeyedWeakReference reference =new KeyedWeakReference(activity, key, referenceName, queue); watchExecutor.execute(new Runnable() &#123; @Override public void run() &#123; ensureGone(reference, watchStartNanoTime); &#125; &#125;);&#125;final class KeyedWeakReference extends WeakReference&lt;Object&gt; &#123; public final String key; public final String name;&#125; 将activity包装成KeyedWeakReference，然后watchExecutor会去执行ensureGone函数。 ensureGone首先会调用removeWeaklyReachableReferences把已回收的key从retainedKeys移除，剩下的key都是未被回收的对象； if(gone(reference))判断key是否存在，若不在则表示已经回收; gcTrigger.runFc()手动gc，立即回收所有的weakReference； 再次清理retianedKeys，如果还存在则使用heapDumper收集文件 确认发生泄漏，调用displayLeakService发生通知； 小结 利用application.registerActivityLifecycleCallbacks(lifecycleCallbacks)来监听整个生命周期内的Activity onDestoryed事件; 当某个Activity被destory后，将它传给RefWatcher去做观测，确保其后续会被正常回收； RefWatcher首先把Activity使用KeyedWeakReference引用起来，并使用一个ReferenceQueue来记录该KeyedWeakReference指向的对象是否已被回收； AndroidWatchExecutor会在 5s 后，开始检查这个弱引用内的 Activity 是否被正常回收。判断条件是：若 Activity 被正常回收，那么引用它的KeyedWeakReference会被自动放入ReferenceQueue中。 判断方式是：先看 Activity 对应的KeyedWeakReference是否已经放入ReferenceQueue中；如果没有，则手动GC:gcTrigger.runGc();，然后再一次判断ReferenceQueue是否已经含有对应的KeyedWeakReference。若还未被回收，则认为可能发生内存泄漏。 利用HeapAnalyzer对dump的内存情况进行分析并进一步确认，若确定发生泄漏，则利用DisplayLeakService发送通知。 onDestroy后多久检查?首先向主线程的MessageQueue添加一个IdleHandler，该Handler的作用就是当Looper没有消息处理的时候，才回处理该优先级低的Message；低优先级的任务从backgroundHandler.postDelayed来，等到主线程空闲了，5s后工作现场检查activity是否被回收了； 知识点 如何创建低优先级的主线程任务，只会在空闲时执行？ 1Looper.myQueue().addIdleHandler(new IdleHandler() &#123;..); 创建Handler？ 1HandlerThread + Handler / new Handler(Looper.getMainLooper()); 是否运行在主线程? 1Looper.getMainLooper().getThread() == Thread.currentThread(); System.gc是否立马gc?只是建议回收，无法保证真的回收，参考ASOP源码 1234567891011121314Runtime.getRuntime().gc();enqueueReferences();System.runFinalization();public static void enqueueReferences() &#123; /* * Hack. We don't have a programmatic way to wait for the reference queue * daemon to move references to the appropriate queues. */ try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; throw new AssertionError(); &#125;&#125; 优化LeakCanary 忽略已知类或Activity通过ExcludedRefs主动添加需要忽略的类，对于Activity，只需要在onActivityDestroyed去排除； 将内存数据上传至server提供了AbstractAnalysisResultServcice这个IntentService，继承实现该类上传即可； 参考 LeakCanary核心原理源码浅析","tags":[{"name":"LeanCanary","slug":"LeanCanary","permalink":"https://hjw541988478.github.io/tags/LeanCanary/"},{"name":"MemeoryLeak","slug":"MemeoryLeak","permalink":"https://hjw541988478.github.io/tags/MemeoryLeak/"}]},{"title":"Java线程常用场景","date":"2016-11-07T12:04:00.000Z","path":"2016/11/Java线程常用场景/","text":"如何让两个线程依次执行？12345678910111213141516171819202122private static void demo2() &#123; Thread A = new Thread(new Runnable() &#123; @Override public void run() &#123; printNumber(\"A\"); &#125; &#125;); Thread B = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"B 开始等待 A\"); try &#123; A.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; printNumber(\"B\"); &#125; &#125;); B.start(); A.start();&#125; 使用threadA.join()，让线程B等待线程A执行完后，再执行自己； 如何让两个线程交叉有序执行？12345678910111213141516171819202122232425262728293031323334*** 输出A 1, B 1, B 2, B 3, A 2, A 3*/private static void demo3() &#123; Object lock = new Object(); Thread A = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (lock) &#123; System.out.println(\"A 1\"); try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"A 2\"); System.out.println(\"A 3\"); &#125; &#125; &#125;); Thread B = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (lock) &#123; System.out.println(\"B 1\"); System.out.println(\"B 2\"); System.out.println(\"B 3\"); lock.notify(); &#125; &#125; &#125;); A.start(); B.start();&#125; 使用共享锁object以及synchronized关键字，A拿到锁后打印依次然后wait，B从等待变成运行打印结束最后notify，唤醒A，A继续执行结束； 四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的？1234567891011121314151617181920212223242526272829303132private static void runDAfterABC() &#123; int worker = 3; CountDownLatch countDownLatch = new CountDownLatch(worker); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"D is waiting for other three threads\"); try &#123; countDownLatch.await(); System.out.println(\"All done, D starts working\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); for (char threadName='A'; threadName &lt;= 'C'; threadName++) &#123; final String tN = String.valueOf(threadName); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(tN + \"is working\"); try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(tN + \"finished\"); countDownLatch.countDown(); &#125; &#125;).start(); &#125;&#125; 使用CountDownLatch共享倒计时器，初始为3，等待线程调用await等待到0时继续执行，其他线程调用countDown减一，直到为0； 三个运动员各自准备，等到三个人都准备好后，再一起跑123456789101112131415161718192021222324252627282930private static void runABCWhenAllReady() &#123; int runner = 3; CyclicBarrier cyclicBarrier = new CyclicBarrier(runner); final Random random = new Random(); for (char runnerName='A'; runnerName &lt;= 'C'; runnerName++) &#123; final String rN = String.valueOf(runnerName); new Thread(new Runnable() &#123; @Override public void run() &#123; long prepareTime = random.nextInt(10000) + 100; System.out.println(rN + \"is preparing for time:\" + prepareTime); try &#123; Thread.sleep(prepareTime); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; System.out.println(rN + \"is prepared, waiting for others\"); cyclicBarrier.await(); // 当前运动员准备完毕，等待别人准备好 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(rN + \"starts running\"); // 所有运动员都准备好了，一起开始跑 &#125; &#125;).start(); &#125;&#125; 为了实现线程互相等待的需求，利用CyclicBarrier，初始化时设置同时等待的线程数，当线程准备好后调用await操作，直到所有的线程都准备好了，才开始统一执行； 子线程完成某件任务后，把得到的结果回传给主线程1234567891011121314151617181920212223242526private static void doTaskWithResultInWorker() &#123; Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; System.out.println(\"Task starts\"); Thread.sleep(1000); int result = 0; for (int i=0; i&lt;=100; i++) &#123; result += i; &#125; System.out.println(\"Task finished and return result\"); return result; &#125; &#125;; FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(callable); new Thread(futureTask).start(); try &#123; System.out.println(\"Before futureTask.get()\"); System.out.println(\"Result:\" + futureTask.get()); System.out.println(\"After futureTask.get()\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125;&#125; 利用Callable配合FutureTask以及其get方法获取返回结果，当然get会阻塞主线程；如果不希望阻塞主线程可以考虑使用ExecutorService，把FutureTask放入线程池去管理执行； 参考 Java 里如何实现线程间通信","tags":[{"name":"MultiThread","slug":"MultiThread","permalink":"https://hjw541988478.github.io/tags/MultiThread/"}]},{"title":"游戏2048原理探索与实现","date":"2016-09-22T13:22:00.000Z","path":"2016/09/游戏2048原理探索与实现/","text":"简述2048有着简单的游戏规则有趣的游戏过程，在早年的时候着实火了一把，以致在后来也出现了很多不同的版本。但主要的规则都是相似的，4*4的格子，数字随机出现2或者4，手指进行上下左右的滑动，所有数字向滑动方向靠拢，相同的相邻数字相加合并，合并成功或者移动后在剩下的空格中随机出现新的数字，直到合并出现2048，则挑战成功。 分析游戏布局游戏主布局为一个4*4的面板，想要实现该布局的方式有很多种，比如继承View手动计算每个格子的坐标，但是会比较复杂，鉴于GridLayout在4.0的引入，比较适用于本游戏的布局，然后只需要监控上下左右不同的手势方向执行不同的逻辑运算便可以达到效果。接下来的重点是每个格子的实现，它是根据不同的数值表现出来的不同的背景色值，其尺寸大小是根据不同的分辨率下动态设置的。 游戏算法主要是小格子的产生、合并算法要求高点，如果过于麻烦效率太低势必会造成游戏卡顿，影响体验，于是这里采用的是思路比较传统的做法：在进行上下左右滑动时，遍历每一行(列)，如果没有数字用0来代替空格，如某一行的数字为4 4 0 2，则相同的合并后加入List中，否则直接加入，操作后的顺序即8 2，并从滑动的方向重新放置List中的数字，直到遍历所有行(列)。 实现小格子设计让GameBoxView继承FrameLayout，并根据设置的数字改变相应的颜色，对外提供setBoxNum()方法，并加入一个TextView设置数字背景颜色边距和数字值，整个实现起来较为简单：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import android.content.Context;import android.graphics.Color;import android.text.TextPaint;import android.view.Gravity;import android.view.View;import android.widget.FrameLayout;import android.widget.TextView;import com.example.game2048.GameApp;public class GameBoxView extends FrameLayout &#123; private int gBoxNumVal; private TextView gBoxView; private FrameLayout.LayoutParams gBoxParams; // 小格子的初始化数字值 public GameBoxView(Context context, int gBoxNum) &#123; super(context); this.gBoxNumVal = gBoxNum; initGameBoxView(); &#125; private void initGameBoxView() &#123; setBackgroundColor(Color.GRAY); gBoxView = new TextView(getContext()); setBoxNumber(gBoxNumVal); int gameLines = GameApp.mSp.getInt(GameApp.KEY_GAME_LINES, 4); // 根据不同的宫格设置不同的字体大小 if (gameLines == 4) &#123; gBoxView.setTextSize(35); &#125; else if (gameLines == 5) &#123; gBoxView.setTextSize(25); &#125; else &#123; gBoxView.setTextSize(20); &#125; TextPaint tp = gBoxView.getPaint(); tp.setFakeBoldText(true); gBoxView.setGravity(Gravity.CENTER); gBoxParams = new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); gBoxParams.setMargins(5, 5, 5, 5); addView(gBoxView, gBoxParams); &#125; public View getBoxItemView() &#123; return gBoxView; &#125; public int getBoxNumber() &#123; return gBoxNumVal; &#125; public void setBoxNumber(int num) &#123; this.gBoxNumVal = num; if (num == 0) &#123; gBoxView.setText(\"\"); &#125; else &#123; gBoxView.setText(\"\" + num); &#125; switch (num) &#123; case 0: gBoxView.setBackgroundColor(0x00000000); break; case 2: gBoxView.setBackgroundColor(0xffeee5db); break; case 4: gBoxView.setBackgroundColor(0xffeee0ca); break; case 8: gBoxView.setBackgroundColor(0xfff2c17a); break; case 16: gBoxView.setBackgroundColor(0xfff59667); break; case 32: gBoxView.setBackgroundColor(0xfff68c6f); break; case 64: gBoxView.setBackgroundColor(0xfff66e3c); break; case 128: gBoxView.setBackgroundColor(0xffedcf74); break; case 256: gBoxView.setBackgroundColor(0xffedcc64); break; case 512: gBoxView.setBackgroundColor(0xffedc854); break; case 1024: gBoxView.setBackgroundColor(0xffedc54f); break; case 2048: gBoxView.setBackgroundColor(0xffedc32e); break; default: gBoxView.setBackgroundColor(0xff3c4a34); break; &#125; &#125;&#125; 首先在构造时确定显示的数字，从而确定小格子的背景颜色，默认都是灰色，然后设置小格子的边距，整个的实现效果如下图： 小格子效果图 可以看到的是对于不同的数字对比效果还是很明显的，也达到了我们的目的。 游戏面板设计在初始化游戏矩阵时，首先需要移除之前的游戏布局，并获取最高成绩，并随机添加2个小格子作为初始格子。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 初始化游戏矩阵private void initGameMatrix()&#123; removeAllViews(); mHistoryScore = 0; GameApp.CURRENT_SCORE = 0; GameApp.mGameLines = GameApp.mSp.getInt(GameApp.KEY_GAME_LINES,4); mGameLines = GameApp.mGameLines; mGameMatrixViews = new GameBoxView[mGameLines][mGameLines]; mGameMatrixHistory = new int[mGameLines][mGameLines]; mTmpBoxNumList = new ArrayList&lt;&gt;(); mBlankGameBoxes = new ArrayList&lt;&gt;(); mHighestScore = GameApp.mSp.getInt(GameApp.KEY_HIGH_SCORE , 0); setColumnCount(mGameLines); setRowCount(mGameLines); // 设置触摸事件监听用于处理滑动事件 setOnTouchListener(this); DisplayMetrics metrics = new DisplayMetrics(); WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE); Display display = wm.getDefaultDisplay(); display.getMetrics(metrics); GameApp.mGameBoxWidth = metrics.widthPixels / GameApp.mGameLines; //根据小格子宽度初始化格子 initGameView(GameApp.mGameBoxWidth);&#125;public void initGameView(int cardSize)&#123; removeAllViews(); GameBoxView gameBoxView; for (int i = 0; i &lt; mGameLines; i ++)&#123; for (int j = 0 ; j &lt; mGameLines ; j++)&#123; gameBoxView = new GameBoxView(getContext(),0); addView(gameBoxView,cardSize,cardSize); mGameMatrixViews[i][j] = gameBoxView; mBlankGameBoxes.add(new Point(i,j)); &#125; &#125; // 初始化随机2个数字 addRandomNum(); addRandomNum();&#125;// 根据剩余的格子位置坐标初始化小格子private void addRandomNum()&#123; getBlankGameBoxes(); if (mBlankGameBoxes.size() &gt; 0)&#123; int randomNumPos = (int) Math.random() * mBlankGameBoxes.size(); Point randomPoint = mBlankGameBoxes.get(randomNumPos); mGameMatrixViews[randomPoint.x][randomPoint.y] // 只会出现2或者4 .setBoxNumber(Math.random() &gt; 0.2d ? 2: 4); // 增加缩放动画过渡自然些 animCreate(mGameMatrixViews[randomPoint.x][randomPoint.y]); &#125;&#125; 滑动事件处理游戏中只存在着上下左右四个方向的滑动，整个处理流程大致如下：滑动事件产生-&gt;滑动事件结束-&gt;判断滑动方向-&gt;游戏布局重新处理-&gt;添加新的随机数字-&gt;游戏是否结束。下面是对移动方向的处理：12345678910111213141516171819202122232425@Override public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: saveHistoryMatrix(); mStartX = (int) event.getX(); mStartY = (int) event.getY(); break; case MotionEvent.ACTION_MOVE: break; case MotionEvent.ACTION_UP: mEndX = (int) event.getX(); mEndY = (int) event.getY(); judgeDirection(mEndX - mStartX , mEndY - mStartY); if (isMoved()) &#123; addRandomNum(); GameActivity.getGameActivity().setScore(GameApp.CURRENT_SCORE, 0); &#125; checkCompleted(); break; default: break; &#125; return true; &#125; 在onTouch方法中捕获ACTION_DOWN事件，预先保存目前状态的游戏数据，记录起点坐标，在手指抬起后，捕获ACTION_UP事件，记录终点坐标随之判断滑动的方向，合并游戏数据，添加一个新的随机数字并检查游戏是否符合达到结束的条件。下面是向上滑动后进行的操作：12345678910111213141516171819202122232425262728293031323334private void swipeUp()&#123; for (int i = 0 ; i &lt; mGameLines ; i ++)&#123; for (int j = 0 ; j &lt; mGameLines ; j ++) &#123; int currentNum = mGameMatrixViews[j][i].getBoxNumber(); if (currentNum != 0) &#123; if (mLastBoxNum == -1) &#123; mLastBoxNum = currentNum; &#125; else &#123; if (mLastBoxNum == currentNum)&#123; mTmpBoxNumList.add(mLastBoxNum * 2); GameApp.CURRENT_SCORE += mLastBoxNum * 2; mLastBoxNum = -1; &#125; else &#123; mTmpBoxNumList.add(mLastBoxNum); mLastBoxNum = currentNum; &#125; &#125; &#125; else &#123; continue; &#125; &#125; if (mLastBoxNum != -1)&#123; mTmpBoxNumList.add(mLastBoxNum); &#125; for (int j = 0; j &lt; mTmpBoxNumList.size() ; j ++)&#123; mGameMatrixViews[j][i].setBoxNumber(mTmpBoxNumList.get(j)); &#125; for (int m = mTmpBoxNumList.size(); m &lt; mGameLines; m ++)&#123; mGameMatrixViews[m][i].setBoxNumber(0); &#125; mLastBoxNum = -1; mTmpBoxNumList.clear(); &#125; &#125; 通过外层循环遍历每一列，再通过内层循环遍历每一行，对相同的数字进行合并，并通过 mLastBoxNum 标识区分是否已经进行了合并，对于已经合并后的数字并不会与下个数字再次进行合并，最后将处理后的数字重新设置到游戏面板，从而完成了整个滑动过程。 判断游戏结束游戏结束意味着达到了设定的目标分数值，或者失败表示着所有的方块无法再次移动。对于游戏数据来说，成功即意味着游戏矩阵含有了设定分数值的方块，而失败意味着每个小方块四个方向都不存在与其相同的小方块。主要操作如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private void checkCompleted()&#123; int result = checkNums(); if (result == 0) &#123; if (GameApp.CURRENT_SCORE &gt; mHighestScore)&#123; SharedPreferences.Editor editor = GameApp.mSp.edit(); editor.putInt(GameApp.KEY_HIGH_SCORE, GameApp.CURRENT_SCORE); editor.apply(); GameActivity.getGameActivity().setScore(GameApp.CURRENT_SCORE, 1); GameApp.CURRENT_SCORE = 0; &#125; AlertDialog.Builder builder = new AlertDialog.Builder(getContext()); builder.setTitle(\"GameOver\") .setPositiveButton(\"Again\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; startGame(); &#125; &#125;).create().show(); GameApp.CURRENT_SCORE = 0; &#125; else if (result == 2) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(getContext()); builder.setTitle(\"Mission Accomplished\") .setPositiveButton(\"Again\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; startGame(); &#125; &#125;) .setNegativeButton(\"Continue\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; SharedPreferences.Editor editor = GameApp.mSp.edit(); if (mTargetScore == 1024)&#123; editor.putInt(GameApp.KEY_GAME_GOAL,2048); mTargetScore = 2048; GameActivity.getGameActivity().setGoal(2048); &#125; else if (mTargetScore == 2048)&#123; editor.putInt(GameApp.KEY_GAME_GOAL,4096); mTargetScore = 4096; GameActivity.getGameActivity().setGoal(4096); &#125; else &#123; editor.putInt(GameApp.KEY_GAME_GOAL,4096); mTargetScore = 4096; GameActivity.getGameActivity().setGoal(4096); &#125; editor.apply(); &#125; &#125;).create().show(); GameApp.CURRENT_SCORE = 0; &#125; &#125; 最终游戏实现效果图： 最终效果图 总结一步步分析来看，2048游戏的核心就是随机数字的生成，合并同行/同列数字，重新布局，检查游戏是否结束，关键还是对于游戏玩法转化成代码的理解能力，需要加强对日常业务的思考，对于问题转化成解决问题的模型的能力。 参考 Android 群英传","tags":[{"name":"CustomView","slug":"CustomView","permalink":"https://hjw541988478.github.io/tags/CustomView/"},{"name":"RandomNumber","slug":"RandomNumber","permalink":"https://hjw541988478.github.io/tags/RandomNumber/"}]},{"title":"MultiDex65535探索","date":"2016-07-03T11:22:00.000Z","path":"2016/07/MultiDex65535探索/","text":"问题背景 UNEXPECTED TOP-LEVEL EXCEPTION: java.lang.IllegalArgumentException: method ID not in [0, 0xffff]: 65536Dex文件中保存所有classes的方法个数的变量范围值在0~65535之间，但随着业务一直在增长，引入到的库以及业务代码越来越多，超过这个限制只是时间问题。一般来说 APK 安装的流程大多是这样构成的，首先复制apk文件到data/app目录下，然后解压扫描安装包将dex文件安装到data/dalvik-cache目录下，同时在data/data目录下创建以APK包名的应用数据目录。由于5.0及以上版本ART模式的存在，app第一次安装之后会进行一次预编译，如果这时候发现了classes(..N).dex文件的存在就会将他们最终合成为一个.oat的文件。 官方方案 在gradle脚本里写上:12345678910111213141516171819android &#123; compileSdkVersion 21 buildToolsVersion &quot;21.1.0&quot; defaultConfig &#123; ... minSdkVersion 14 targetSdkVersion 21 ... // Enabling multidex support. multiDexEnabled true &#125; ...&#125; dependencies &#123;compile &apos;com.android.support:multidex:1.0.0&apos;&#125; buildTools 版本在 21 之上 ，同时打开 multidex ，由此产生多 dex。 Application中重写 attachBaseContext :123456@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this); &#125; 此时大功告成，但经过不同机型测试后发现了如下的问题： 第二个dex文件太大导致打开时发生ANR 解决ANRANR 产生的原因一般是操作在 5s 内无法完成。思考下 apk 的加载流程，首先是首次安装完点击图标，由于此时 apk 的进程尚未启动，于是从该apk抽取classes.dex(主dex)进行加载，同时触发一次 dexopt。此时 App 的laucherActivity准备启动 ，同时触发Application启动，之后Application的attachBaseContext()方法调用，这时候MultiDex.install()调用，classes2.dex(第2个dex) 被install，再次触发dexopt，然后Applicaition的onCreate()执行，然后launcherActivity开始执行。在第二个 dex 较大的情况下必然会阻塞线程造成 ANR。那有什么好的方案呢？ 我们先看看源码，从MultiDex.install()进去看看:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Patches the application context class loader by appending extra dex files * loaded from the application apk. This method should be called in the * attachBaseContext of your &#123;@link Application&#125;, see * &#123;@link MultiDexApplication&#125; for more explanation and an example. * * @param context application context. * @throws RuntimeException if an error occurred preventing the classloader * extension. */ public static void install(Context context) &#123; Log.i(TAG, \"install\"); ...... try &#123; ApplicationInfo applicationInfo = getApplicationInfo(context); if (applicationInfo == null) &#123; // Looks like running on a test Context, so just return without patching. return; &#125; synchronized (installedApk) &#123; String apkPath = applicationInfo.sourceDir; // installedApk的类型是：Set&lt;String&gt;。 // 如果这个apk已经安装，则不重复安装。 if (installedApk.contains(apkPath)) &#123; return; &#125; installedApk.add(apkPath); ...... // 类加载器应该直接或间接继承于BaseDexClassLoader。 // 修改BaseDexClassLoader类中的DexPathList pathList字段，追加额外的DEX文件项。 /* The patched class loader is expected to be a descendant of * dalvik.system.BaseDexClassLoader. We modify its * dalvik.system.DexPathList pathList field to append additional DEX * file entries. */ ClassLoader loader; ...... // dex将会输出到SECONDARY_FOLDER_NAME目录。 File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME); List&lt;File&gt; files = MultiDexExtractor.load(context, applicationInfo, dexDir, false); // 校验这些zip文件是否合法。 if (checkValidZipFiles(files)) &#123; // 安装提取出来的zip文件。 installSecondaryDexes(loader, dexDir, files); &#125; else &#123; Log.w(TAG, \"Files were not valid zip files. Forcing a reload.\"); // 最后一个参数是true，代表强制加载。 // Try again, but this time force a reload of the zip file. files = MultiDexExtractor.load(context, applicationInfo, dexDir, true); // 校验这些zip文件是否合法。 if (checkValidZipFiles(files)) &#123; // 安装提取出来的zip文件。 installSecondaryDexes(loader, dexDir, files); &#125; else &#123; // Second time didn't work, give up throw new RuntimeException(\"Zip files were not valid.\"); &#125; &#125; &#125; &#125; catch (Exception e) &#123; Log.e(TAG, \"Multidex installation failure\", e); throw new RuntimeException(\"Multi dex installation failed (\" + e.getMessage() + \").\"); &#125; Log.i(TAG, \"install done\"); &#125; 经过层层的分析可以了解到多 dex 加载的时序图大概如下图所示： 时序图 这样看来MultiDex.install()始终在主线程中进行加载，确实是这样子，由于第二个 dex 太大导致 ANR。这么说有没更好的方案既能同步加载第二个 dex 又不卡住 UI 线程呢？ 异步加载 dex线程异步 or 进程异步？如果是线程异步的话，无法预知 install 加载完成的时间，这时候进程需要第二个 dex 的信息的话岂不是会发生异常，显然这是行不通的。因此最终的解决方案就是需要放在进程异步加载上。在阅读了相关的博客后，得到了一个很重要的结论：在安装完启动后是第二个 dex 进行 dexopt 花费了更多的时间。结合之前对源码的理解，可以把问题的关注点转化为，在不ANR的前提下完成dexopt，这样以后也不会需要再次dexopt，由此便可以直接在 UI 线程install dex。对于整个思路的流程图如下图： 进程异步加载dex图 首先是需要在 Application 中修改的: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); Log.d(\"loadDex\", \"App attachBaseContext \"); if (!isDexLoadProcessRunning()) &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123;//&gt;=5.0的系统默认对dex进行oat优化 if (has2ndDexOptUndone(base))&#123; waitForDexopt(base); &#125; MultiDex.install (this); &#125; &#125;&#125;``` 2. 相关方法:```java//neead wait for dexoptprivate boolean has2ndDexOptUndone(Context context)&#123;String flag = get2ndDexSHA1(context);Log.d(“loadDex”, “dex2-sha1 “ + flag);SharedPreferences sp = context.getSharedPreferences(PackageUtils.getPackageInfo(context). versionName, MODE_MULTI_PROCESS);String saveValue = sp.getString(KEY_DEX2_SHA1, “”);return flag != null &amp;&amp; !flag.equals(saveValue);&#125;public void waitForDexopt(Context base) &#123;Intent intent = new Intent();ComponentName componentName = newComponentName(getPackageName(), DexLoadActivity.class.getName());intent.setComponent(componentName);intent.putExtra(“IS_DO_2NDDEX_OPT”,true);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);base.startActivity(intent);long startWait = System.currentTimeMillis ();long waitTime = 10 * 1000 ;while (has2ndDexOptUndone(base)) &#123;try &#123;long nowWait = System.currentTimeMillis() - startWait;Log.d(“loadDex” , “wait ms :” + nowWait);if (nowWait &gt;= waitTime) &#123;return;&#125;Thread.sleep(200 );&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125; 加载 dex 进程的 Activity 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 安装完成之后第一次启动时,classes2.dex的dexopt花费了更多的时间 * 在不阻塞UI线程的前提下，完成dexopt，以后都不需要再次dexopt在UI线程install dex 了 */public class DexLoadActivity extends FinishActivity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_load_dex); new LoadDexTask().execute(); &#125; class LoadDexTask extends AsyncTask &#123; @Override protected Object doInBackground(Object[] params) &#123; try &#123; MultiDex.install(getApplication()); Log.d(\"loadDex\" , \"install finish\" ); ((GameAsstApplication) getApplication()).installFinish(getApplication()); &#125; catch (Exception e) &#123; Log.e(\"loadDex\" , e.getLocalizedMessage()); &#125; return null; &#125; @Override protected void onPostExecute(Object o) &#123; Log.d( \"loadDex\", \"get install finish\"); finish(); System.exit(0); &#125; &#125; @Override public void onBackPressed() &#123; //cannot backpress &#125;&#125;// 其配置描述：&lt;activity android:name=\".client.DexLoadActivity\" android:launchMode= \"singleTask\" android:process= \":mini\" android:exported = \"false\" android:theme=\"@android:style/Theme.Translucent.NoTitleBar.Fullscreen\" android:alwaysRetainTaskState= \"false\" android:excludeFromRecents= \"true\" android:screenOrientation= \"portrait\"/&gt; 在Application启动的时候会检测dexopt是否已经完成过，（检测方式是查看sp文件是否有dex文件的SHA1-Digest记录，这里要两个进程读取该sp,读取模式是MODE_MULTI_PROCESS）。如果没有就启动DexLoadActivity(属于：mini进程) ,否则就直接install dex。 参考 Android拆分与加载Dex的多种方案对比 美团Android DEX自动拆包及动态加载简介","tags":[{"name":"HotFix","slug":"HotFix","permalink":"https://hjw541988478.github.io/tags/HotFix/"},{"name":"MultiDex","slug":"MultiDex","permalink":"https://hjw541988478.github.io/tags/MultiDex/"}]},{"title":"数据结构之排序算法","date":"2016-04-09T10:32:00.000Z","path":"2016/04/数据结构之排序算法/","text":"背景 概念假设含有n个记录的序列为{r1..rn}，其对应关键字{k1..kn}，确定1…n的一种排列p1..pn,使得其关键字按照kp1..kpn呈非递增或者非递减关系，这样操作称为排序。 稳定性假设ki=kj且排序前的序列中ri领先于rj，如12果排序后ri仍领先于rj，则称排序方法稳定。 分类主要分为内排序和外排序。影响到性能的因素：1.时间 2.辅助空间 3.算法复杂性；内排序主要分为：插入、交换、选择和归并排序； 简单排序冒泡排序（交换排序）两两比较相邻记录关键字，如果反序则交换，直到没有反序的记录为止。时间复杂度：O(n^2)12345678910111213void bubbleSort(int[] ary)&#123; int i, j; boolean flag = true; for(i = 0; i&lt; ary.length - 1&amp;&amp; flag; i++)&#123; flag = false; for(j = ary.length - 2; j&gt;= i; j --)&#123; if(ary[j] &gt; ary[j + 1])&#123; swap(ary,j,j); flag = true; &#125; &#125; &#125;&#125; 选择排序（选择排序，记录下标最终交换）通过n-1次关键字比较，从n-i+1个记录中选出最小记录，并和第i个记录交换；时间复杂度：O(n^2)1234567891011121314void selectSort(int[] ary)&#123; int i,j,min; for(i = 0; i &lt; ary.length; i++) &#123; min = i; for(j = i + 1; i &lt; ary.length; j ++) &#123; if(ary[min] &gt; ary[j])&#125; min = j; &#125; &#125; if( i != min)&#123; swap(ary, i, min); &#125; &#125;&#125; 直接插入排序（插入排序）将一个记录插入到已排序好的表中，从而得到新的记录数+1的有序表；时间复杂度：O(n^2)123456789101112void insertSort(int[] ary)&#123; int i,j; for(i = 1; i &lt; ary.length; i ++)&#123; if(ary[i] &lt; ary[i-1]) &#123; int temp = ary[i]; for(j = i -1;j &gt;=0 &amp;&amp; arr[j] &gt; temp; j --)&#123; arr[j + 1] = arr[j]; &#125; arr[j + 1] = temp; &#125; &#125;&#125; 进阶排序希尔排序（插入排序）将待排序的数组分割成N个基本有序的子数组，比如大的基本在后面，小的在前面，不大不小的在中间，所以需要采取增量跳跃组成子序列，才能保证子序列进行直接插入排序后，得到的结果是基本有序。时间复杂度：O(n^3/2)12345678910111213141516void shellSort(int[] ary)&#123; int i,j; int increment = ary.length; do &#123; increment = increment / 3 + 1;//增量序列 for( i = increment + 1; i &lt; ary.length; i ++) &#123; if(ary[i] &lt; ary[i - increment]) &#123; int temp = ary[i]; for( j = i - increment; j &gt;=0 &amp;&amp; temp &lt; ary[j]; j -= increment) &#123; ary[j + increment] = ary[j];&#125; ary[j + increment] = temp; &#125; &#125; &#125;while(increment &gt; 1);&#125; 增量序列最后一个值必须等于1，属于不稳定的排序； 堆排序（选择排序）将待排序的序列构造成一个大顶堆，此时最大值就是根结点，然后移走根结点，将剩余的n-1个序列重新构造成一个堆，这样持续得到最小值，由此构成一个有序序列；关键点：如何构造堆？ 输出根结点后，如何调整为新的堆？时间复杂度：O（nlogn），跳跃式进行但不稳定，不适合个数较少的情况。12345678910111213141516171819202122232425void heapSort(int[] ary])&#123; int i; for(i=ary.length/2; i &gt;= 0; i --) &#123; heapAdjust(ary, i, ary.length); &#125; for(i=ary.length - 1; i &gt; 0; i --) &#123; swap(ary,0,i); heapAdjust(ary,0,i-1); &#125;&#125;void heapAdjust(int[] ary, int s, int m) &#123; int temp, j; temp = ary[s]; for(j=2*s; j&lt;=m ;j*=2)&#123; if(j&lt;m &amp;&amp; ary[j] &lt; ary[j + 1]) &#123; ++ j; &#125; if(temp &gt;= ary[j])&#123; break; &#125; ary[s] = ary[j]; s = j; &#125; ary[s] = temp;&#125; 归并排序假设初始n个记录，看成每个子序列长度为1的有序子序列，然后两两归并，一直重复直到得到一个长度为n的有序序列为止，也称为2路归并排序；时间复杂度：O（nlogn）,稳定但占用内存，不过效率高123456789101112131415161718192021222324252627282930313233343536void mergeSort(int[] ary)&#123; mSort(ary, res_ary, 0 , ary.length - 1);&#125;//将sr[s..t]归并排序成tr1[s..t];void mSort(int sr[], int tr1[], int s, int t)&#123; int m; int tr2[MAXSIZE + 1]; if(s == t) &#123; tr1[s] = sr[s]; &#125; else &#123; m = (s + t)/2; mSort(sr, tr2, s, m); mSort(sr, tr2, m + 1, t); mMerge(tr2, tr1, s, m, t); &#125;&#125;void mMerge(int sr[], int tr[], int i, int m, int n) &#123; int j,k,l; for(j = m + 1, k =i;i&lt;=m &amp;&amp; j &lt;=n; k ++) &#123; if( sr[i] &lt; sr[j] )&#123; tr[k] = sr[i ++]; &#125; else &#123; tr[k] = sr[j ++]; &#125; &#125; if(i&lt;=m)&#123; for(l = 0;l &lt;= m - i; l ++ )&#123; tr[k+l] = sr[i+l]; &#125; &#125; if(j &lt;=n ) &#123; for(l = 0; l &lt;= n- j; l ++ ) &#123; tr[k+l] = sr[j+l]; &#125; &#125;&#125; 快速排序（交换排序）通过一趟排序将待排记录分割成2部分，其中一部分记录关键字比另一部分小，则可分别对这两部分记录继续排序，以达到有序目的。时间复杂度：O（nlogn），跳跃进行不稳定，可以进行的优化操作： 优化选取枢轴：三数取中，即取三个关键字进行排序，将中间数作为枢轴，一般取左、右和中三个数。 优化不必要的交换：将枢轴值保存在临时变量上，采用替换而非交换的方式进行比较，最后再将枢轴值还原。 优化小数组时的排序方案：当数组长度较小时直接采用插入排序； 优化递归操作：缩减栈深度，提高性能；1234567891011121314151617181920212223242526void quickSort(int[] ary) &#123; qSort(ary, 0, ary.length- 1);&#125;void qSort(int[] ary, int low , int high)&#123; int pivot; if(low &lt; high) &#123; pivot = partition(ary, low, high); qSort(ary, low , pivot - 1); qSort(ary, pivot + 1, high); &#125;&#125;void partition(int[] ary, int low , int high)&#123; int pivotKey; pivotKey = ary[low]; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; ary[high] &gt;= pivotKey) &#123; high --; &#125; swap(ary, low , high); while(low &lt; high &amp;&amp; ary[low] &lt;= pivotKey) &#123; low ++; &#125; swap(ary, low , high); &#125; return low;&#125; 总结排序分为内排序和外排序，外排序要在内外存之间多次交换才能进行，主要是总结内排序；按操作划分为四类：插入、交换、选择和归并： 插入类：直接插入、希尔排序； 选择类：简单选择、堆排序； 交换类：冒泡、快排； 归并类：归并排序；除了归并和简单的三种排序外，其他都是不稳定的排序算法；除了简单排序外，其他复杂度都是O(nlogn)； 按使用情况划分：若基本有序，采用基本排序比改进排序更搞笑；否则，采用堆排序和归并排序强于其他高级排序； 从时间复杂度看，堆排序和归并排序比快排稳定，也就是无论数据好坏都可以高效完成，而快排需要根据数据的特点才可能高效完成； 从空间复杂度看，堆排序只需要O（1）便可完成，因此对内存敏感的话，应采用堆排序； 从稳定性看，无疑归并最好； 从记录个数来看，无疑个数越小越适宜于简单排序，否则，使用改进排序；综合来看，经过优化后的快排是最好的选择； 常见的大O复杂度 常用数据结构和排序算法复杂度","tags":[{"name":"Sort","slug":"Sort","permalink":"https://hjw541988478.github.io/tags/Sort/"},{"name":"DataStructure","slug":"DataStructure","permalink":"https://hjw541988478.github.io/tags/DataStructure/"}]},{"title":"IPC通信机制理解实践","date":"2015-11-19T11:12:00.000Z","path":"2015/11/IPC通信机制理解实践/","text":"IntroIPC含义为进程间通信或者跨进程通信，指的是两个进程之间进行数据交换的过程。线程是CPU调度的最小单元，也是一种有限的系统资源，而进程是指一个执行单元。在Android系统中，一个进程一般指一个应用。 多进程模式开启多进程模式在Android中使用多进程只有一种方法，那就是在AndroidManifest.xml中指定android:process属性，除此之外并无其他办法。如下面的例子所示:123456&lt;activity android:name=\"me.huangjiawen.ipcaty1\" android:process=\":remote\"/&gt;&lt;activity android:name=\"me.huangjiawen.ipcaty2\" android:process=\"me.huangjiawen.remote\"/&gt; 通过:remote指定的进程，表示当前进程名为当前包名附上:remote，即me.huangjiawen:remote，且属于当前应用的私有进程，其他应用的组件不能和它跑在同一个进程中。 通过me.huangjiawen.remote完整的名字指定的进程，它不会附上包名信息，且属于全局进程，其他应用可以通过ShareUID的方式和它跑在同一个进程中。 多进程模式运行机制通常情况下，在应用中我们很多时候会使用静态类型的变量来共享数据，保证共享数据的唯一性。如下情况:123public class AppInfo&#123; public static int TOTAL_NUM = 1;&#125; 在单进程的应用中，在不同的地方访问TOTAL_NUM数据都是唯一的，但在多进程模式下的运行机制中，当我们在一个进程中修改其值，然后在另一个进程中获取其值，会发现获取到的值并不是修改后的值，而是初始值。发生这种情况的原因是因为多进程被分配了不同的虚拟机，也就是说在内存地址上分配着不同的空间，彼此相互是独立的，在某进程中修改后的静态变量值只会影响到当前进程，对其他进程并不会造成影响。因此四大组件通过内存共享数据的方式是不可取的，而大多数需要使用多进程的情况都需要数据共享，此时需要其他方式来解决这个问题。在多进程共享数据主要会造成下面几个方面的影响： 静态成员和单例模式失效 线程同步机制失效 SharedPreference可靠性下降 Application多次创建 IPC基础SerializableSerializable是Java提供的一个序列化空接口，只需要声明便可以使用，同时默认产生一个serialVersionUID常量。我们常见的序列化和反序列化的使用场景是这样的：1234567891011// 序列化User user = new User(\"Sunny\",20);ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(\"cache.txt\");oos.writeObject(user);oos.close;// 反序列化ObjectInputStream ois = new ObjectInputStream( new FileInputStream(\"cache.txt\");User newUser = (User) ois.readObject();ois.close(); 这里，serialVersionUID起到了重要的作用，序列化的时候把当前类的serialVersionUID写入到中介，当反序列化的时候检测中介的serialVersionUID，如果与当前版本的一致，说明是相同的，则可以序列化成功，否则序列化失败。 ParcelableParcelable也是一个接口，实现了这个接口后，便可以用来在Intent和Binder传递。下面实例:12345public class User implements Parcelable&#123; public String name; public int age; ...&#125; 从上面的代码可以看出，Parcel内部包装了可序列化的数据，其中通过writeToParcel方法完成序列化功能，而反序列化由CREATOR来完成，其内部标明了如何创建对象和数组，而内容描述功能在几乎所有情况都应该返回0，除非存在文件描述符，则返回0。 BinderBinder是Android中的一个类，它继承了IBinder接口。在Andriod应用层中，主要用在Service中，包括Messenger和AIDL，其中涉及到IPC通信的主要是AIDL。通过指定Book.aidl、IBookManager.aidl进行rebuild后自动生成的IBookManager.java，它继承于IInterface接口，同时内部类Stub和内部代理类Proxy很好地实现了同进程和跨进程间的通信过程。1234package me.huangjiawen.ipcexercise;public interface IBookManager extends android.os.IInterface &#123; ...&#125; 通过内部声明的2个ID标识IBookManager所声明的方法，这样可以清晰的认识到在transact过程中客户端请求的到底是哪个方法，接着声明一个内部类Stub，这个Stub是一个内部类，也就是一个Binder类，当客户端与服务端在同一个进程中的时候，方法调用不会走transact过程，而在不同进程中的时候，逻辑由Stub内部代理类Proxy完成。其中，关键方法或属性含义如下： DESCRIPTER：Binder的唯一标识，一般用于Binder的类名表示； asInterface(android.os.IBinder obj) :用于将服务端的Binder对象转换成客户端所需要的AIDL接口类型对象，这种转换是区分进程的，如果在同一进程，则返回服务端本身，否则返回的是封装后的Stub.Proxy对象； asBinder :用于返回当前Binder对象； onTransact :该方法运行在服务端的Binder线程中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理，其参数，code对应着请求的方法是什么，data取出目标方法所需要的参数，当方法执行完毕后，向reply中写入返回值。如果返回失败，则表示调用失败，可以利用此特性做权限验证。 Proxy.getBookList该方法运行在客户端中，当客户端进行远程调用的时候，首先创建输入型的Parcel对象_data、输出型的Parcel对象_reply和返回值对象List，然后把方法所需要的参数写入到_data中，接着进行RPC请求，直到返回结果数据继续执行，并从_reply中取结果数据返回给客户端。 Proxy.addBook该方法也运行在客户端中，与上一个方法不一样的地方在于没有返回值。通过对上面关键方法的分析可以看到整个工作机制，但也有需要注意的地方，第一个是如果远程请求的方法很耗时，那么在UI线程中直接执行可能会造成ANR，第二个是由于服务端Binder方法运行在Binder线程池中，所以Binder方法无论怎样都应该以同步的方式去实现，因为它已经运行在一个线程中了。对于Binder工作机制的理解如下图所示： Binder工作机制图 当然，我们也可以无需借助aidl自动生成，使用手写实现的步骤如下： 声明一个AIDL性质的接口，只需要继承IInterface接口即可； 实现Stub类和Stub类中的Proxy代理类；只是在结构上面看着更为清晰，将接口和IBinder进行分离，实质上并无改变。 IPC方式Bundle由于Bundle实现了Parcelable接口，这也意味着它能够作为进程间传输的载体，但由于Bundle支持的数据类型有限，使得一些特殊对象不被支持，在Activity、Service和Recevier中使用情景很常见，作为使用情景最多的方式，特点是方便易用。 文件共享两个进程可以通过共享同一文件达到目的，但由于Android系统是基于Linux，这使得读写文件可以同时执行，因此为了保证数据的完整性和最新性，需要使用同步加锁，但这无疑降低了读写效率。因此文件共享适用于数据同步要求不高的进程间通信。 MessengerMessenger可以在不同进程之间传递Message对象，可以轻松实现跨进程通信，底层实现依赖的是AIDL，由于具有一次只处理一个请求的特性，这意味着不需要考虑线程同步的问题。 服务端进程服务端只需要创建一个Service来处理客户端请求，同时使用Handler并通过它来创建一个Message对象，然后在onBind方法中返回这个底层对象Binder即可。 1234567891011121314151617181920212223242526272829public class MessengerService extends Service &#123; private static class MessengerHandler extends Handler&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case 0: // 收到客户端发过来的消息 Log.d(TAG,msg.getData().getString(\"msg\")); // 回复客户端 Messenger client = msg.replyTo; Message replyMsg = Message.obtain(null,1); Bundle bundle = new Bundler(); bundle.putString(\"msg\",\"hello,client\"); replyMsg.setData(bundle); client.send(replyMsg); break; default: super.handleMessage(msg); break; &#125; &#125; &#125; private final Messenger mMessengerHandler = new Messenger(new MessengerHandler()); @Nullable @Override public IBinder onBind(Intent intent) &#123; return mMessengerHandler.getBinder(); &#125;&#125; 客户端进程 12345678910111213141516171819202122232425262728293031323334package me.huangjiawen.ipcexercise;public class MessengerActivity extends AppCompatActivity &#123; private Messenger mService; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mService = new Messenger(service); Message msg = Message.obtain(null, 0); Bundle data = new Bundle(); data.putString(\"msg\", \"this is client.\"); msg.setData(data); try &#123; Log.d(TAG, \"client has sended msg.\"); mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Intent intent = new Intent(this, MessengerService.class); bindService(intent, mConnection, BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; unbindService(mConnection); super.onDestroy(); &#125;&#125; 可以看到客户端与服务端的交互流程中，数据总是以Message做为载体，Messenger作为传输信使进行消息的发送。其工作原理可以如下图所示： Messenger工作原理 AIDLMessenger的底层实现是基于AIDL来的，但Messenger是以串行的方式来处理消息的，对于大量的消息请求，显然Messenger变得不怎么合适了，那么AIDL方式的可以解决这个问题。 AIDL文件的创建AIDL文件是以.aidl为后缀声明了接口和方法的文件，主要支持的数据类型： 基本数据类型(int、long、char等) String和CharSequence List:只支持ArrayList Map:只支持HashMap Parceable:所有实现了Parceable接口的对象 AIDL:所有AIDL接口本身也可以被使用除了基本类型数据外，其他数据类型的参数必须标上方向：in、out或者inout，in表示输入型参数，out表示输出型参数，inout表示输入输出型参数。如：123456package me.huangjiawen.ipcexercise;import me.huangjiawen.ipcexercise.Book;interface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book);&#125; 远程服务端Service的实现在创建好AIDL接口后，接下来我们就需要实现接口：12345678910111213141516171819202122232425262728public class BookManagerService extends Service &#123; private static final String TAG = \"BMS\"; private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;(); private Binder mBinder = new IBookManager.Stub()&#123; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; return mBookList; &#125; @Override public void addBook(Book book) throws RemoteException &#123; mBookList.add(book); &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mBookList.add(new Book(1,\"android\")); mBookList.add(new Book(2,\"ios\")); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 使用CopyOnWriteArrayList来支持并发的读写，由于AIDL的方法是在线程池中执行的，如果有多个客户端同时连接，也存在着多个线程同时访问的情况，而我们这里直接使用CopyOnWriteArrayList便可以达到自动线程同步的目的。与此类似的集合还有ConcurrentHashMap，它们都会按照规范去访问数据最后生成ArrayList或者HashMap。最后记得在Manifest文件去配置Service。123&lt;service android:name=\".aidl.BookManagerService\" android:process=\":remote\"/&gt; 客户端的实现客户端需要做的是，绑定远程服务，拿到Binder对象转换成AIDL接口，最后通过AIDL接口进行远程方法调用就好了。 123456789101112131415161718192021222324252627282930public class BookManagerActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_book_manager); Intent intent = new Intent(this, BookManagerService.class); bindService(intent, mConnection, BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; unbindService(mConnection); super.onDestroy(); &#125; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; IBookManager bookManager = IBookManager.Stub.asInterface(service); try &#123; List&lt;Book&gt; list = bookManager.getBookList(); Log.d(\"BMA\", \"query book list , and type :\" + list.getClass().getCanonicalName()); Log.d(\"BMA\", \"query book list:\" + list.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;;&#125; 回调接口管理当然有些时候我们需要回调接口去接收到服务端的传过来的信息，这意味着包含着3个过程，注册服务，运行服务，反注册服务，一般情况下我们在拿到服务端的Binder后直接使用来进行注册与反注册，但此时通过日志可以发现，实际上是反注册失败的。仔细分析不难发现，在多进程中，Binder会把从客户端传过来的对象转化成一个新的对象，由于对象不能跨进程传输，对象的跨进程输出本质是反序列化的过程，所以能够见到的跨进程传输的对象都是实现了Parcelable接口的。但还好的是系统给我们提供了RemoteCallbackList专用于删除跨进程listener的接口，可以看到其真正的结构： 1ArrayMap&lt;IBinder,Callback&gt; mCallbacks = new ArrayMap&lt;IBinder,Callback&gt;(); 使用IBinder类型作为key，回调接口callback作为value。也就是说利用了底层Binder对象都是同一个的特性，并且自动实现了线程同步的功能，也就是这样达到的目的。 Binder异常处理如果Binder意外死亡，某些情况下需要我们进行重新连接。进行这种操作的方法有两种，第一种是给DeathRecipient设置监听，第二种是在onServiceDisconnected中进行处理。这两种处理方法的不同点在于前一种是在Binder线程池中的一个线程中操作的，而后一种是在UI线程中处理的，根据具体需求可以选择是去处理。 AIDL权限验证默认情况下，我们所有的远程服务任何人都能连接，但大多数情况下，是需要加入权限认证的。解决的方式有两种。第一种是在onBind中进行自定义权限的验证，验证不通过返回null。12345&lt;permission android:name=&quot;me.huangjiawen.permission.ACCESS_BOOK_SERVICE&quot; android:protectionLevel=&quot;normal&quot;/&gt;int check = checkCallingOrSelfPermission(&quot;me.huangjiawen.permission.ACCESS_BOOK_SERVICE&quot;);if (check == PackageManager.PERMISSION_DENIED) return null; 第二种是在服务端中的onTransact方法中进行权限验证，如果验证失败返回false，验证方式可以采用permission验证，也可以使用Uid和Pid验证，通过getCallingUid和getCallingPid可以拿到客户端所属应用的Uid和Pid。比如既验证包名又验证permission。12345678910int check = checkCallingOrSelfPermission(\"me.huangjiawen.permission.ACCESS_BOOK_SERVICE\");if (check == PackageManager.PERMISSION_DENIED) return false;String packageName = null;String[] packages = getPackageManager.getPackageForUid(getCallingUid());if ( packages != null &amp;&amp; packages.length &gt; 0 ) &#123; packageName = packages[0];&#125;if(!packageName.startsWith(\"me.huangjiawen\")) return false; ContentProviderContentProvider是Android提供的专门用于不同应用间进行数据共享的方式，和Messenger一样，底层实现也是Binder。下面来进行自定义的ContentProvider来进行研究：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class BookProvider extends ContentProvider &#123; private static final String TAG = \"BookProvider\"; // 在Manifest声明配置的 private static final String AUTHORITY = \"me.huangjiawen.book.provider\"; public static final Uri BOOK_CONTENT_URI = Uri.parse(\"content://\" + AUTHORITY + \"/book\"); public static final int BOOK_URI_CODE = 0; private static final UriMatcher sUriMathcher = new UriMatcher( UriMatcher.NO_MATCH); static &#123; sUriMathcher.addURI(AUTHORITY, \"book\", BOOK_URI_CODE); &#125; private Context mContext; private SQLiteDatabase mDb; @Override public boolean onCreate() &#123; mContext = getContext(); mDb = new BookDbHelper(mContext).getWritableDatabase(); mDb.execSQL(\"insert into tb_book values(3,'Android');\"); mDb.execSQL(\"insert into tb_book values(4,'IOS');\"); return true; &#125; private String getTableName(Uri uri) &#123; String tableName = BookDbHelper.TB_BOOK; switch (sUriMathcher.match(uri)) &#123; case BOOK_URI_CODE: tableName = BookDbHelper.TB_BOOK; break; &#125; return tableName; &#125; @Nullable @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; return mDb.query(getTableName(uri), projection, selection, selectionArgs, null, null, sortOrder); &#125; @Nullable @Override public String getType(Uri uri) &#123; return null; &#125; @Nullable @Override public Uri insert(Uri uri, ContentValues values) &#123; mDb.insert(getTableName(uri), null, values); mContext.getContentResolver().notifyChange(uri, null); return uri; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; int count = mDb.delete(getTableName(uri), selection, selectionArgs); if (count &gt; 0) &#123; mContext.getContentResolver().notifyChange(uri, null); &#125; return count; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; int rows = mDb.update(getTableName(uri), values, selection, selectionArgs); if (rows &gt; 0) mContext.getContentResolver().notifyChange(uri, null); return rows; &#125;&#125; 上面已经实现了TB_BOOK表的CRUD并且提供了Provider，如果存在着多个数据库而由于存在多线程并发访问，因此要做好线程同步操作。还有值得注意的是，如果对数据库产生了更新的影响，有必要去使用ContentResolver的notifyChange去通知外部数据源已经改变。在AndroidManifest文件中的配置：12345&lt;provider android:name=\"me.huangjiawen.ipcexercise.BookProvider\" android:authorities=\"me.huangjiawen.book.provider\" android:permission=\"me.huangjiawen.PROVIDER\" android:process=\":provider\" /&gt; 使用示例如下:123456789101112131415161718public class ProviderActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Uri uri = BookProvider.BOOK_CONTENT_URI; ContentValues cvs = new ContentValues(); cvs.put(\"_id\", 6); cvs.put(\"name\", \"javascript\"); getContentResolver().insert(uri, cvs); Cursor bookCursor = getContentResolver().query(uri, new String[]&#123;\"_id\", \"name\"&#125;, null, null, null); while (bookCursor.moveToNext()) &#123; Book book = new Book(bookCursor.getInt(0),bookCursor.getString(1)); Log.d(\"ProviderActivity\",book.toString()); &#125; bookCursor.close(); &#125;&#125; 通过ContentProvider对外提供的URI对TB_BOOK表添加了2条记录，然后使用getContentResolver()进行遍历查找输出。由于Provider和Activity运行在两个不同的进程中，也很好的展示了进程间的通信。 Binder连接池一般情况下，当我们创建一个AIDL接口的时候，也意味着也要创建一个新的Service，而随着AIDL接口越来越多的时候，Service也会变得越多，因此我们需要将所有的AIDL放在一个Service中去管理。Binder连接池的目的就是将每个业务模块Binder请求统一转发给Service去执行，从而避免了重复创建Service的过程。示例如下： 业务接口： 1234567interface ISecurityCenter &#123; String encrypt(String content); String decrypt(String password);&#125;interface ICompute &#123; int add(int a, int b);&#125; 业务接口实现 12345678910111213141516public class SecurityCenterImpl extends ISecurityCenter.Stub &#123; @Override public String encrypt(String content) &#123; ..... &#125; @Override public String decrypt(String password) &#123; ..... &#125;&#125;public class ComputeImpl extends ICompute.Stub &#123; @Override public int add(int a,int b) &#123; return a + b; &#125;&#125; 创建Binder连接池的AIDL接口 123interface IBinderPool &#123; IBinder queryBinder(int binderCode);&#125; 实现连接池queryBinder方法 12345678910111213@Overridepublic IBinder queryBinder(int binderCode) &#123; IBinder binder = null; switch (binderCode) &#123; case IBINDER_SECURITY_CENTER: binder = new SeccurityCenterImpl(); break; case IBINDER_COMPUTE: binder = new ComputeImpl(); break; &#125; return binder;&#125; 实现BinderPoolService 12345678910111213public class BinderPoolService extends Service &#123; private Binder mBinderPool = new BinderPool.BinderPoolImpl(); . . . @Override public IBinder onBind(Intent intent)&#123; return mBinderPool; &#125; . . .&#125; BinderPool连接池实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class BinderPool &#123; public static final int BINDER_NOE = -1; public static final int BINDER_COMPUTE = 0; public static final int BINDER_SECURITY_CENTER = 1; private Context context; private IBinderPool mBinderPool; private static volatile BinderPool sInstance; private CountDownLatch mConnectBinderPoolCountDownLatch; private BinderPool(Context context) &#123; mContext = context.getApplicationContext(); connectBinderPoolService(); &#125; public static BinderPool getInstance(Context context)&#123; ... return instance; &#125; private synchronized void connectBinderPoolService()&#123; mConnectBinderPoolCountDownLatch = new CountDownLatch(1); Intent service = new Intent(mContext, BinderPoolService.class); mContgxt.bindService(service,mBinderPoolConnection, Context.BIND_AUTO_CREATE); try&#123; mConnectBinderPoolCountDownLatch.await(); &#125;catch(Exception e)&#123; e.printStackTrance(); &#125; &#125; public IBinder queryBinder(int binderCode)&#123; IBinder binder = null; try &#123; if (mBinderPool != null ) binder = mBinderPool.queryBinder(binderCode); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; return binder; &#125; private ServiceConnection mBinderPoolConnection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name)&#123; &#125; @Override public void onServiceConencted(ComponentName name,IBinder service)&#123; mBinderPool = IBinderPool.Stub.asInterface(service); try &#123; mBinderPool.asBinder().linkToDeath(mBinderPoolDeathRecipient,0); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; mConnectBinderPoolCountDownLatch.countDown(); &#125; &#125;; private IBinder.DeathRecipient mBinderPoolDeathRecipient = new IBinder.DeathRecipient()&#123; @Override public void binderDied()&#123; mBinderPool.asBinder().unlinkToDeath(mBinderPoolDeathRecipient,0); mBinderPool = null; connectBinderPoolService(); &#125; &#125;; public static class BinderPoolImpl extends IBinderPool.Stub &#123; public BinderPoolImpl() &#123; super(); &#125; @Override public IBinder queryBinder(int binderCode) throws RemoteException &#123; IBinder binder = null; switch (binderCode) &#123; case BINDER_SECURITY_CENTER: &#123; binder = new SecurityCenterImpl(); break; &#125; case BINDER_COMPUTE: binder = new ComputeImpl(); break; &#125; return binder; &#125; &#125;&#125; BinderPool使用 1234567private void doWork()&#123; BinderPool binderPool = BinderPool.getInstance(BinderPoolActivity.this); IBinder computeBinder = binderPool.queryPool(BinderPool.BINDER_COMPUTE); ICompute mCompute = ComputeImpl.asInterface(computeBinder); //使用 mCompute.add(3,5);&#125; 在Binder线程池实现过程中，使用到了CountDownLatch讲bindService操作由异步变成同步操作，因此操作需要放在新的线程中执行，同时包含了断线重连机制，也意味着，一旦产生了断线重连的情况，记得手动获取新的Binder对象。 IPC总结在众多的IPC方式中，简单易用的有Bundle和文件共享机制，不过它们都不适合高并发且实时通信，只适合简单数据的交换工作，而AIDL支持高并发通信，但是要处理线程同步问题，使用起来稍微麻烦一些，因此有了上层封装好的Messenger和ContentProvider通信，Messenger使用Message使用数据交换，而ContentProvider更适合于一对多的数据共享，最后是Socket通信，它支持实时通信，通过网络传输字节流，实现起来也稍微麻烦一些。 参考 Android系统进程间通信Binder机制在应用程序框架层的Java接口源代码分析 深入理解android之IPC机制与Binder框架","tags":[{"name":"MultiProcess","slug":"MultiProcess","permalink":"https://hjw541988478.github.io/tags/MultiProcess/"},{"name":"IPC","slug":"IPC","permalink":"https://hjw541988478.github.io/tags/IPC/"},{"name":"Binder","slug":"Binder","permalink":"https://hjw541988478.github.io/tags/Binder/"}]},{"title":"顶层悬浮球分析与实现","date":"2015-11-19T11:12:00.000Z","path":"2015/11/顶层悬浮球分析与实现/","text":"悬浮球功能作为顶层视图，在用户关闭了 APP 后也能方便快捷操作，而这类应用主要是系统级别的安全应用，比如一键清理内存。在后续的 Android 版本中，Google 和很多厂商对于此类权限做了更为敏感的控制，需要用户手动设置才能看到悬浮球。下面手动实现了一个悬浮球来分析整个过程，其核心部分就是WindowManager类对Window的管理。 WindowManager对于WindowManager的工作过程，可以通过手动添加一个Window为例去分析：12345678TextView mFloatingText = new TextView(this);mFloatingText.setText(\"FloatingText\");WindowManager.LayoutParams params = new WindowManager.LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT,0,0,PixelFormat.TRANSPARENT);params.flags = LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_SHOW_WHEN_LOCKED;params.gravity = Gravity.LEFT | Gravity.TOP;params.x = 300;params.y = 100;mWindowManager.addView(mFloatingText,params); 上述代码将一个TextView添加到屏幕坐标为(300,100)的位置上。其中对于flags和type参数比较重要，flags表示Window显示属性，有主要的值： FLAG_NOT_FOCUSABLE表示 Window 不需要获取焦点，最终的触摸事件会直接传递到下层具有焦点的 Window； FLAG_NOT_TOUCH_MODAL表示当前 Window 区域的点击事件自己处理，其他区域交给底层 Window 去处理； FLAG_SHOW_WHEN_LOCKED表示可以显示在锁屏界面上。type参数表示 Window 的类型，Window有三种类型，分别是应用 Window，子 Window和系统 Window，层级越大表示越顶层： 应用 Window对应着一个 Activity，1~99层； 子 Window不能单独存在，必须附属于父 Window之上，比如 Dialog，1000-1999层； 系统 Window声明权限才能创建，比如 Toast 和系统状态栏，2000-2999层。首先加上权限，1&lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\"/&gt; 然后设置 type 属性，1mParams.type = LayoutParams.TYPE_SYSTEM_ERROR; 对于仅有的addView、updateViewLayout和removeView方法，已经可以满足添加视图、更新视图和删除视图了。 实现首先是主布局，提供一个Button，通过单击该按钮来打开浮窗，主要涉及到的是一个主入口Activity和主布局文件。1234567891011121314151617import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.start_float_window).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startService(new Intent(MainActivity.this,FloatWindowService.class)); &#125; &#125;); &#125;&#125; 可以看到的是，实际上是启动了一个Service，也就是说对于悬浮球的操作都是在FloatWindowService类中完成的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import android.app.ActivityManager;import android.app.Service;import android.content.Context;import android.content.Intent;import android.content.pm.PackageManager;import android.content.pm.ResolveInfo;import android.os.Handler;import android.os.IBinder;import java.util.ArrayList;import java.util.List;import java.util.Timer;import java.util.TimerTask;public class FloatWindowService extends Service &#123; /** * 用于在线程中创建或移除悬浮窗。 */ private Handler handler = new Handler(); /** * 定时器，定时进行检测当前应该创建还是移除悬浮窗。 */ private Timer timer; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; // 开启定时器，每隔0.5秒刷新一次 if (timer == null) &#123; timer = new Timer(); timer.scheduleAtFixedRate(new RefreshTask(), 0, 500); &#125; return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); // Service被终止的同时也停止定时器继续运行 timer.cancel(); timer = null; &#125; class RefreshTask extends TimerTask &#123; @Override public void run() &#123; // 当前界面是桌面，且没有悬浮窗显示，则创建悬浮窗。 if (isHome() &amp;&amp; !MyWindowManager.isWindowShowing()) &#123; handler.post(new Runnable() &#123; @Override public void run() &#123; MyWindowManager.createSmallWindow(getApplicationContext()); &#125; &#125;); &#125; // 当前界面不是桌面，且有悬浮窗显示，则移除悬浮窗。 else if (!isHome() &amp;&amp; MyWindowManager.isWindowShowing()) &#123; handler.post(new Runnable() &#123; @Override public void run() &#123; MyWindowManager.removeSmallWindow(getApplicationContext()); MyWindowManager.removeBigWindow(getApplicationContext()); &#125; &#125;); &#125; // 当前界面是桌面，且有悬浮窗显示，则更新内存数据。 else if (isHome() &amp;&amp; MyWindowManager.isWindowShowing()) &#123; handler.post(new Runnable() &#123; @Override public void run() &#123; MyWindowManager.updateUsedPercent(getApplicationContext()); &#125; &#125;); &#125; &#125; &#125; /** * 判断当前界面是否是桌面 */ private boolean isHome() &#123; ActivityManager mActivityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; rti = mActivityManager.getRunningTasks(1); return getHomes().contains(rti.get(0).topActivity.getPackageName()); &#125; /** * 获得属于桌面的应用的应用包名称 * * @return 返回包含所有包名的字符串列表 */ private List&lt;String&gt; getHomes() &#123; List&lt;String&gt; names = new ArrayList&lt;String&gt;(); PackageManager packageManager = this.getPackageManager(); Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_HOME); List&lt;ResolveInfo&gt; resolveInfo = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY); for (ResolveInfo ri : resolveInfo) &#123; names.add(ri.activityInfo.packageName); &#125; return names; &#125;&#125; 可见FloatWindowService在onStartCommand方法中开启了一个定时器，每隔500毫秒就会执行RefreshTask任务。任务主要执行的操作是，当前界面是桌面的话则显示悬浮球并刷新内存使用率，否则隐藏悬浮球。且当服务停止时，将定时器销毁，防止内存泄露。从上面的代码我们也可以看出，创建和移除悬浮窗，以及更新悬浮窗的内容，都是由MyWindowManager这个类来管理的，比起直接写在Service中，能够更好的分离代码。既然悬浮窗能够显示了，接下来就是悬浮窗视图 View 的实现了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135import android.content.Context;import android.view.LayoutInflater;import android.view.MotionEvent;import android.view.View;import android.view.WindowManager;import android.widget.LinearLayout;import android.widget.TextView;import java.lang.reflect.Field;public class FloatWindowSmallView extends LinearLayout &#123; /** * 记录小悬浮窗的宽度 */ public static int viewWidth; /** * 记录小悬浮窗的高度 */ public static int viewHeight; /** * 记录系统状态栏的高度 */ private static int statusBarHeight; /** * 用于更新小悬浮窗的位置 */ private WindowManager windowManager; /** * 小悬浮窗的参数 */ private WindowManager.LayoutParams mParams; /** * 记录当前手指位置在屏幕上的横坐标值 */ private float xInScreen; /** * 记录当前手指位置在屏幕上的纵坐标值 */ private float yInScreen; /** * 记录手指按下时在屏幕上的横坐标的值 */ private float xDownInScreen; /** * 记录手指按下时在屏幕上的纵坐标的值 */ private float yDownInScreen; /** * 记录手指按下时在小悬浮窗的View上的横坐标的值 */ private float xInView; /** * 记录手指按下时在小悬浮窗的View上的纵坐标的值 */ private float yInView; public FloatWindowSmallView(Context context) &#123; super(context); windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); LayoutInflater.from(context).inflate(R.layout.float_window_small, this); View view = findViewById(R.id.small_window_layout); viewWidth = view.getLayoutParams().width; viewHeight = view.getLayoutParams().height; TextView percentView = (TextView) findViewById(R.id.percent); percentView.setText(MyWindowManager.getUsedPercentValue(context)); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 手指按下时记录必要数据,纵坐标的值都需要减去状态栏高度 xInView = event.getX(); yInView = event.getY(); xDownInScreen = event.getRawX(); yDownInScreen = event.getRawY() - getStatusBarHeight(); xInScreen = event.getRawX(); yInScreen = event.getRawY() - getStatusBarHeight(); break; case MotionEvent.ACTION_MOVE: xInScreen = event.getRawX(); yInScreen = event.getRawY() - getStatusBarHeight(); // 手指移动的时候更新小悬浮窗的位置 updateViewPosition(); break; case MotionEvent.ACTION_UP: // 如果手指离开屏幕时，xDownInScreen和xInScreen相等，且yDownInScreen和yInScreen相等，则视为触发了单击事件。 if (xDownInScreen == xInScreen &amp;&amp; yDownInScreen == yInScreen) &#123; openBigWindow(); &#125; break; default: break; &#125; return true; &#125; /** * 将小悬浮窗的参数传入，用于更新小悬浮窗的位置。 * * @param params 小悬浮窗的参数 */ public void setParams(WindowManager.LayoutParams params) &#123; mParams = params; &#125; /** * 更新小悬浮窗在屏幕中的位置。 */ private void updateViewPosition() &#123; mParams.x = (int) (xInScreen - xInView); mParams.y = (int) (yInScreen - yInView); windowManager.updateViewLayout(this, mParams); &#125; /** * 打开大悬浮窗，同时关闭小悬浮窗。 */ private void openBigWindow() &#123; MyWindowManager.createBigWindow(getContext()); MyWindowManager.removeSmallWindow(getContext()); &#125; /** * 用于获取状态栏的高度。 * * @return 返回状态栏高度的像素值。 */ private int getStatusBarHeight() &#123; if (statusBarHeight == 0) &#123; try &#123; Class&lt;?&gt; c = Class.forName(\"com.android.internal.R$dimen\"); Object o = c.newInstance(); Field field = c.getField(\"status_bar_height\"); int x = (Integer) field.get(o); statusBarHeight = getResources().getDimensionPixelSize(x); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return statusBarHeight; &#125;&#125; 为了实现悬浮球随手指移动而移动的效果，于是对onTouchEvent事件进行了重写。在用户按下瞬间触发ACTION_DOWN事件，按下的点在屏幕中的坐标，以及相对于视图的位置，然后随着手指的移动会触发ACTION_MOVE事件，此时获取新的屏幕坐标，更新悬浮球在屏幕中位置，最后手指抬起来，则触发ACTION_UP事件，如果此时的坐标和ACTION_DOWN中坐标是一致的，则表示单击了悬浮窗。记得处理屏幕状态栏的高度，在处理坐标的时候应该减掉这一部分值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197import android.app.ActivityManager;import android.content.Context;import android.graphics.PixelFormat;import android.view.Gravity;import android.view.ViewGroup;import android.view.WindowManager;import android.widget.TextView;import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class MyWindowManager &#123; /** * 小悬浮窗View的实例 */ private static FloatWindowSmallView smallWindow; /** * 大悬浮窗View的实例 */ private static FloatWindowBigView bigWindow; /** * 小悬浮窗View的参数 */ private static WindowManager.LayoutParams smallWindowParams; /** * 大悬浮窗View的参数 */ private static WindowManager.LayoutParams bigWindowParams; /** * 用于控制在屏幕上添加或移除悬浮窗 */ private static WindowManager mWindowManager; /** * 用于获取手机可用内存 */ private static ActivityManager mActivityManager; /** * 创建一个小悬浮窗。初始位置为屏幕的右部中间位置。 * * @param context * 必须为应用程序的Context. */ public static void createSmallWindow(Context context) &#123; WindowManager windowManager = getWindowManager(context); int screenWidth = windowManager.getDefaultDisplay().getWidth(); int screenHeight = windowManager.getDefaultDisplay().getHeight(); if (smallWindow == null) &#123; smallWindow = new FloatWindowSmallView(context); if (smallWindowParams == null) &#123; smallWindowParams = new WindowManager.LayoutParams(); smallWindowParams.type = WindowManager.LayoutParams.TYPE_PHONE; smallWindowParams.format = PixelFormat.RGBA_8888; smallWindowParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE; smallWindowParams.gravity = Gravity.LEFT | Gravity.TOP; smallWindowParams.width = FloatWindowSmallView.viewWidth; smallWindowParams.height = FloatWindowSmallView.viewHeight; smallWindowParams.x = screenWidth; smallWindowParams.y = screenHeight / 2; &#125; smallWindow.setParams(smallWindowParams); windowManager.addView(smallWindow, smallWindowParams); &#125; &#125; /** * 将小悬浮窗从屏幕上移除。 * * @param context * 必须为应用程序的Context. */ public static void removeSmallWindow(Context context) &#123; if (smallWindow != null) &#123; WindowManager windowManager = getWindowManager(context); windowManager.removeView(smallWindow); smallWindow = null; &#125; &#125; /** * 创建一个大悬浮窗。位置为屏幕正中间。 * * @param context * 必须为应用程序的Context. */ public static void createBigWindow(Context context) &#123; WindowManager windowManager = getWindowManager(context); int screenWidth = windowManager.getDefaultDisplay().getWidth(); int screenHeight = windowManager.getDefaultDisplay().getHeight(); if (bigWindow == null) &#123; bigWindow = new FloatWindowBigView(context); if (bigWindowParams == null) &#123; bigWindowParams = new WindowManager.LayoutParams(); bigWindowParams.x = screenWidth / 2 - FloatWindowBigView.viewWidth / 2; bigWindowParams.y = screenHeight / 2 - FloatWindowBigView.viewHeight / 2; bigWindowParams.type = WindowManager.LayoutParams.TYPE_PHONE; bigWindowParams.format = PixelFormat.RGBA_8888; bigWindowParams.gravity = Gravity.LEFT | Gravity.TOP; bigWindowParams.width = FloatWindowBigView.viewWidth; bigWindowParams.height = FloatWindowBigView.viewHeight; &#125; windowManager.addView(bigWindow, bigWindowParams); &#125; &#125; /** * 将大悬浮窗从屏幕上移除。 * * @param context * 必须为应用程序的Context. */ public static void removeBigWindow(Context context) &#123; if (bigWindow != null) &#123; WindowManager windowManager = getWindowManager(context); windowManager.removeView(bigWindow); bigWindow = null; &#125; &#125; /** * 更新小悬浮窗的TextView上的数据，显示内存使用的百分比。 * * @param context * 可传入应用程序上下文。 */ public static void updateUsedPercent(Context context) &#123; if (smallWindow != null) &#123; TextView percentView = (TextView) smallWindow.findViewById(R.id.percent); percentView.setText(getUsedPercentValue(context)); &#125; &#125; /** * 是否有悬浮窗(包括小悬浮窗和大悬浮窗)显示在屏幕上。 * * @return 有悬浮窗显示在桌面上返回true，没有的话返回false。 */ public static boolean isWindowShowing() &#123; return smallWindow != null || bigWindow != null; &#125; /** * 如果WindowManager还未创建，则创建一个新的WindowManager返回。否则返回当前已创建的WindowManager。 * * @param context * 必须为应用程序的Context. * @return WindowManager的实例，用于控制在屏幕上添加或移除悬浮窗。 */ private static WindowManager getWindowManager(Context context) &#123; if (mWindowManager == null) &#123; mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); &#125; return mWindowManager; &#125; /** * 如果ActivityManager还未创建，则创建一个新的ActivityManager返回。否则返回当前已创建的ActivityManager。 * * @param context * 可传入应用程序上下文。 * @return ActivityManager的实例，用于获取手机可用内存。 */ private static ActivityManager getActivityManager(Context context) &#123; if (mActivityManager == null) &#123; mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); &#125; return mActivityManager; &#125; /** * 计算已使用内存的百分比，并返回。 * * @param context * 可传入应用程序上下文。 * @return 已使用内存的百分比，以字符串形式返回。 */ public static String getUsedPercentValue(Context context) &#123; String dir = \"/proc/meminfo\"; try &#123; FileReader fr = new FileReader(dir); BufferedReader br = new BufferedReader(fr, 2048); String memoryLine = br.readLine(); String subMemoryLine = memoryLine.substring(memoryLine.indexOf(\"MemTotal:\")); br.close(); long totalMemorySize = Integer.parseInt(subMemoryLine.replaceAll(\"\\\\D+\", \"\")); long availableSize = getAvailableMemory(context) / 1024; int percent = (int) ((totalMemorySize - availableSize) / (float) totalMemorySize * 100); return percent + \"%\"; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return \"悬浮窗\"; &#125; /** * 获取当前可用内存，返回数据以字节为单位。 * * @param context * 可传入应用程序上下文。 * @return 当前可用内存。 */ private static long getAvailableMemory(Context context) &#123; ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo(); getActivityManager(context).getMemoryInfo(mi); return mi.availMem; &#125;&#125; MyWindowManager主要负责了控制悬浮窗的创建和移除，以及悬浮窗在桌面上显示时系统内存使用率计算操作。其中WindowManager.LayoutParams布局参数在一开始就进行了说明，在设置好了后进行addView悬浮窗便可以显示了，而在需要移除的时候，获取到悬浮窗 View 的引用直接进行removeView操作便好。最后记得在AndroidManifest.xml文件中配置好Service和相关权限：12345678910111213&lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" /&gt;&lt;uses-permission android:name=\"android.permission.SYSTEM_OVERLAY_WINDOW\" /&gt;&lt;uses-permission android:name=\"android.permission.GET_TASKS\" /&gt;&lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=\".FloatWindowService\"/&gt;&lt;/application&gt; 59%内存使用率效果图 总结总的来说，悬浮窗简单的控制还是容易实现的，但对于业务功能稍微复杂来说，合理的内存控制以及交互效果实现是需要花时间研究的地方。 参考 Android桌面悬浮窗效果实现，仿360手机卫士悬浮窗效果","tags":[{"name":"Service","slug":"Service","permalink":"https://hjw541988478.github.io/tags/Service/"},{"name":"FloatWindow","slug":"FloatWindow","permalink":"https://hjw541988478.github.io/tags/FloatWindow/"},{"name":"WindowManager","slug":"WindowManager","permalink":"https://hjw541988478.github.io/tags/WindowManager/"}]},{"title":"OkHttp探索使用","date":"2015-09-16T12:12:00.000Z","path":"2015/09/OkHttp探索使用/","text":"为Android和Java应用设计并且支持SPDY和HTTP请求的客户端。 CallsRequests(请求)每个HTTP请求包含了URL、METHOD和一系列头部信息。当然，头部也可以包含指定类型的数据流。 Responses(响应)带有状态码，Header和一些可选信息的对请求的响应。 Calls(调用)调用能够以Synchronous(同步)或者Asynchronous(异步)的形式被执行: Synchronous：请求线程直到响应能够可读时才会释放阻塞； Asynchronous：请求线程能够将请求进行入队操作，直到响应发生时以回调接口的形式返回。 ConnectionsURLS(统一资源定位符)URLs对于HTTP和互联网世界来说是至关重要的，除了成为通用的、web世界里唯一命名的解决方案，它们同时也描述了如何获取web资源。 Addresses(地址)地址描述了一个web服务器和一切对于连接到服务器必要的静态配置信息，比如端口号，HTTPS设置等。共享同一地址的URL同样也共享同一的TCP连接，这样做的好处是：更低的延迟、更高的吞吐量和低消耗电量。OkHttp使用自动重用HTTP/1.x协议的连接和多路复用HTTP/2和SPDY的连接的ConnectionPool（连接池）。 Routes(路由)路由提供连接到web服务器的必要的动态信息。对于一个地址来说可能存在着多条路由选择。 Connections(连接)如果使用OkHttp进行请求的话，它会这么做： 使用给出的URL和配置好的OkHttpClient产生一个Address，这个Address描述了我们如何连接到web服务器； 试图从ConnectionPool(连接池)重新获得一个连接； 如果在连接池找不到连接，它将尝试选择一条路由信息。这也意味着会产生一个DNS请求以便获取真实的服务器IP地址，然后选择TLS版本以及必要时代理服务器的相关信息； 如果是新的路由，它将会通过Socket进行直接连接或者TLS隧道，必要时会进行握手，进行连接； 发送HTTP请求并获得响应信息。一旦响应成功接收到后，连接会被加入到连接池中以便后续的复用，但如果长时间的不使用的后，连接也会从连接池中丢弃。 示例SynchronousGet同步Get请求，响应中的string()方法很方便地让响应以String的形式返回，但数据量大于1M的时候，优先使用Stream。12345678910111213private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; Request request = new Request.Builder() .url(\"http://publicobject.com/helloworld.txt\") .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); Headers responseHeaders = response.headers(); for (int i = 0; i &lt; responseHeaders.size(); i++) &#123; System.out.println(responseHeaders.name(i) + \": \" + responseHeaders.value(i)); &#125; System.out.println(response.body().string());&#125; Asynchronous Get在工作线程上下载文件，当响应可读的时候获取回调接口。回调接口是在响应的头部信息准备好时便准备完毕了，此时直接读取响应的信息可能会导致阻塞。目前的OkHttp版本暂未提供异步的APi去解析接收Response。12345678910111213141516171819private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; Request request = new Request.Builder() .url(\"http://publicobject.com/helloworld.txt\") .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Request request, Throwable throwable) &#123; throwable.printStackTrace(); &#125; @Override public void onResponse(Response response) throws IOException &#123; if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); Headers responseHeaders = response.headers(); for (int i = 0; i &lt; responseHeaders.size(); i++) &#123; System.out.println(responseHeaders.name(i) + \": \" + responseHeaders.value(i)); &#125; System.out.println(response.body().string()); &#125; &#125;);&#125; Accessing Headers显而易见地，HTTP的头部信息与Map这种数据结构是很相似的，每一个key对应着一个value，但有些头部允许着多个value，比如Guava的Multimap,对于这些情况，OkHttp同时都支持的。当写入请求头部信息的时候，使用header(name,value)来设置唯一的键值。如果有存在着对应的值，在新的值设置好之前旧的值会被移除掉。可以考虑使用addHeaeder(name,value)来使得一个key对应着多个值。当读取响应体的头部信息时，可以使用header(name)来获取最后一个设置的值。通常来说这也是唯一的引用，但是如果没有对应的值的话，会返回null。在读取多值对应一键的情况下时，使用headerss(name)来以List的形式来获取其值。如果想获取所有的头部，可以考虑使用Headers类通过索引来获取每一个头。1234567891011121314private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; Request request = new Request.Builder() .url(\"https://api.github.com/repos/square/okhttp/issues\") .header(\"User-Agent\", \"OkHttp Headers.java\") .addHeader(\"Accept\", \"application/json; q=0.5\") .addHeader(\"Accept\", \"application/vnd.github.v3+json\") .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(\"Server: \" + response.header(\"Server\")); System.out.println(\"Date: \" + response.header(\"Date\")); System.out.println(\"Vary: \" + response.headers(\"Vary\"));&#125; Post String当POST请求的字符串数据小于1MB的时候，推荐使用这种方式请求。12345678910111213141516171819public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(\"text/x-markdown; charset=utf-8\"); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; String postBody = \"\" + \"Releases\\n\" + \"--------\\n\" + \"\\n\" + \" * _1.0_ May 6, 2013\\n\" + \" * _1.1_ June 15, 2013\\n\" + \" * _1.2_ August 11, 2013\\n\"; Request request = new Request.Builder() .url(\"https://api.github.com/markdown/raw\") .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody)) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(response.body().string()); &#125; Post Streaming当以流的形式进行POST请求时，请求体的内容已经生成了就如同被写入了一样。下面的例子中使用了Okio的缓冲池。但一般情况下我们会使用OutputStream，我们可以使用BufferedSink.outputStream()来获取。12345678910111213141516171819202122232425262728293031public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(\"text/x-markdown; charset=utf-8\"); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; RequestBody requestBody = new RequestBody() &#123; @Override public MediaType contentType() &#123; return MEDIA_TYPE_MARKDOWN; &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; sink.writeUtf8(\"Numbers\\n\"); sink.writeUtf8(\"-------\\n\"); for (int i = 2; i &lt;= 997; i++) &#123; sink.writeUtf8(String.format(\" * %s = %s\\n\", i, factor(i))); &#125; &#125; private String factor(int n) &#123; for (int i = 2; i &lt; n; i++) &#123; int x = n / i; if (x * i == n) return factor(x) + \" × \" + i; &#125; return Integer.toString(n); &#125; &#125;; Request request = new Request.Builder() .url(\"https://api.github.com/markdown/raw\") .post(requestBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(response.body().string()); &#125; Post File使用文件作为请求体是很容易的。12345678910111213public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(\"text/x-markdown; charset=utf-8\"); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; File file = new File(\"README.md\"); Request request = new Request.Builder() .url(\"https://api.github.com/markdown/raw\") .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file)) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(response.body().string()); &#125; Posting form parameters使用FormEncodingBuilder来构造一个可以像HTML中标签的请求体。键值对会与HTML相适应地特性从URL中进行编码。12345678910111213private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; RequestBody formBody = new FormEncodingBuilder() .add(\"search\", \"Jurassic Park\") .build(); Request request = new Request.Builder() .url(\"https://en.wikipedia.org/w/index.php\") .post(formBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(response.body().string()); &#125; Posting a multipart requestMultipartBuilder可以用来构造复杂的请求体，每一部分都是一个请求体，并且可以自定义头部信息。如果存在的话，请求体的头部信息应该描述请求的内容，比如Content-Disposition。当然如果Content-Length与Content-Type存在的话，会自动加入到请求的头部当中。1234567891011121314151617181920212223private static final String IMGUR_CLIENT_ID = \"...\"; private static final MediaType MEDIA_TYPE_PNG = MediaType.parse(\"image/png\"); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image RequestBody requestBody = new MultipartBuilder() .type(MultipartBuilder.FORM) .addPart( Headers.of(\"Content-Disposition\", \"form-data; name=\\\"title\\\"\"), RequestBody.create(null, \"Square Logo\")) .addPart( Headers.of(\"Content-Disposition\", \"form-data; name=\\\"image\\\"\"), RequestBody.create(MEDIA_TYPE_PNG, new File(\"website/static/logo-square.png\"))) .build(); Request request = new Request.Builder() .header(\"Authorization\", \"Client-ID \" + IMGUR_CLIENT_ID) .url(\"https://api.imgur.com/3/image\") .post(requestBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(response.body().string()); &#125; Parse a JSON Response With GsonGSON是一个很方便的API用来转换JSON和Java对象，需要的注意的是ResponseBody.charStream方法默认使用UTF-8编码进行解码，如果有必要的话请设置Content-Type。1234567891011121314151617181920private final OkHttpClient client = new OkHttpClient(); private final Gson gson = new Gson(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(\"https://api.github.com/gists/c2a7c39532239ff261be\") .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); Gist gist = gson.fromJson(response.body().charStream(), Gist.class); for (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123; System.out.println(entry.getKey()); System.out.println(entry.getValue().content); &#125; &#125; static class Gist &#123; Map&lt;String, GistFile&gt; files; &#125; static class GistFile &#123; String content; &#125; Response Caching但需要缓存的时候，应该指定用来进行缓存的目录，缓存目录一般只是用来给自己进行读写的，而非让任意应用进行缓存。多个缓存访问同一个缓存目录是一种错误的做法，如果需要多个缓存应该使用多个OkHttpClient实例去设置多个缓存目录，否则可能会造成应用崩溃。当然有一种更简洁的做法是直接在头部信息里面设置Cache-Control:max-age=9600来允许缓存。12345678910111213141516171819202122232425private final OkHttpClient client; public CacheResponse(File cacheDirectory) throws Exception &#123; int cacheSize = 10 * 1024 * 1024; // 10 MiB Cache cache = new Cache(cacheDirectory, cacheSize); client = new OkHttpClient(); client.setCache(cache); &#125; public void run() throws Exception &#123; Request request = new Request.Builder() .url(\"http://publicobject.com/helloworld.txt\") .build(); Response response1 = client.newCall(request).execute(); if (!response1.isSuccessful()) throw new IOException(\"Unexpected code \" + response1); String response1Body = response1.body().string(); System.out.println(\"Response 1 response: \" + response1); System.out.println(\"Response 1 cache response: \" + response1.cacheResponse()); System.out.println(\"Response 1 network response: \" + response1.networkResponse()); Response response2 = client.newCall(request).execute(); if (!response2.isSuccessful()) throw new IOException(\"Unexpected code \" + response2); String response2Body = response2.body().string(); System.out.println(\"Response 2 response: \" + response2); System.out.println(\"Response 2 cache response: \" + response2.cacheResponse()); System.out.println(\"Response 2 network response: \" + response2.networkResponse()); System.out.println(\"Response 2 equals Response 1? \" + response1Body.equals(response2Body)); &#125; 为了防止响应使用缓存，可以通过设置CacheControl.FORCE_NETWORK来强制使用网络，当然也可以设置CacheControl.FORCE_CACHE来强制使用缓存而不使用网络。但值得注意的地方就是，在强制使用缓存的时候，然而响应需要使用网络，此时会返回504 Unsatisfiable Request错误。 Canceling a Call使用Call.cancell来立即取消正在进行的请求。如果此时正在进行请求或者读取响应时，执行该操作会导致IOException。在不需要进行请求的时候才进行cancel的请求，比如已经离开了应用，此时所有异步和同步的请求都可以取消。一种简便的方法是使用tag参数，构造请求的时候使用RequestBuilder.tag(tag)，在取消的时候使用OkHttpClient.cancel(tag)。123456789101112131415161718192021222324252627private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(\"http://httpbin.org/delay/2\") // This URL is served with a 2 second delay. .build(); final long startNanos = System.nanoTime(); final Call call = client.newCall(request); // Schedule a job to cancel the call in 1 second. executor.schedule(new Runnable() &#123; @Override public void run() &#123; System.out.printf(\"%.2f Canceling call.%n\", (System.nanoTime() - startNanos) / 1e9f); call.cancel(); System.out.printf(\"%.2f Canceled call.%n\", (System.nanoTime() - startNanos) / 1e9f); &#125; &#125;, 1, TimeUnit.SECONDS); try &#123; System.out.printf(\"%.2f Executing call.%n\", (System.nanoTime() - startNanos) / 1e9f); Response response = call.execute(); System.out.printf(\"%.2f Call was expected to fail, but completed: %s%n\", (System.nanoTime() - startNanos) / 1e9f, response); &#125; catch (IOException e) &#123; System.out.printf(\"%.2f Call failed as expected: %s%n\", (System.nanoTime() - startNanos) / 1e9f, e); &#125; &#125; Timeouts超时的问题可以使用OkHttpClient来进行设置读取、连接的超时时间。1234567891011121314private final OkHttpClient client; public ConfigureTimeouts() throws Exception &#123; client = new OkHttpClient(); client.setConnectTimeout(10, TimeUnit.SECONDS); client.setWriteTimeout(10, TimeUnit.SECONDS); client.setReadTimeout(30, TimeUnit.SECONDS); &#125; public void run() throws Exception &#123; Request request = new Request.Builder() .url(\"http://httpbin.org/delay/2\") // This URL is served with a 2 second delay. .build(); Response response = client.newCall(request).execute(); System.out.println(\"Response completed: \" + response); &#125; Per-call Configuration可以使用已经配置好的请求来克隆其配置，同时单独配置其他信息。12345678910111213141516171819202122private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(\"http://httpbin.org/delay/1\") // This URL is served with a 1 second delay. .build(); try &#123; OkHttpClient cloned = client.clone(); // Clone to make a customized OkHttp for this request. cloned.setReadTimeout(500, TimeUnit.MILLISECONDS); Response response = cloned.newCall(request).execute(); System.out.println(\"Response 1 succeeded: \" + response); &#125; catch (IOException e) &#123; System.out.println(\"Response 1 failed: \" + e); &#125; try &#123; OkHttpClient cloned = client.clone(); // Clone to make a customized OkHttp for this request. cloned.setReadTimeout(3000, TimeUnit.MILLISECONDS); Response response = cloned.newCall(request).execute(); System.out.println(\"Response 2 succeeded: \" + response); &#125; catch (IOException e) &#123; System.out.println(\"Response 2 failed: \" + e); &#125; &#125; Handling authenticationOKHttp对于未认证的请求失败时会进行自动重试，当发生了401错误时，使用Authenticator来设置相关认证信息，在构造新的请求的时候应该去包括缺失的认证信息，如果不存在的时候设置null便好。可以使用Response.challenges()来获取相关认证信息，但已经实现了一个基本的认证信息时，只需要使用Credentials.basic(username,password来加密请求头便好。12345678910111213141516171819202122private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; client.setAuthenticator(new Authenticator() &#123; @Override public Request authenticate(Proxy proxy, Response response) &#123; System.out.println(\"Authenticating for response: \" + response); System.out.println(\"Challenges: \" + response.challenges()); String credential = Credentials.basic(\"jesse\", \"password1\"); return response.request().newBuilder() .header(\"Authorization\", credential) .build(); &#125; @Override public Request authenticateProxy(Proxy proxy, Response response) &#123; return null; // Null indicates no attempt to authenticate. &#125; &#125;); Request request = new Request.Builder() .url(\"http://publicobject.com/secrets/hellosecret.txt\") .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(response.body().string());&#125; 为了避免多次重试造成的认证无法正常工作的情况，可以选择返回nulll。当然也可以像下面一样的处理方式来处理认证失败的情况：123if (credential.equals(response.request().header(\"Authorization\"))) &#123; return null; // If we already failed with these credentials, don't retry. &#125; 同时也可以指定重试次数：123if (responseCount(response) &gt;= 3) &#123; return null; // If we've failed 3 times, give up.&#125; 重试次数的方法：1234567private int responseCount(Response response) &#123; int result = 1; while ((response = response.priorResponse()) != null) &#123; result++; &#125; return result;&#125; Interceptors(拦截器)拦截器是一种用来进行监控，重写，重试和重新调用的强大机制。下面是一种简单的实现，只是用来简单的LOG输出。12345678910111213class LoggingInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); long t1 = System.nanoTime(); logger.info(String.format(\"Sending request %s on %s%n%s\", request.url(), chain.connection(), request.headers())); Response response = chain.proceed(request); long t2 = System.nanoTime(); logger.info(String.format(\"Received response for %s in %.1fms%n%s\", response.request().url(), (t2 - t1) / 1e6d, response.headers())); return response; &#125;&#125; chain.proceed(request)该调用方法是每个拦截器实现的关键部分，看起来简单的方法事实上完成了所有的HTTP调用与处理流程。拦截器也是能够被链接起来的，假设同时拥有压缩的拦截器和校验的拦截器，这里需要确定何时进行校验，何时进行压缩。OkHttp会使用列表进行跟踪，确保拦截器的有序执行。拦截器的允许机制如下图所示： 拦截器运行机制 由图可以看到的是，拦截器存在着两种工作域，全局的拦截器和网络拦截器。 Application Interceptors下面使用LoginInterceptor来对上面两种拦截器进行区分。使用OkHttpClient.interceptors()获取拦截器列表，然后使用add方法进行新的拦截器的添加。12345678OkHttpClient client = new OkHttpClient();client.interceptors().add(new LoggingInterceptor());Request request = new Request.Builder() .url(\"http://www.publicobject.com/helloworld.txt\") .header(\"User-Agent\", \"OkHttp Example\") .build();Response response = client.newCall(request).execute();response.body().close(); 假设存在着重定向的链接，Application级别的拦截器只会被调用一次，即请求时的Sending…和最后返回的 Network Interceptors使用网络层级别的拦截器与上面的很相似，只不过在获取系统拦截器列表的操作interceptors()换成了networkInterceptors()：12345678OkHttpClient client = new OkHttpClient();client.networkInterceptors().add(new LoggingInterceptor());Request request = new Request.Builder() .url(\"http://www.publicobject.com/helloworld.txt\") .header(\"User-Agent\", \"OkHttp Example\") .build();Response response = client.newCall(request).execute();response.body().close(); 对于已存在的重定向的链接，Network级别的拦截器会被调用多次，对应着多个Sending ..和Received..。 比较 Application interceptors 无需担心中间产生的响应； 尽管HTTP响应是从缓存中获得的，但是总是只会调用一次； 只关心应用原始的意图，对于OkHttp自动注入的头部信息并不关心； 允许短路而且无需调用Chain.proceed()； 允许重试而且通过Chain.proceed()来产生多次调用； Network interceptors 能够处理中间产生的相应，比如重定向和重试； 对于网络短路而使用缓存的响应不会被调用； 只关心数据流动正像数据从整个网络传输一样； 能够访问带有请求的Connection对象 重写请求头拦截器可以任意地添加，移除或者替换，对于存在的头可以随意变换。比如，服务端能够支持压缩的请求流，此时可以在Application interceptor中去处理压缩过程。1234567891011121314151617181920212223242526272829/** This interceptor compresses the HTTP request body. Many webservers can't handle this! */final class GzipRequestInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request originalRequest = chain.request(); if (originalRequest.body() == null || originalRequest.header(\"Content-Encoding\") != null) &#123; return chain.proceed(originalRequest); &#125; Request compressedRequest = originalRequest.newBuilder() .header(\"Content-Encoding\", \"gzip\") .method(originalRequest.method(), gzip(originalRequest.body())) .build(); return chain.proceed(compressedRequest); &#125; private RequestBody gzip(final RequestBody body) &#123; return new RequestBody() &#123; @Override public MediaType contentType() &#123; return body.contentType(); &#125; @Override public long contentLength() &#123; return -1; // We don't know the compressed length in advance! &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; BufferedSink gzipSink = Okio.buffer(new GzipSink(sink)); body.writeTo(gzipSink); gzipSink.close(); &#125; &#125;; &#125;&#125; 重写响应既然能够重写请求，那么也可以重写响应。但对于大多数情况下都是不推荐的，因为这回影响返回结果的正确性。不过有时候可以修正某些预先配置错误的信息。比如Cache-Control。123456789/** Dangerous interceptor that rewrites the server's cache-control header. */private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Response originalResponse = chain.proceed(chain.request()); return originalResponse.newBuilder() .header(\"Cache-Control\", \"max-age=60\") .build(); &#125;&#125;; HTTPSOkHttp尝试平衡下面两个具有竞争性质的点： (Connectivity) 更多版本更全面的连接。 (Security) 更多版本的证书支持。总的来说，尽可能使用新版本的OKHttp使得连接性和安全性都能得到保证。 总结参考Wiki和其他博文，自己总结写了个轻量级的能够更快捷方便的OkHttpUtil，支持多种请求：Github：https://github.com/hjw541988478/OkHttpTutorial 参考 OkHttp OkHttpWiki Android OkHttp完全解析 是时候来了解OkHttp了 Android Https相关完全解析 当OkHttp遇到Https","tags":[{"name":"Okhttp","slug":"Okhttp","permalink":"https://hjw541988478.github.io/tags/Okhttp/"}]},{"title":"MaterialDesign设计探索使用","date":"2015-09-09T11:24:14.000Z","path":"2015/09/MaterialDesign设计探索使用/","text":"在Android5.0之后，Google就开始推崇一门新的设计语言MaterialDesign，它更加新鲜和简洁，且能够非常有效的激发应用开发者的创作热情，也能够降低开发者自主开发设计UI的难度，对于MD风格的实现，Google后续完善了下面几个库，一步步的实现MD标准的交互效果。需要在AndroidStudio引入的库：1234compile &apos;com.android.support:design:23.0.0&apos;compile &apos;com.android.support:appcompat-v7:23.0.0&apos;compile &apos;com.android.support:recyclerview-v7:23.0.0&apos;compile &apos;com.android.support:cardview-v7:23.0.0&apos; 新的UI组件CoordinatorLayoutCoordinatorLayout在android.support.deisgn中，是一种增强型的FrameLayout，主要有以下两大基础性作用： 作为顶级应用的装饰器； 作为给多个子View之间进行特定交互的协调器；通过对子View的Behavior的指定，可以实现子View之间的通信，从而确定它们具体的交互行为。 Behavior 官方提供的BehaviorBehaivor是CoordinatorLayout子View之间进行交互的插件，包括了一种或多种交互行为，如拖拉、滑动、下拉等各种手势。已知的子类有AppBarLayout.Behavior，AppBarLayout.ScrollingViewBehavior， FloatingActionButton.Behavior和SwipeDismissBehavior&lt;V extends View&gt;,这些可以直接使用@string/**的形式在layout_behavior属性中使用。 自定义Behavior自定义的Behavior需要重新实现的回调方法有： public boolean layoutDependsOn (CoordinatorLayout parent, View child, View dependency)该方法确定是否有另一个指定的兄弟View作为依赖布局，并且作为对布局请求的响应，至少会调用一次。如果指定的child和dependency返回为true,父ViewCoordinatorLayout可能会做以下两件事：不管子View的命令，始终在dependencyView后展示child；当dependency视图布局或位置发生变化时，调用onDepentViewChanged方法； public boolean onDependentViewChanged (CoordinatorLayout parent, View child, View dependency)无论dependency尺寸或者布局改变，该方法都会被调用。Behavior可能会合适地使用该方法来更新视图以此作为回应。当layoutDependsOn被调用时或者child设置了以一个锚视图，dependency也会改变。如果Behavior改变了child的位置或者大小，则返回true。 NestingScrolling原始触摸事件分发目前的触摸事件的分发机制都是从父View传递给子View，会经历dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent，但是如果触摸事件分发给子View的时候，而子View想根据实际情况将事件向上层传递给父View，而这个时候子View并没有办法通知父View，只能将事件抛弃。 嵌套滑动处理流程在行的嵌套滑动机制中，可以使用到supportv4包中NestedScrollingChild类，包括下面几个关键的方法： public boolean startNestedScroll(int axes)子View寻找能够接受嵌套滑动事件的ParentView，然后通知父View，配合处理触摸事件； public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow)在子View中的onInterceptTouch或者onTouch事件中，通过调用该方法通知父View滑动的距离。其中第三个参数父View消费掉的滑动长度，第四个参数返回子View的窗体偏移量。由于窗体进行了移动，为了下一次触摸事件计算正确，还需要根据第四个参数来计算偏移量。整个方法返回的值是根据父View是否有接受子View滚动参数的消费来决定返回true或者false； public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)在子View进行了scroll后，如果父View接受到了它的滚动参数并进行了消费，则返回true，否则返回false； public void stopNestedScroll()整个嵌套处理流程结束。 AppBarLayoutAppBarLayout是实现了众多MD设计概念特性的垂直方向的LinearLayout，其中一个很重要的概念就是滚动手势。子View可以通过方法setScrollFlags(int)或者XML属性app:layout_scrollFlags去提供期望的滚动行为。该布局应该直接放在CoordinateLayout节点下，同时也需要兄弟View去决定何时滚动，但必须是AppBarLayout.ScrollingViewBehavior的实例。 layout_scrollFlags作为触发特定交互事件的标志，主要有四种： SCROLL_FLAG_ENTER_ALWAYS这个flag让任意向下的滚动使得View可见； SCROLL_FLAG_ENTER_ALWAYS_COLLAPSED当View既设置了minHeight属性又设置了此flag，只有滚动到顶部的时候才会时View可见； SCROLL_FLAG_EXIT_UNTIL_COLLAPSED当View离开屏幕时，保持折叠的状态； SCROLL_FLAG_SCROLLView会直接离开屏幕。 常用属性 layout_scrollFlags设置滚动出发事件的标志 layout_scrollInterpolator设置滚动发生时的插值器 CollapsingToolbarLayoutCollapsingToolbarLayout是实现了折叠的ToolBar的包装，它用来设计作为AppBarLayout的直接子View，可以用来设置众多属性，包括折叠状态的标题、位置等。 collapsedTitleGravity指定折叠状态的标题如何放置，可选值:top、bottom等 collapsedTitleTextAppearance指定折叠状态标题文字的样貌 contentScrim指定CollapsingToolbarLayout完全被滚出到屏幕外时的ColorDrawable expandedTitleGravity指定展开状态的标题如何放置 title指定标题文本 titleEnabled指定是否显示标题文本 toolbarId指定与之关联的ToolBar，如果未指定则默认使用第一个被发现的ToolBar子View layout_collapseModeCOLLAPSE_MODE_OFF:View表现的像没有折叠行为一样；COLLAPSE_MODE_PARALLAX：View会以视差的样式滚动；COLLAPSE_MODE_PIN：View会直到达到CollapsingToolbarLayout底部的时候固定； 实例特性 新的UI组件：Toolbar、DrawerLayout、DrawerNavigationView、SwipeRefreshLayout、RecyclerView、TabLayout、CollapsingToolbarLayout、AppBarLayout、CoordinateLayout、FloatingActionButton、SnackBar、CardView; 已实现效果 下拉刷新 抽屉菜单导航 Tab选项卡导航 视差折叠Toolbar 效果图 抽屉菜单和Tab布局效果图 视差效果图 实现过程下拉刷新 布局 123456789&lt;android.support.v4.widget.SwipeRefreshLayout android:id=\"@+id/id_refresh\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/id_list\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 视图初始化设置刷新监听和适配器RecyclerView recyclerView = (RecyclerView) root.findViewById(R.id.id_list); final SwipeRefreshLayout swipeRefresh = (SwipeRefreshLayout) root.findViewById(R.id.id_refresh); swipeRefresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; adapter.data.add(0, \"onRefresh\"); adapter.notifyDataSetChanged(); swipeRefresh.setRefreshing(false); &#125; &#125;); recyclerView.setLayoutManager(new LinearLayoutManager(getActivity())); recyclerView.setHasFixedSize(true); recyclerView.setAdapter(adapter);// 适配器class RecyclerViewListAdapter extends RecyclerView.Adapter&lt;RecyclerViewListAdapter.MyViewHolder&gt; &#123; private List&lt;String&gt; data = new ArrayList&lt;&gt;(); public RecyclerViewListAdapter(List&lt;String&gt; data) &#123; this.data.clear(); this.data.addAll(data); &#125; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View itemView = LayoutInflater.from(parent.getContext()) .inflate(R.layout.item_fragment_list, parent, false); return new MyViewHolder(itemView); &#125; @Override public void onBindViewHolder(MyViewHolder holder, final int position) &#123; holder.itemText.setText(data.get(position)); holder.rootView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(v.getContext(), DetailActivity.class); intent.putExtra(\"title\", data.get(position)); v.getContext().startActivity(intent); &#125; &#125;); &#125; @Override public int getItemCount() &#123; return data.size(); &#125; class MyViewHolder extends RecyclerView.ViewHolder &#123; @Bind(R.id.id_item_text) TextView itemText; View rootView; public MyViewHolder(View itemView) &#123; super(itemView); rootView = itemView; ButterKnife.bind(this, itemView); &#125; &#125; &#125; 关于下拉刷新部分的详细实现可参考上一篇博文：RecyclerView下拉刷新上拉加载的封装 。 抽屉菜单导航 布局12345678910111213141516&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/id_drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;include layout=\"...\"/&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/id_drawer_nav_view\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\" app:headerLayout=\"@layout/nav_header\" app:menu=\"@menu/menu_drawer\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 需要注意的是，对于抽屉菜单，分为头布局和菜单两部分，头布局是layout资源，而菜单是menu资源，极大地降低了使用的难度，降低了各自的耦合度。 抽屉菜单分解图 nav_header.xml123456789101112131415161718&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\" android:background=\"?attr/colorPrimaryDark\" android:padding=\"16dp\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerVertical=\"true\" android:text=\"Hi, Doge!\" android:textColor=\"@android:color/white\" /&gt; &lt;ImageView android:layout_width=\"120dp\" android:layout_height=\"120dp\" android:layout_centerInParent=\"true\" android:scaleType=\"centerCrop\" android:src=\"@mipmap/doge_head\" /&gt;&lt;/RelativeLayout&gt; menu_drawer.xml12345678910111213141516&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;group android:checkableBehavior=\"single\"&gt; &lt;item android:icon=\"@mipmap/ic_dashboard\" android:title=\"Home\" /&gt; &lt;item android:icon=\"@mipmap/ic_forum\" android:title=\"Setting\" /&gt; &lt;item android:icon=\"@mipmap/ic_event\" android:title=\"Like\" /&gt; &lt;item android:icon=\"@mipmap/ic_headset\" android:title=\"Music\" /&gt; &lt;/group&gt;&lt;/menu&gt; 布局中android:layout_gravity=&quot;start&quot;属性代表着抽屉菜单放在左边，此时通过设置抽屉菜单视图选中的监听器，可以边缘右滑和左上角的菜单图标打开抽屉，点击空白区域或者选中菜单项便可以关闭菜单。1234567891011121314151617navView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(MenuItem menuItem) &#123; menuItem.setCheckable(true); navDrawer.closeDrawers(); return true; &#125; &#125;);@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; int id = item.getItemId(); if (id == android.R.id.home) &#123; navDrawer.openDrawer(GravityCompat.START); return true; &#125; return super.onOptionsItemSelected(item);&#125; Tab选项卡导航 布局123456789101112131415161718192021222324252627282930313233&lt;android.support.design.widget.CoordinatorLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/id_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:layout_scrollFlags=\"scroll|enterAlways\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" /&gt; &lt;android.support.design.widget.TabLayout android:id=\"@+id/id_tabs\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/id_pager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/id_fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"end|bottom\" android:layout_margin=\"16dp\" android:src=\"@mipmap/ic_done\" app:layout_behavior=\".QuickReturnFooterBehavior\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 布局中使用到了CoordinateLayout作为根节点，辅以ViewPager作为事件行为触发器，再通过AppBarLayout的嵌套，便可以实现了向下滑动自动隐藏Toolbar，上滑恢复显示的功能，这里FloatingActionButton同时也用到了一个自定义的Behavior，可以实现自动隐藏与出现的功能，整个过程显得协调一致。TabLayout一般是与ViewPager一起使用的，在iewPager初始化并设置了适配器后，让TabLayout与之联动，最后达到一致的工作的效果。 TabLayout实现效果图 这里只实现了3个Tab栏，按照实际情况需要可以通过对ViewPager适配器，来控制Tab栏的标题和个数。12pager.setAdapter(new ListPagerAdapter(getSupportFragmentManager(), initData()));tabs.setupWithViewPager(pager); 此外TabLayout还有一些其他可在布局文件自定义的属性，如下：123456&lt;!--Tab被选中字体的颜色--&gt;app:tabSelectedTextColor=@android:color/holo_blue_bright&lt;!--Tab未被选中字体的颜色--&gt;app:tabTextColor=@android:color/black&lt;!--Tab指示器下标的颜色--&gt;app:tabIndicatorColor=@android:color/holo_blue_bright 视差折叠效果视图 布局12345678910111213141516171819202122232425&lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/collapsing_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" app:contentScrim=\"?attr/colorPrimary\" app:expandedTitleMarginEnd=\"64dp\" app:expandedTitleMarginStart=\"48dp\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\" app:title=\"doge\"&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" android:scaleType=\"centerCrop\" android:src=\"@mipmap/doge\" app:layout_collapseMode=\"parallax\" /&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_collapseMode=\"pin\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; CollapsingToolbarLayout直面意思就是可折叠的Toolbar布局，通过向下滚动可以使图片逐渐变大，向下滚动使得逐渐以视差效果的形式逐渐变小，最后只剩下Toolbar，在5.0(v21)版本上，通过Style的设置，可以让状态栏也变得透明，让图片和状态栏融为一体。1234&lt;style name=\"AppTheme\" parent=\"BaseAppTheme\"&gt; &lt;item name=\"android:windowDrawsSystemBarBackgrounds\"&gt;true&lt;/item&gt; &lt;item name=\"android:statusBarColor\"&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt; 展开状态 折叠状态 具体实现的关键点在于对layout_collapseMode、layout_scrollFlags和layout_behavior属性的设置，具体设置模式上面有说。 综合使用范例Google有给出的使用范例：12345678910111213141516171819202122&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;!-- Your scrolling content --&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;android.support.design.widget.AppBarLayout android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar ... app:layout_scrollFlags=\"scroll|enterAlways\"/&gt; &lt;android.support.design.widget.TabLayout ... app:layout_scrollFlags=\"scroll|enterAlways\"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 其他组件CardView1234567891011&lt;android.support.v7.widget.CardView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margin=\"8dp\" app:cardElevation=\"8dp\" app:contentPadding=\"16dp\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"这只可爱的柴犬叫Kabosu（かぼす，一种类似于日本柚子的水果，果汁很酸却有种独特的芳香，经常被用作烤鱼或生鱼片的调料）\" /&gt;&lt;/android.support.v7.widget.CardView&gt; item即为卡片视图 CardView继承于Framelayout，所以Framelayout的属性都有，同时也有其它可自定义的属性，app:cardElevation表示在Z轴上的阴影，app:contentPadding表示卡片内容的内边距，app:cardCornerRadius表示卡片四个角的圆角矩形的程度。 Toolbar123456&lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_collapseMode=\"pin\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" /&gt; 作为未来ActionBar的替代品，Google为了统一MD设计的风格和AppBar的设计规范，Toolbar是为了更灵活的ActionBar而生的。通过Style设置NoActionBar，然后再代码中使用setSupportedActionBar方法来使用Toolbar替代ActionBar,此外还可以对其他属性，如标题，背景，LOGO等进行自定义的设置，但请记得要取得ActionBar，请使用getSupportedActionBar方法。 FloatingActionButton12345678&lt;android.support.design.widget.FloatingActionButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"16dp\" android:clickable=\"true\" android:src=\"@mipmap/ic_heart_outline_white_24dp\" app:layout_anchor=\"@id/appbar\" app:layout_anchorGravity=\"bottom|right|end|center_vertical\" /&gt; 上面的布局代码在设置完其基本属性后，同时还配置了layout_anchor和layout_anchorGravity属性，表示固定在某个视图上，同时也确定了在视图上的位置。 SnackBar1Snackbar.make(fab, \"hey , it's SnackBar\", Snackbar.LENGTH_SHORT).setAction(\"Dismiss\", null).show(); SnackBar的用法与Toast很类似，但是它可以构造一个动作，监听动作后接受回调，执行自定义的事件。 总结目前对于MaterialDesign设计的实现，Google官方已经提供了足够多的第三方库了，而且使用起来相对灵活的自由，可以根据需求，适时使用一些新的特性，对于开发来说也减少了设计成本，能够提高开发效率和统一风格。已将代码上传至Github：https://github.com/hjw541988478/materialdeisgn_tutorial 参考 Material Design 中文版 Material Design 原版(需FQ) 直接拿来用!十大Material Design开源项目-CSDN.NET Android Support Design 中 CoordinatorLayout 与 Behaviors 初探 android：ToolBar详解 Android的材料设计兼容库（Design Support Library） Github库 MaterialDesignLibrary MaterialDesign","tags":[{"name":"MaterialDesign","slug":"MaterialDesign","permalink":"https://hjw541988478.github.io/tags/MaterialDesign/"}]},{"title":"RecyclerView下拉刷新上拉加载的封装","date":"2015-09-02T11:04:23.000Z","path":"2015/09/RecyclerView下拉刷新上拉加载的封装/","text":"初识RecyclerView A flexible view for providing a limited window into a large data set. 根据Google提供的官方说明，意思是为了解决大量数据子在有限的屏幕中显示的情况，RecyclerView就是应对这种情况而产生的。RecyclerView是supportV7包中最新的组件，有着非常高的可定制性和灵活性。使用时需要在build.gradle文件中配置：1compile &apos;com.android.support:recyclerview-v7:22.2.1&apos; 与ListView不同的是，RecyclerView不再负责Item布局绘制等方面的工作，转而拆分成不同的类去管理。作为未来ListView、GridView等替代的组件，虽然没有它们那么易用，所有的功能都需要自己重新实现，但正是因为这种特性使得RecyclerView更加Flexible。为了满足各种各样的需求，可能会使用到下面与RecyclerView相关紧密的类： RecyclerView.AdapterAdapter与在此前用到过的BaseAdapter很相似，准确的说是做了缓存优化的BaseAdapter，它负责为Item创建合适的视图同时为这些视图通过ViewHolder去绑定数据，以下3个方法是必须重写的：123public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType)public void onBindViewHolder(ViewHolder holder,int position)public int getItemCount() RecyclerView.ViewHolderViewHolder早前在ListView的使用时就推荐用来做性能优化，只不过在RecyclerView.Adapter中变成了必须实现的一部分。它保存着Item中所需要使用到的视图ID，方便在绑定数据的时候使用，使用的方法如下：123456public class MyViewHolder extends ViewHolder&#123; public MyViewHolder(View itemView)&#123; super(itemView); //... &#125;&#125; RecyclerView.LayoutManagerLayoutManager是用来确定RecyclerView的布局方式的，目前有三种可选，分别是： LinearLayoutManager线性布局，提供横向和纵向布局，实现ListView的选择 GridLayoutManager表格布局，初始化时需要提供列的数目，与GridView初始化时类似 StaggeredGridLayoutManager实现瀑布流效果必备，错乱的网格布局，提供横向和纵向布局对于实现上拉加载的时候，也需要使用到这个类，辅助性的获取一些数据，主要方法有：1234public int findFirstVisibleItemPosition() // 返回第一个可见Item在Adapter中的位置public int findFirstCompletelyVisibleItemPosition() // 返回第一个完全可见Item在Adapter中的位置public int findLastVisibleItemPosition() // 返回最后一个可见Item在Adapter中的位置public int findLastCompletelyVisibleItemPosition() // 返回最后一个完全可见Item在Adapter中的位置 RecyclerView.ItemDecorationItemDecoration类似ListtView中的Divider，让Item可以分隔开，但并不是必备的，在MaterialDesign设计中，推荐RecyclerView与CardView结合在一起使用，但是实际项目开发中，可以根据需要绘制ItemDecoration，实现不同风格的间隔线。实现自定义的ItemDecoration需要实现的方法有：12public void onDraw(Canvas c,RecyclerView parent,RecyclerView.State state) // 绘制视图public void getItemOffset(Rect outRect,int itemPosition,RecyclerView parent) // 在绘制视图时会调用此方法计算每一个Item的合适的尺寸 RecyclerView.ItemAnimator当Item的状态改变的时候，ItemAnimator会根据实际情况提供不同的动画效果，主要有 Item被删除时 Item被添加时 Item被移动时在未给RecyclerView设置ItemAnimator的时候，会使用默认的DefaultItemAnimator，以前我们都是使用notifyDataSetChanged方法去更新视图，现在我们可以使用带有动画效果的notifyItemInserted、notifyItemRemoved方法去更新视图。主要使用到的有：12public final void notifyItemInserted(int position) // 插入时的动画效果public final void notifyItemRemoved(int position) // 移除时的动画效果 框架封装思路下拉刷新下拉刷新采用supportv4包中原生的下拉组件SwipeRefreshlayout，直接在布局文件中作为容器包裹RecyclerView，然后在视图初始化的时候，对组件设置onRefershListener，在其回调方法onRefresh中拦截下拉刷新事件，使用自定义的刷新监听器，根据实际情况分发刷新事件。其中使下拉刷新事件控制的相关方法有setEnabled和setRerefreshing，分别的作用是是否允许下拉刷新以及下拉刷新UI是否运行。123456789101112131415161718/** * 允许下拉刷新 * * @param onRefreshListener 刷新回调接口 */private void enableRefresh(final OnRefreshListener onRefreshListener) &#123; swipeRefreshLayout.setEnabled(true); mOnRefreshListener = new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; if (onRefreshListener != null) onRefreshListener.onRefresh(); if (swipeRefreshLayout.isRefreshing()) swipeRefreshLayout.setRefreshing(false); &#125; &#125;; swipeRefreshLayout.setOnRefreshListener(mOnRefreshListener);&#125; 上面是对刷新事件的拦截和处理过程，若是允许下拉刷新并且下拉监听器不为空，则将事件向上级传递，执行业务代码，若是刷新事件执行完毕后，将刷新组件的状态自动设置为默认状态。12345678910 /** * 禁止下拉刷新 */private void disableRefresh() &#123; swipeRefreshLayout.setEnabled(false); if (manager != null) &#123; if (adapter != null &amp;&amp; adapter.getItemCount() != 0) manager.scrollToPosition(0); &#125;&#125; 若是不允许下拉刷新，直接将组件setEnabled为false便可，同时数据不为空的时候，讲焦点移动到第一个Item的位置。 上拉加载上拉加载的实现依赖于OnScrollListener，当滑动到最后一个Item的时候并且RecyclerView处于SCROLL_STATE_IDLE状态，便可以得知视图已经拉到底部，此时便触发自定义的上拉加载监听器并执行回调，同时在上拉加载完成后，若视图处于刷新状态，则将视图切换到默认状态。123456789101112131415161718192021222324252627282930/** * 允许上拉加载 * * @param onLoadMoreListener */private void enableLoadMore(final OnLoadMoreListener onLoadMoreListener) &#123; if (mOnLoadMoreListener != null) recyclerView.removeOnScrollListener(mOnLoadMoreListener); if (adapter != null) adapter.setIsNeedLoadMore(true); final LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager(); mOnLoadMoreListener = new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mLastVisibleItemPosition + 1 == adapter.getItemCount()) &#123; if (onLoadMoreListener != null) &#123; onLoadMoreListener.onLoadMore(); &#125; if (swipeRefreshLayout.isRefreshing()) swipeRefreshLayout.setRefreshing(false); &#125; &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); mLastVisibleItemPosition = layoutManager.findLastVisibleItemPosition(); &#125; &#125;; recyclerView.addOnScrollListener(mOnLoadMoreListener);&#125; 通过调用enableLoadMore方法，便完成了上拉加载的设置。若是上次的监听器不为空，则移除上一个OnScrollListener，同时设置新的监听器并在Adapter中切换LoadMoreView的状态，这样可以让最后一个Item的视图变成Loading状态。1234567891011 /** * 禁止上拉加载 */private void disableLoadMore() &#123; if (adapter != null) &#123; adapter.setIsNeedLoadMore(false); adapter.setFooterView(null, null); &#125; if (mOnLoadMoreListener != null) recyclerView.removeOnScrollListener(mOnLoadMoreListener);&#125; 若是调用禁止上拉加载方法，则直接移除上拉加载监听器，同时将Adapter中的FooterView置空以及上拉加载的标志位置false。 抽象适配器 对扩展开放，对修改关闭 由于需要对HeaderView以及FooterView处理，根据开闭原则，显然不能交给使用者自己去实现，因此我们需要封装完善，讲Adapter抽象，然后交由使用者继承已封装好的Adpter，使用者只用关心业务Item，从而更加简便灵活的使用。尽管我们不允许外部改变HeaderView和FooterView的实现逻辑，但是保留接口让使用者决定是否持有或者修改FooterView和HeaderView。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 /** * 设置底部视图 * * @param loadMoreView 加载中视图 * @param endFooterView 加载完成视图 */public void setFooterView(View loadMoreView, View endFooterView) &#123; this.loadMoreView = loadMoreView; this.endFooterView = endFooterView;&#125;/** * 设置头部视图 * * @param headerView 头部视图 */public void setHeaderView(View headerView) &#123; this.headerView = headerView;&#125;/** * 总视图个数 = 普通Item个数 + 头视图 + 尾视图 * * @return */@Overridepublic int getItemCount() &#123; return getAdapterItemCount() + (hasHeaderView() ? 1 : 0) + (isNeedLoadMore ? hasLoadMoreFooterView() ? 1 : 0 : hasEndFooterView() ? 1 : 0);&#125;/** * 根据不同的类型返回不同的ViewHolder * * @param parent * @param viewType * @return */@Overridepublic VH onCreateViewHolder(ViewGroup parent, int viewType) &#123; if (viewType == TYPE_LOADMORE_FOOTER) &#123; return (VH) new RecyclerView.ViewHolder(loadMoreView) &#123; &#125;; &#125; else if (viewType == TYPE_END_FOOTER) &#123; return (VH) new RecyclerView.ViewHolder(endFooterView) &#123; &#125;; &#125; else if (viewType == TYPE_HEADER) &#123; return (VH) new RecyclerView.ViewHolder(headerView) &#123; &#125;; &#125; else &#123; return onCreateViewHolder(parent); &#125;&#125; 对于需要根据实际情况获得的数据，我们使用抽象的方法让子类去实现，Item的数量，类型视图也是由此决定的。需要子类实现的相关方法：12345678910111213 /** * 普通Item的视图交由子类去处理 * * @param parent * @return */public abstract VH onCreateViewHolder(ViewGroup parent);/** * 普通Item的视图个数 * * @return */public abstract int getAdapterItemCount(); 使用方法和效果图在使用本框架的时候，使用者只需要在初始化View后，设置后下拉刷新、上拉加载监听器和适配器后，然后使用相关接口决定是否刷新和加载，对于整个UI效果是无需关心的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initViews(); // 再进行网络请求的时候，可设置Loading视图 mRecyclerView.showLoading(); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; bindData(); &#125; &#125;, 1500);&#125;/** * 初始化视图 */private void initViews() &#123; mToolBar = (Toolbar) findViewById(R.id.id_toolbar); if (mToolBar != null) setSupportActionBar(mToolBar); mRecyclerView = (HarvestRecyclerView) findViewById(R.id.id_harvest_recyclerview); manager = new LinearLayoutManager(this); mRecyclerView.setHasFixedSize(true); mRecyclerView.setLayoutManager(manager); mRecyclerView.setEmptyView(getResources().getDrawable(R.drawable.ic_results_empty), \"No data Here.\", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; adapter.data.add(\"onRefresh\" + refreshNum++); adapter.notifyDataSetChanged(); &#125; &#125;); onRefreshListener = new HarvestRecyclerView.OnRefreshListener() &#123; @Override public void onRefresh() &#123; if (refreshNum &gt;= 8) &#123; adapter.data.clear(); &#125; else adapter.data.add(0, \"onRefresh\" + refreshNum++); adapter.notifyDataSetChanged(); &#125; &#125;; onLoadMoreListener = new HarvestRecyclerView.OnLoadMoreListener() &#123; @Override public void onLoadMore() &#123; if (loadMoreNum &gt;= 8) &#123; mRecyclerView.setLoadMoreEnabled(false, null); &#125; else adapter.data.add(\"onLoadMore\" + loadMoreNum++); adapter.notifyDataSetChanged(); &#125; &#125;;&#125; 继承HarvestRecyclerViewAdpter，实现相关抽象的方法以及业务所需要的相关功能。123456789101112131415161718192021222324public List&lt;String&gt; data = new ArrayList&lt;&gt;();@Overridepublic TestHarvHolder onCreateViewHolder(ViewGroup parent) &#123; View root = LayoutInflater.from(parent.getContext()) .inflate(R.layout.item_view_card, parent, false); return new TestHarvHolder(root);&#125;@Overridepublic int getAdapterItemCount() &#123; return data.size();&#125;@Overridepublic void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; if (holder instanceof TestHarvHolder) &#123; ((TestHarvHolder) holder).mContentText.setText(data.get(position)); &#125;&#125;public class TestHarvHolder extends RecyclerView.ViewHolder &#123; TextView mContentText; public TestHarvHolder(View itemView) &#123; super(itemView); mContentText = (TextView) itemView.findViewById(R.id.id_text); &#125;&#125; 效果图如下面所示： demo refresh loadmore 小结对于下拉刷新和上拉加载框架的封装，主要是异常情况的处理，有无HeaderView，有无FooterView等，以及刷新和加载事件的拦截，以及对于相关设计模式的理解与运用。Github地址：https://github.com/hjw541988478/RefreshLoadMoreRecyclerView 参考 关于RecyclerView中Viewholder和View的缓存机制的探究 first-glance-androids-recyclerview [Android]使用RecyclerView替代ListView（二） 相关Github开源项目SuperRecyclerViewUltimateRecyclerView","tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://hjw541988478.github.io/tags/RecyclerView/"},{"name":"CustomView","slug":"CustomView","permalink":"https://hjw541988478.github.io/tags/CustomView/"}]},{"title":"Android传感器编程之摇一摇","date":"2015-08-26T11:54:01.000Z","path":"2015/08/Android传感器编程之摇一摇/","text":"思路摇一摇功能目前在很多Android的应用都有用到，大多数的目的是增强与用户的交互，同时也增加了趣味性。本质上来看，通过对加速传感器感知手机在X轴、Y轴和Z轴上加速度的变化，在三者的值达到设定的阈值的时候，便触发事件，进行业务上的逻辑调用，同时使用振动传感器产生振动事件。对于加速度传感器和振动传感器的使用，需要预先在配置文件中声明权限：12&lt;uses-permission android:name=&quot;android.hardware.sensor.accelerometer&quot; /&gt; # 加速度传感器&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt; # 振动传感器 同时在应用初始化的时候，获取SensorManager和Vibrator,之后才可以使用振动传感器和加速度传感器进行其他操作：12SensorManager mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE); Vibrator mVibrator = (Vibrator) getSystemService(Service.VIBRATOR_SERVICE); 摇晃监听器的实现 摇晃监听器:1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ShakeOffListener implements SensorEventListener &#123; private Context context; private Vibrator mVibrator; private SensorManager mSensorManager; private OnShakeListener mListener; interface OnShakeListener &#123; void onShake(); &#125; public void setShakeListener(OnShakeListener listener) &#123; this.mListener = listener; &#125; public ShakeOffListener(Context context) &#123; this.context = context; mVibrator = (Vibrator) context. getSystemService(Context.VIBRATOR_SERVICE); mSensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE); &#125; public void resume() &#123; mSensorManager.registerListener(this, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL); &#125; public void pause() &#123; mVibrator.vibrate(300); mSensorManager.unregisterListener(this); &#125; // 传感器值变化 @Override public void onSensorChanged(SensorEvent event) &#123; float x = event.values[0]; float y = event.values[1]; float z = event.values[2]; // 达到速度阀值，发出提示 if (Math.abs(x) &gt;= 19 || Math.abs(y) &gt;= 19 || Math.abs(z) &gt;= 19) &#123; if (mListener != null) mListener.onShake(); &#125; &#125; //传感器反应速度值的变化 @Override public void onAccuracyChanged(Sensor sensor, int accuracy) &#123; &#125;&#125; 在对ShakeOffListener进行初始化时，首先会对传感器进行初始化，同时也在内部定义了OnShakeListener接口，方便在宿主类对事件触发的监听，然后通过对SensorEventListener接口的实现，重新实现了onSensorChanged的回调方法，这里主要完成是对于摇晃功能阈值的设定以及触发条件满足后将事件传给宿主类完成其他操作，同时也定义了resume和pause方法，用来完成摇晃过程的恢复和暂停事件的处理，这样可以更加方便处理摇晃开始、摇晃中和摇晃结束整个流程。 摇晃监听器的使用及其效果 在Activity中进行使用123456789101112131415161718192021222324252627282930313233343536373839404142public class TestActivity extends Activity &#123; private ImageView shkePic; private ShakeOffListener mShakeOffListener; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); shkePic = (ImageView) findViewById(R.id.id_hand_shake_off); mShakeOffListener = new ShakeOffListener(this); mShakeOffListener.setShakeListener(new ShakeOffListener.OnShakeListener() &#123; @Override public void onShake() &#123; //TODO 处理业务请求 Logger.d(\"onShake~\"); Animation shakeAnim = AnimationUtils.loadAnimation(TestActivity.this, R.anim.shake); shakeAnim.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; mShakeOffListener.pause(); &#125; @Override public void onAnimationEnd(Animation animation) &#123; mShakeOffListener.resume(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); shkePic.startAnimation(shakeAnim); &#125; &#125;); mShakeOffListener.resume(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (mShakeOffListener != null)&#123; mShakeOffListener.pause(); mShakeOffListener = null; &#125; &#125;&#125; 在TestActivity中，通过在onCreate方法中，初始化ShakeOffListener同时实现了自定义的摇晃事件接口，巧妙的利用Animation的执行流程的回调方法，防止了摇晃事件的重复触发，摇晃事件的间隔取决于动画的时长，只需要在动画开始和结束使用pause和resume方法便可以暂停和恢复对摇晃事件的监听。最后在Activity被销毁时会回调的onDestroy方法中解除对摇晃监听器的注册，防了止内存泄露。用到的Animation摇晃动画资源文件shake.xml：12345&lt;translate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"500\" android:fromXDelta=\"0\" android:interpolator=\"@anim/cycle_7\" android:toXDelta=\"50\"/&gt; 以及使用到的插值器cycle_7.xml：12&lt;cycleInterpolator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:cycles=\"5.0\" /&gt; 还有在对传感器进行注册的时候，第一个参数是加速度传感器监听器实例，本例中是实现了SensorEventListener接口了的，第二个是加速度传感器实例，实现摇晃功能需要Sensor.TYPE_ACCELEROMETER类型，最后一个参数代表着传感器反应的速度类型，这个有如下几类： SENSOR_DELAY_NORMAL：默认的获取传感器数据的速度； SENSOR_DELAY_UI：若使用传感器更新UI，推荐使用； SENSOR_DELAY_GAME：如果利用传感器开发游戏，建议使用； SENSOR_DELAY_FASTEST：在特别灵敏的处理下推荐使用，但该模式可能造成手机电力大量消耗；对于摇晃功能的实现，也只需要使用默认的即SENSOR_DELAY_NORMAL便可以满足监听传感器加速度变化的需求：123mSensorManager.registerListener(this, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL); 摇晃前截图 摇晃成功截图 总结摇一摇功能用到的知识点有传感器、动画以及利用动画的执行周期巧妙的实现业务需求，但不得不说的是，对于合理设定摇晃阈值才是整个摇晃功能实现的关键，目前这个版本设定的值是19,对于大多数手机是能够实现功能的，但是相信有更好方法利用X、Y、Z轴加速度的值去处理这个阈值，这个是待完善的地方。","tags":[{"name":"Sensor","slug":"Sensor","permalink":"https://hjw541988478.github.io/tags/Sensor/"},{"name":"Vibrator","slug":"Vibrator","permalink":"https://hjw541988478.github.io/tags/Vibrator/"}]},{"title":"Android应用自动检测更新机制的实现","date":"2015-08-25T12:42:39.000Z","path":"2015/08/Android应用自动检测更新机制的实现/","text":"需求在安卓应用程序中，随着业务的升级或者BUG的修复，往往需要进行版本的迭代与更新。在更新的过程中，选择合理的更新方式显得尤为重要。但大多数思路都是一样，从服务端获取版本号比对当前包的版本号，如果大于当前版本号则提示用户升级，而对于某些需要强制更新的版本号，则不允许用户取消版本的升级，必须强制更新。整个流程大概如下图所示： 更新流程图 可以看到，整个流程的关键在于对VerisonCode版本号的大小比较，VersionCode标识了同一应用的不同版本号，对于修改版本号后打包的安装包便是最新版本的安装包。在AndroidStudio中，VersionCode的配置一般在应用模块的*.build文件中，如下：1234567defaultConfig &#123; applicationId &quot;com.test.app&quot; minSdkVersion 9 targetSdkVersion 22 versionCode 6 #这里便是对版本号的设置 versionName &quot;2.0.0&quot;&#125; 对于本地版本号的获取，使用1curCode = mActivity.getPackageManager().getPackageInfo(mActivity.getPackageName(), 0).versionCode; 便可以获取，然后直接去比较从服务端获取下来的版本号，便可以知晓应用是否需要更新。 分析使用Service组件去完成整个功能，鉴于它有着不可见，运行在后台的特性，并使用本地服务，直接startService或者stopService便可以完成服务的启动和停止，整个流程分为3个部分，服务端获取最新版本信息-&gt;下载最新版本，并实时更新UI-&gt;下载完成，覆盖安装。 服务端获取最新版本通过服务端提供的API或者第三方SDK提供的API实现，在自定义的Application中，应用启动时便异步发起检测更新的请求，这样应用每次启动都能知晓是否需要更新。对于异步请求，可以使用OkHttp、AsyncHttp等知名的第三方库，同时也可以使用AsyncTask类去实现，当然，视项目的网络请求框架而定，直接复用网络框架中的请求即可。 下载最新版本，更新进度条在获取到服务端返回的结果中，解析最新版本安装包的下载地址URL链接，同时使用NotificationManager去唤起一个新的Notification，对于有进度条需求的，便需要使用自定义的UI，在Notification中获取到视图的ID和引用，这样便可以适时的去更新UI。对于UI更新机制，推荐使用主UI线程的Handler去维护管理消息队列，在下载线程中只需要使用sendMessage方法将相关数据带过去，让Handler去实现具体的UI更新内容。需要注意的时，对于更新频率的控制，在复用Notification时候，更新频率过高的时候，会占用大量内存，可能会引起UI线程的阻塞，从而影响用户体验。 下载完成，覆盖安装如何监听下载完成的事件呢?其实可以有两种方式实现，即BroadcastReceiver或者EventBus，但无论哪种方式，下载完成的关键便是网络数据已经完全请求完成，也就是下载进度达到了100%。而覆盖安装的关键在于Intent的Flags和DataAndType的设置，根据之前设定好的下载文件的路径，并可以发起调用覆盖安装的请求。 实现 UpdateService实现12345678910111213141516171819202122232425262728293031public class UpdateService extends Service &#123; // 安装包下载地址 private String url = null; // 新的安装包本地存储路径 private String filePath = null; // 通知管理器 private NotificationManager updateNotificationManager = null; // 通知 private Notification updateNotification = null; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; // 获取传值 url = intent.getStringExtra(\"url\"); if (url != null) &#123; String fileName = url.substring(url.lastIndexOf(\"/\")); File uDir = new File(Environment.getExternalStorageDirectory() + \"/test/download/\"); if (!uDir.exists() || !uDir.isDirectory()) &#123; uDir.mkdirs(); &#125; // 本地目录存储路径 filePath = uDir + fileName; // 使用AsyncTask执行下载请求 new DownloadAsyncTask().execute(url); &#125; return super.onStartCommand(intent, 0, 0); &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125;&#125; UpdateService先会把本地存储路径和Notification初始化，然后使用AsyncTask进行新安装包的下载和NotificationUI的更新工作。记得在使用Service前进行动态注册或者在AndroidManifest.xml文件中配置好Service节点。 DownloadAsyncTask实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293class DownloadAsyncTask extends AsyncTask&lt;String, Integer, Void&gt; &#123; //构造Notification @Override protected void onPreExecute() &#123; updateNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); updateNotification = new Notification(); updateNotification.icon = R.drawable.ic_launcher; updateNotification.contentView = new RemoteViews(getPackageName(), R.layout.view_notification_download); updateNotification.contentView.setProgressBar(R.id.notify_progress, 100, 0, false); updateNotification.contentView.setTextViewText(R.id.notify_title, \"已下载:0%\"); updateNotification.contentIntent = PendingIntent.getActivity(getApplicationContext(), 0, new Intent(), 0); updateNotification.flags = Notification.FLAG_AUTO_CANCEL; updateNotificationManager.notify(101, updateNotification); &#125; @Override protected Void doInBackground(String... params) &#123; // 下载百分比 int downPercentage = 0; // 上次缓存文件大小 int cachedSize = 0; // 临时文件大小 long tmpTotalSize = 0; // 待下载文件总大小 int totalSize = 0; HttpURLConnection httpUrlConn = null; InputStream httpInputStream = null; FileOutputStream fileOutputStream = null; try &#123; URL url = new URL(params[0]); httpUrlConn = (HttpURLConnection) url.openConnection(); if (cachedSize &gt; 0) &#123; // 方便以后实现断点续传 httpUrlConn.setRequestProperty(\"RANGE\", \"bytes=\" + cachedSize + \"-\"); &#125; httpUrlConn.setConnectTimeout(NetworkConfig.CONNECT_TIMEOUT); httpUrlConn.setReadTimeout(NetworkConfig.CONNECT_TIMEOUT); // 获取文件总大小 totalSize = httpUrlConn.getContentLength(); if (httpUrlConn.getResponseCode() == 200) &#123; httpInputStream = httpUrlConn.getInputStream(); fileOutputStream = new FileOutputStream(new File(filePath)); byte buffer[] = new byte[4096]; int bufferSize = 0; while ((bufferSize = httpInputStream.read(buffer)) &gt; 0) &#123; fileOutputStream.write(buffer, 0, bufferSize); tmpTotalSize += bufferSize; int tmpDownPercentage = (int) (tmpTotalSize * 100 / totalSize); if (tmpDownPercentage - downPercentage &gt; 5) &#123; downPercentage += 5; publishProgress(tmpDownPercentage); &#125; &#125; // 下载结束 publishProgress(100); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); publishProgress(-1); &#125; finally &#123; try &#123; if (httpUrlConn != null) httpUrlConn.disconnect(); if (httpInputStream != null) httpInputStream.close(); if (fileOutputStream != null) fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); publishProgress(-1); &#125; &#125; return null; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; if (values[0] != -1) &#123; updateNotification.contentView.setTextViewText(R.id.notify_title, values[0] &gt;= 100 ? \"已完成下载\" : \"已下载:\" + values[0] + \"%\"); updateNotification.contentView.setProgressBar(R.id.notify_progress, 100, values[0] &gt;= 100 ? 100 : values[0], false); &#125; else &#123; updateNotification.contentView.setTextViewText(R.id.notify_title, \"下载失败!\"); &#125; updateNotification.flags = Notification.FLAG_AUTO_CANCEL; updateNotificationManager.notify(101, updateNotification); &#125; @Override protected void onPostExecute(Void result) &#123; Intent installIntent = new Intent(Intent.ACTION_VIEW); installIntent.addFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED | Intent.FLAG_ACTIVITY_NEW_TASK); installIntent.setDataAndType(Uri.fromFile(new File(filePath)), \"application/vnd.android.package-archive\"); startActivity(installIntent); stopSelf(); &#125; &#125; DownloadAsyncTask充分利用了AsyncTask的特点，分别在onPreExecute中进行了Notification的构造以及唤醒工作，在doInBackground中进行着网络数据下载工作，然后在数据不断缓存的过程中，当数据缓存的比例大于5%时，则调用publishProgress方法，更新Notification中的进度条，这样做的目的是，在频繁更新Notification并唤醒的过程中，会阻塞UI线程导致ANR，因此一般在进度变化累积到5%的时候再去更新UI，保证应用的流畅性。具体涉及到UI的更新工作放在onProgressUpdate方法中，包括进度和文字提示的更新，其中包含了更新失败的情况，同样也需要提示。最后在onPostExecute方法中进行下载文件的获取和安装，并弹出安装界面指导安装。 下载中状态 下载完成状态 安装状态 总结Andriod应用的更新机制主要使用到的知识点有NotificationManager、Notification、ProgressBar、Service、AsyncTask。通过对上面主要的分析与实现，可以看到涉及到的点还是比较多的，但大多都是基础的知识点，以后在实现复杂功能的时候，也应该通过对业务流程的分析、知识点的理解，综合运用，达到目的。","tags":[{"name":"Service","slug":"Service","permalink":"https://hjw541988478.github.io/tags/Service/"},{"name":"Handler","slug":"Handler","permalink":"https://hjw541988478.github.io/tags/Handler/"},{"name":"Notification","slug":"Notification","permalink":"https://hjw541988478.github.io/tags/Notification/"}]},{"title":"PropertyAnimation使用总结","date":"2015-08-24T11:27:14.000Z","path":"2015/08/PropertyAnimation使用总结/","text":"ObjectAnimator 淡入效果123ObjectAnimator.ofFloat(tv, \"alpha\", 0.0f, 1.0f) .setDuration(500) .start(); ofFloat对应着三个参数值，分别是目标View，动画属性名Property，以及属性值，一个则为终点值，两个对应着起点和终点值，多个则为起点值，将会调用的值和终点值。与ofFloat类似的还有ofInt、ofObject，这些都是用来设置动画动作的元素。 同时缩小和淡出效果123456789101112131415ObjectAnimator anim = ObjectAnimator .ofFloat(view, \"hjw\", 1.0F, 0.0F) .setDuration(500); anim.start(); anim.addUpdateListener(new AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float cVal = (Float) animation.getAnimatedValue(); view.setAlpha(cVal); view.setScaleX(cVal); view.setScaleY(cVal); &#125; &#125;); 可以看到，使用这种非常规的方式也可以达到预期的效果，只需要在使用了未知的Property，然后再回调方法中按照时间插值和持续时间计算值，我们自己手动调用实现各个属性的值。 ValueAnimator 抛物线运动效果12345678910111213141516171819202122ValueAnimator animator = new ValueAnimator(); animator.setDuration(3000); animator.setObjectValues(new PointF(0, 0)); animator.setInterpolator(new LinearInterpolator()); animator.setEvaluator(new TypeEvaluator&lt;PointF&gt;() &#123; @Override public PointF evaluate(float fraction, PointF startValue, PointF endValue) &#123; PointF pointF = new PointF(); pointF.x = 100 * fraction; pointF.y = 0.5f * (fraction * 100) * (fraction * 100); return pointF; &#125; &#125;); animator.start(); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; PointF point = (PointF) animation.getAnimatedValue(); circleView.setX(point.x); circleView.setY(point.y); &#125; &#125;); 可以看到与ObjectAnimator相比，并没有指定Property的操作，也就是说，ValueAnimator只关心值的变化，但是带来的变化是只需要根据计算好的动画值，重写TypeEvaluator类，在evaluate回调方法中返回任何想要调用的值，类似上面那种非常规的方式，也无需使用到反射。 AnimationSet 淡入淡出效果123456789ObjectAnimator alphaOutAnim = new ObjectAnimator(); alphaOutAnim.ofFloat(tv, \"alpha\", 0f, 1f); ObjectAnimator alphaInAnim = new ObjectAnimator(); alphaInAnim.ofFloat(tv, \"alpha\", 1f, 0f); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.setInterpolator(new LinearInterpolator()); animatorSet.setDuration(2000); animatorSet.playSequentially(alphaOutAnim, alphaInAnim); animatorSet.start(); AnimationSet主要是用来对多动画的执行顺序进行控制，包括playTogether同时执行、playSequentially顺序执行和after with before等方法控制。 监听动画变化事件 监听动画事件123456789101112131415161718192021ObjectAnimator anim = ObjectAnimator.ofFloat(tv, \"alpha\", 0.5f); anim.addListener(new AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; // 动画开始执行 &#125; @Override public void onAnimationRepeat(Animator animation) &#123; // 动画重复执行 &#125; @Override public void onAnimationEnd(Animator animation) &#123; // 动画执行结束 &#125; @Override public void onAnimationCancel(Animator animation) &#123; // 取消动画执行 &#125; &#125;); anim.start(); 对于常用的开始、重复、结束和取消动画事件都能够被监听到，只需要在回调方法中实现所需要实现的业务即可。 XML创建PropertyAnimation XML方式描述淡出效果1234567&lt;objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"1000\" android:propertyName=\"alpha\" android:valueFrom=\"0.0\" android:valueTo=\"1.0\" android:valueType=\"floatType\" &gt;&lt;/objectAnimator&gt; 在res/animator目录下创建alpha.xml文件，然后进行调用：123Animator anim = AnimatorInflater.loadAnimator(this, R.animator.alpha); anim.setTarget(mMv); anim.start() 如果需要多个动画去执行，只需要在XML文件中增加Set节点：123456789101112131415&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:ordering=\"together\" &gt; &lt;objectAnimator android:duration=\"1000\" android:propertyName=\"scaleX\" android:valueFrom=\"1\" android:valueTo=\"0.5\" &gt; &lt;/objectAnimator&gt; &lt;objectAnimator android:duration=\"1000\" android:propertyName=\"scaleY\" android:valueFrom=\"1\" android:valueTo=\"0.5\" &gt; &lt;/objectAnimator&gt;&lt;/set&gt; 通过改变ordering属性的值去控制多个动画之间的执行顺序。 Layout Animations(布局动画)改变ViewGroup的子View移除或者添加的动画效果12345678910LayoutTransition transition = new LayoutTransition(); transition.setAnimator(LayoutTransition.CHANGE_APPEARING, transition.getAnimator(LayoutTransition.CHANGE_APPEARING)); transition.setAnimator(LayoutTransition.APPEARING, null); transition.setAnimator(LayoutTransition.DISAPPEARING, null); transition.setAnimator(LayoutTransition.CHANGE_DISAPPEARING, null); mLayout.setLayoutTransition(transition); 需要注意的四种类型： LayoutTransition.APPEARING：当一个View在ViewGroup中出现时，对此View设置的动画； LayoutTransition.CHANGE_APPEARING： 当一个View在ViewGroup中出现时，此View对其他View位置造成的效果，对其他View设置的动画； LayoutTransition.DISAPPEARING：当一个View在ViewGroup中消失时，对此View设置的动画； LayoutTransition.CHANGE_DISAPPEARING：当一个View在ViewGroup中消失时，此View对其他View位置造成效果，对其他View设置的动画； LayoutTransition.CHANGE：不是由于View出现或消失造成对其他View位置造成效果，对其他View设置的动画。","tags":[{"name":"Animation","slug":"Animation","permalink":"https://hjw541988478.github.io/tags/Animation/"}]},{"title":"多行文本的可展开折叠的TextView实现","date":"2015-08-23T11:28:19.000Z","path":"2015/08/多行文本可折叠展开TextView实现/","text":"需求在实现商家评论区的需求时，对于多行评论的显示，采用的是使用maxLines属性去限定显示的行数，同时使用android:ellipsize=end在限定行数的末尾显示...，这种方式可以很好的避免评论文字过多显示过长的情况。但是对于有价值的评论，有必要显示所有评论文字，采用展开折叠的交互，能够更加的灵活地去应对长文字的多行显示，给用户给好的体验。 思路首先，继承LinearLayout，并对文本和标记组件进行一层包装，通过对折叠状态下的行数、展开折叠的动画时长、展开和折叠状态的视图控制，进行可自定义的属性封装。然后对父类的onClick方法进行重写，用户在对组件点击的时候，文本会自动的展开或折叠。然而当文本正在处于折叠或展开过程的动画中时，应该重写onInterceptTouchEvent方法拦截所有的点击事件，防止出现异常。其次，在整个流程中我们需要了解到文本的真实高度，用来在初始化的时候去判断是否需要进入折叠模式，因此需要重写onMeasure方法，如果组件不需要重新绘制或者组件的可见性为View.GONE，则直接使用父类的onMeasure方法。然后，但是如果组件需要重新绘制，便会初始化组件的状态，并对组件进行测量，判断真实文本的行数，如果小于设置的最大显示行数，则直接显示，否则按最大显示行数显示文本并让展开状态的View可见，保存当前折叠状态下显示的高度。最后，对于视图复用的问题，一般情况下，视图被滑出了屏幕看不见后，这个视图数据便消失了，重新让视图进入屏幕中时，视图会重新初始化，而对于那些展开或者折叠状态的视图也会默认变为折叠模式。因此需要一个标记量去使用额外的标记决定视图显示的位置和状态，这里使用到的是SparseBooleanArray，实质上基于稀疏矩阵和折半查找的HashMap&lt;Integer,Boolean&gt;的优化版本，key用来记录位置，value用来记录状态。 实现 通过在attrs.xml中进行属性的自定义，并通过下面的代码去获取在布局文件中配置的自定义的属性值，包括了最多显示行数，展开、折叠资源等。 12345678910111213141516171819202122 private void init(AttributeSet attrs) &#123; TypedArray typedArray = getContext().obtainStyledAttributes(attrs, R.styleable.ExpTextView); //最多行数 mMaxLines = typedArray.getInt(R.styleable.Exp_maxCollapsedLines, MAX_COLLAPSED_LINES); //动画时长 mAnimDuration = typedArray.getInt(R.styleable.ExpTextView_animDuration, DEFAULT_ANIM_DURATION); // 动画透明度渐变初始值 mAnimAlphaStart = typedArray.getFloat(R.styleable.ExpTextView_animAlphaStart, DEFAULT_ANIM_ALPHA_START); mExpandDrawable = typedArray.getDrawable(R.styleable.ExpTextView_expandDrawable); mCollapseDrawable = typedArray.getDrawable(R.styleable.ExpTextView_collapseDrawable); if (mExpandDrawable == null) &#123; mExpandDrawable = getDrawable(getContext(), ); &#125; if (mCollapseDrawable == null) &#123; mCollapseDrawable = getDrawable(getContext(), R.drawable.ic_mer_detail_collapse); &#125; typedArray.recycle(); //只能是垂直布局 setOrientation(LinearLayout.VERTICAL); //默认是不显示的 setVisibility(GONE);&#125; 重写onMeasure方法，目的是判断当前文本的状态和初始化在不同状态下必要的数据。 1234567891011121314151617181920212223242526272829303132333435363738@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 如果没有改变直接返回当前状态 if (!mRelayout || getVisibility() == View.GONE) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); return; &#125; mRelayout = false; // 初始化默认状态 mButton.setVisibility(View.GONE); mTv.setMaxLines(Integer.MAX_VALUE); // 测量控件尺寸 super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 文本显示的行数小于限定值，直接返回 if (mTv.getLineCount() &lt;= mMaxCollapsedLines) &#123; return; &#125; // 获得文本的真实高度 mTextHeightWithMaxLines = getRealTextViewHeight(mTv); // 处于折叠模式中，只显示限定值的行数 if (mCollapsed) &#123; mTv.setMaxLines(mMaxCollapsedLines); &#125; mButton.setVisibility(View.VISIBLE); // 重新测量控件尺寸 super.onMeasure(widthMeasureSpec, heightMeasureSpec); if (mCollapsed) &#123; // 获得文本与容器的外间距值 mTv.post(new Runnable() &#123; @Override public void run() &#123; mMarginBetweenTxtAndBottom = getHeight() - mTv.getHeight(); &#125; &#125;); // 保存当前测量值的高度 mCollapsedHeight = getMeasuredHeight(); &#125;&#125; 获取TextView真实高度的方法。 12345private static int getRealTextViewHeight(TextView textView) &#123; int textHeight = textView.getLayout().getLineTop(textView.getLineCount()); int padding = textView.getCompoundPaddingTop() + textView.getCompoundPaddingBottom(); return textHeight + padding; &#125; 重写onClick方法，处理点击事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic void onClick(View view) &#123; if (mButton.getVisibility() != View.VISIBLE) &#123; return; &#125; // 折叠模式状态值与上次相反 mCollapsed = !mCollapsed; mButton.setImageDrawable(mCollapsed ? mExpandDrawable : mCollapseDrawable); if (mCollapsedStatus != null) &#123; // 存放状态值 mCollapsedStatus.put(mPosition, mCollapsed); &#125; // 动画播放标记置true mAnimating = true; Animation animation; if (mCollapsed) &#123; animation = new ExpandCollapseAnimation(this, getHeight(), mCollapsedHeight); &#125; else &#123; animation = new ExpandCollapseAnimation(this, getHeight(), getHeight() + mTextHeightWithMaxLines - mTv.getHeight()); &#125; // 保持动画后的状态 animation.setFillAfter(true); animation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; applyAlphaAnimation(mTv, mAnimAlphaStart); &#125; @Override public void onAnimationEnd(Animation animation) &#123; // 防止多次调用applyTransformation() clearAnimation(); // 动画播放标记置false mAnimating = false; // 如果外部有设置监听事件，则触发监听事件 if (mListener != null) &#123; mListener.onExpandStateChanged(mTv, !mCollapsed); &#125; &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); clearAnimation(); startAnimation(animation);&#125; 展开折叠动画类。 1234567891011121314151617181920212223242526272829class ExpandCollapseAnimation extends Animation &#123; private final View mTargetView; private final int mStartHeight; private final int mEndHeight; public ExpandCollapseAnimation(View view, int startHeight, int endHeight) &#123; mTargetView = view; mStartHeight = startHeight; mEndHeight = endHeight; setDuration(mAnimationDuration); &#125; @Override protected void applyTransformation(float interpolatedTime, Transformation t) &#123; final int newHeight = (int) ((mEndHeight - mStartHeight) * interpolatedTime + mStartHeight); mTv.setMaxHeight(newHeight - mMarginBetweenTxtAndBottom); if (Float.compare(mAnimAlphaStart, 1.0f) != 0) &#123; applyAlphaAnimation(mTv, mAnimAlphaStart + interpolatedTime * (1.0f - mAnimAlphaStart)); &#125; mTargetView.getLayoutParams().height = newHeight; mTargetView.requestLayout(); &#125; @Override public void initialize(int width, int height, int parentWidth, int parentHeight) &#123; super.initialize(width, height, parentWidth, parentHeight); &#125; @Override public boolean willChangeBounds() &#123; return true; &#125;&#125; 其他必要重写的方法。 12345678910@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; // 如果动画正在播放就不分发触摸时间给子View return mAnimating;&#125;@Overrideprotected void onFinishInflate() &#123; // 结束加载时初始化控件ID findViews();&#125; 效果 多行文本展开状态效果图 多行文本收缩状态效果图","tags":[{"name":"CustomView","slug":"CustomView","permalink":"https://hjw541988478.github.io/tags/CustomView/"}]}]