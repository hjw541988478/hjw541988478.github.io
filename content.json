[{"title":"RecyclerView下拉刷新上拉加载的封装","date":"2015-09-02T11:04:23.000Z","path":"2015/09/02/RecyclerView下拉刷新上拉加载的封装/","text":"初识RecyclerView A flexible view for providing a limited window into a large data set. 根据Google提供的官方说明，意思是为了解决大量数据子在有限的屏幕中显示的情况，RecyclerView就是应对这种情况而产生的。RecyclerView是supportV7包中最新的组件，有着非常高的可定制性和灵活性。使用时需要在build.gradle文件中配置：1compile &apos;com.android.support:recyclerview-v7:22.2.1&apos; 与ListView不同的是，RecyclerView不再负责Item布局绘制等方面的工作，转而拆分成不同的类去管理。作为未来ListView、GridView等替代的组件，虽然没有它们那么易用，所有的功能都需要自己重新实现，但正是因为这种特性使得RecyclerView更加Flexible。为了满足各种各样的需求，可能会使用到下面与RecyclerView相关紧密的类： RecyclerView.AdapterAdapter与在此前用到过的BaseAdapter很相似，准确的说是做了缓存优化的BaseAdapter，它负责为Item创建合适的视图同时为这些视图通过ViewHolder去绑定数据，以下3个方法是必须重写的：123public ViewHolder onCreateViewHolder(ViewGroup parent,int viewType)public void onBindViewHolder(ViewHolder holder,int position)public int getItemCount() RecyclerView.ViewHolderViewHolder早前在ListView的使用时就推荐用来做性能优化，只不过在RecyclerView.Adapter中变成了必须实现的一部分。它保存着Item中所需要使用到的视图ID，方便在绑定数据的时候使用，使用的方法如下：123456public class MyViewHolder extends ViewHolder&#123; public MyViewHolder(View itemView)&#123; super(itemView); //... &#125;&#125; RecyclerView.LayoutManagerLayoutManager是用来确定RecyclerView的布局方式的，目前有三种可选，分别是： LinearLayoutManager线性布局，提供横向和纵向布局，实现ListView的选择 GridLayoutManager表格布局，初始化时需要提供列的数目，与GridView初始化时类似 StaggeredGridLayoutManager实现瀑布流效果必备，错乱的网格布局，提供横向和纵向布局对于实现上拉加载的时候，也需要使用到这个类，辅助性的获取一些数据，主要方法有：1234public int findFirstVisibleItemPosition() // 返回第一个可见Item在Adapter中的位置public int findFirstCompletelyVisibleItemPosition() // 返回第一个完全可见Item在Adapter中的位置public int findLastVisibleItemPosition() // 返回最后一个可见Item在Adapter中的位置public int findLastCompletelyVisibleItemPosition() // 返回最后一个完全可见Item在Adapter中的位置 RecyclerView.ItemDecorationItemDecoration类似ListtView中的Divider，让Item可以分隔开，但并不是必备的，在MaterialDesign设计中，推荐RecyclerView与CardView结合在一起使用，但是实际项目开发中，可以根据需要绘制ItemDecoration，实现不同风格的间隔线。实现自定义的ItemDecoration需要实现的方法有：12public void onDraw(Canvas c,RecyclerView parent,RecyclerView.State state) // 绘制视图public void getItemOffset(Rect outRect,int itemPosition,RecyclerView parent) // 在绘制视图时会调用此方法计算每一个Item的合适的尺寸 RecyclerView.ItemAnimator当Item的状态改变的时候，ItemAnimator会根据实际情况提供不同的动画效果，主要有 Item被删除时 Item被添加时 Item被移动时在未给RecyclerView设置ItemAnimator的时候，会使用默认的DefaultItemAnimator，以前我们都是使用notifyDataSetChanged方法去更新视图，现在我们可以使用带有动画效果的notifyItemInserted、notifyItemRemoved方法去更新视图。主要使用到的有：12public final void notifyItemInserted(int position) // 插入时的动画效果public final void notifyItemRemoved(int position) // 移除时的动画效果 框架封装思路下拉刷新下拉刷新采用supportv4包中原生的下拉组件SwipeRefreshlayout，直接在布局文件中作为容器包裹RecyclerView，然后在视图初始化的时候，对组件设置onRefershListener，在其回调方法onRefresh中拦截下拉刷新事件，使用自定义的刷新监听器，根据实际情况分发刷新事件。其中使下拉刷新事件控制的相关方法有setEnabled和setRerefreshing，分别的作用是是否允许下拉刷新以及下拉刷新UI是否运行。123456789101112131415161718/** * 允许下拉刷新 * * @param onRefreshListener 刷新回调接口 */private void enableRefresh(final OnRefreshListener onRefreshListener) &#123; swipeRefreshLayout.setEnabled(true); mOnRefreshListener = new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; if (onRefreshListener != null) onRefreshListener.onRefresh(); if (swipeRefreshLayout.isRefreshing()) swipeRefreshLayout.setRefreshing(false); &#125; &#125;; swipeRefreshLayout.setOnRefreshListener(mOnRefreshListener);&#125; 上面是对刷新事件的拦截和处理过程，若是允许下拉刷新并且下拉监听器不为空，则将事件向上级传递，执行业务代码，若是刷新事件执行完毕后，将刷新组件的状态自动设置为默认状态。12345678910 /** * 禁止下拉刷新 */private void disableRefresh() &#123; swipeRefreshLayout.setEnabled(false); if (manager != null) &#123; if (adapter != null &amp;&amp; adapter.getItemCount() != 0) manager.scrollToPosition(0); &#125;&#125; 若是不允许下拉刷新，直接将组件setEnabled为false便可，同时数据不为空的时候，讲焦点移动到第一个Item的位置。 上拉加载上拉加载的实现依赖于OnScrollListener，当滑动到最后一个Item的时候并且RecyclerView处于SCROLL_STATE_IDLE状态，便可以得知视图已经拉到底部，此时便触发自定义的上拉加载监听器并执行回调，同时在上拉加载完成后，若视图处于刷新状态，则将视图切换到默认状态。123456789101112131415161718192021222324252627282930/** * 允许上拉加载 * * @param onLoadMoreListener */private void enableLoadMore(final OnLoadMoreListener onLoadMoreListener) &#123; if (mOnLoadMoreListener != null) recyclerView.removeOnScrollListener(mOnLoadMoreListener); if (adapter != null) adapter.setIsNeedLoadMore(true); final LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager(); mOnLoadMoreListener = new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mLastVisibleItemPosition + 1 == adapter.getItemCount()) &#123; if (onLoadMoreListener != null) &#123; onLoadMoreListener.onLoadMore(); &#125; if (swipeRefreshLayout.isRefreshing()) swipeRefreshLayout.setRefreshing(false); &#125; &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); mLastVisibleItemPosition = layoutManager.findLastVisibleItemPosition(); &#125; &#125;; recyclerView.addOnScrollListener(mOnLoadMoreListener);&#125; 通过调用enableLoadMore方法，便完成了上拉加载的设置。若是上次的监听器不为空，则移除上一个OnScrollListener，同时设置新的监听器并在Adapter中切换LoadMoreView的状态，这样可以让最后一个Item的视图变成Loading状态。1234567891011 /** * 禁止上拉加载 */private void disableLoadMore() &#123; if (adapter != null) &#123; adapter.setIsNeedLoadMore(false); adapter.setFooterView(null, null); &#125; if (mOnLoadMoreListener != null) recyclerView.removeOnScrollListener(mOnLoadMoreListener);&#125; 若是调用禁止上拉加载方法，则直接移除上拉加载监听器，同时将Adapter中的FooterView置空以及上拉加载的标志位置false。 抽象适配器 对扩展开放，对修改关闭 由于需要对HeaderView以及FooterView处理，根据开闭原则，显然不能交给使用者自己去实现，因此我们需要封装完善，讲Adapter抽象，然后交由使用者继承已封装好的Adpter，使用者只用关心业务Item，从而更加简便灵活的使用。尽管我们不允许外部改变HeaderView和FooterView的实现逻辑，但是保留接口让使用者决定是否持有或者修改FooterView和HeaderView。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 /** * 设置底部视图 * * @param loadMoreView 加载中视图 * @param endFooterView 加载完成视图 */public void setFooterView(View loadMoreView, View endFooterView) &#123; this.loadMoreView = loadMoreView; this.endFooterView = endFooterView;&#125;/** * 设置头部视图 * * @param headerView 头部视图 */public void setHeaderView(View headerView) &#123; this.headerView = headerView;&#125;/** * 总视图个数 = 普通Item个数 + 头视图 + 尾视图 * * @return */@Overridepublic int getItemCount() &#123; return getAdapterItemCount() + (hasHeaderView() ? 1 : 0) + (isNeedLoadMore ? hasLoadMoreFooterView() ? 1 : 0 : hasEndFooterView() ? 1 : 0);&#125;/** * 根据不同的类型返回不同的ViewHolder * * @param parent * @param viewType * @return */@Overridepublic VH onCreateViewHolder(ViewGroup parent, int viewType) &#123; if (viewType == TYPE_LOADMORE_FOOTER) &#123; return (VH) new RecyclerView.ViewHolder(loadMoreView) &#123; &#125;; &#125; else if (viewType == TYPE_END_FOOTER) &#123; return (VH) new RecyclerView.ViewHolder(endFooterView) &#123; &#125;; &#125; else if (viewType == TYPE_HEADER) &#123; return (VH) new RecyclerView.ViewHolder(headerView) &#123; &#125;; &#125; else &#123; return onCreateViewHolder(parent); &#125;&#125; 对于需要根据实际情况获得的数据，我们使用抽象的方法让子类去实现，Item的数量，类型视图也是由此决定的。需要子类实现的相关方法：12345678910111213 /** * 普通Item的视图交由子类去处理 * * @param parent * @return */public abstract VH onCreateViewHolder(ViewGroup parent);/** * 普通Item的视图个数 * * @return */public abstract int getAdapterItemCount(); 使用方法和效果图在使用本框架的时候，使用者只需要在初始化View后，设置后下拉刷新、上拉加载监听器和适配器后，然后使用相关接口决定是否刷新和加载，对于整个UI效果是无需关心的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initViews(); // 再进行网络请求的时候，可设置Loading视图 mRecyclerView.showLoading(); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; bindData(); &#125; &#125;, 1500);&#125;/** * 初始化视图 */private void initViews() &#123; mToolBar = (Toolbar) findViewById(R.id.id_toolbar); if (mToolBar != null) setSupportActionBar(mToolBar); mRecyclerView = (HarvestRecyclerView) findViewById(R.id.id_harvest_recyclerview); manager = new LinearLayoutManager(this); mRecyclerView.setHasFixedSize(true); mRecyclerView.setLayoutManager(manager); mRecyclerView.setEmptyView(getResources().getDrawable(R.drawable.ic_results_empty), \"No data Here.\", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; adapter.data.add(\"onRefresh\" + refreshNum++); adapter.notifyDataSetChanged(); &#125; &#125;); onRefreshListener = new HarvestRecyclerView.OnRefreshListener() &#123; @Override public void onRefresh() &#123; if (refreshNum &gt;= 8) &#123; adapter.data.clear(); &#125; else adapter.data.add(0, \"onRefresh\" + refreshNum++); adapter.notifyDataSetChanged(); &#125; &#125;; onLoadMoreListener = new HarvestRecyclerView.OnLoadMoreListener() &#123; @Override public void onLoadMore() &#123; if (loadMoreNum &gt;= 8) &#123; mRecyclerView.setLoadMoreEnabled(false, null); &#125; else adapter.data.add(\"onLoadMore\" + loadMoreNum++); adapter.notifyDataSetChanged(); &#125; &#125;;&#125; 继承HarvestRecyclerViewAdpter，实现相关抽象的方法以及业务所需要的相关功能。123456789101112131415161718192021222324public List&lt;String&gt; data = new ArrayList&lt;&gt;();@Overridepublic TestHarvHolder onCreateViewHolder(ViewGroup parent) &#123; View root = LayoutInflater.from(parent.getContext()) .inflate(R.layout.item_view_card, parent, false); return new TestHarvHolder(root);&#125;@Overridepublic int getAdapterItemCount() &#123; return data.size();&#125;@Overridepublic void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; if (holder instanceof TestHarvHolder) &#123; ((TestHarvHolder) holder).mContentText.setText(data.get(position)); &#125;&#125;public class TestHarvHolder extends RecyclerView.ViewHolder &#123; TextView mContentText; public TestHarvHolder(View itemView) &#123; super(itemView); mContentText = (TextView) itemView.findViewById(R.id.id_text); &#125;&#125; 效果图如下面所示： 小结对于下拉刷新和上拉加载框架的封装，主要是异常情况的处理，有无HeaderView，有无FooterView`等，以及刷新和加载事件的拦截，以及对于相关设计模式的理解与运用。Github地址：https://github.com/hjw541988478/RefreshLoadMoreRecyclerView 参考 关于RecyclerView中Viewholder和View的缓存机制的探究 first-glance-androids-recyclerview [Android]使用RecyclerView替代ListView（二） 相关Github开源项目SuperRecyclerViewUltimateRecyclerView","tags":[{"name":"PullDownToRefresh","slug":"PullDownToRefresh","permalink":"https://hjw541988478.github.io/tags/PullDownToRefresh/"},{"name":"PullUpToRefresh","slug":"PullUpToRefresh","permalink":"https://hjw541988478.github.io/tags/PullUpToRefresh/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://hjw541988478.github.io/tags/RecyclerView/"},{"name":"CustomView","slug":"CustomView","permalink":"https://hjw541988478.github.io/tags/CustomView/"},{"name":"Components","slug":"Components","permalink":"https://hjw541988478.github.io/tags/Components/"}]},{"title":"Android传感器编程之摇一摇","date":"2015-08-26T11:54:01.000Z","path":"2015/08/26/Android传感器编程之摇一摇/","text":"思路摇一摇功能目前在很多Android的应用都有用到，大多数的目的是增强与用户的交互，同时也增加了趣味性。本质上来看，通过对加速传感器感知手机在X轴、Y轴和Z轴上加速度的变化，在三者的值达到设定的阈值的时候，便触发事件，进行业务上的逻辑调用，同时使用振动传感器产生振动事件。对于加速度传感器和振动传感器的使用，需要预先在配置文件中声明权限：12&lt;uses-permission android:name=&quot;android.hardware.sensor.accelerometer&quot; /&gt; # 加速度传感器&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt; # 振动传感器 同时在应用初始化的时候，获取SensorManager和Vibrator,之后才可以使用振动传感器和加速度传感器进行其他操作：12SensorManager mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE); Vibrator mVibrator = (Vibrator) getSystemService(Service.VIBRATOR_SERVICE); 摇晃监听器的实现 摇晃监听器:1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ShakeOffListener implements SensorEventListener &#123; private Context context; private Vibrator mVibrator; private SensorManager mSensorManager; private OnShakeListener mListener; interface OnShakeListener &#123; void onShake(); &#125; public void setShakeListener(OnShakeListener listener) &#123; this.mListener = listener; &#125; public ShakeOffListener(Context context) &#123; this.context = context; mVibrator = (Vibrator) context. getSystemService(Context.VIBRATOR_SERVICE); mSensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE); &#125; public void resume() &#123; mSensorManager.registerListener(this, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL); &#125; public void pause() &#123; mVibrator.vibrate(300); mSensorManager.unregisterListener(this); &#125; // 传感器值变化 @Override public void onSensorChanged(SensorEvent event) &#123; float x = event.values[0]; float y = event.values[1]; float z = event.values[2]; // 达到速度阀值，发出提示 if (Math.abs(x) &gt;= 19 || Math.abs(y) &gt;= 19 || Math.abs(z) &gt;= 19) &#123; if (mListener != null) mListener.onShake(); &#125; &#125; //传感器反应速度值的变化 @Override public void onAccuracyChanged(Sensor sensor, int accuracy) &#123; &#125;&#125; 在对ShakeOffListener进行初始化时，首先会对传感器进行初始化，同时也在内部定义了OnShakeListener接口，方便在宿主类对事件触发的监听，然后通过对SensorEventListener接口的实现，重新实现了onSensorChanged的回调方法，这里主要完成是对于摇晃功能阈值的设定以及触发条件满足后将事件传给宿主类完成其他操作，同时也定义了resume和pause方法，用来完成摇晃过程的恢复和暂停事件的处理，这样可以更加方便处理摇晃开始、摇晃中和摇晃结束整个流程。 摇晃监听器的使用及其效果 在Activity中进行使用123456789101112131415161718192021222324252627282930313233343536373839404142public class TestActivity extends Activity &#123; private ImageView shkePic; private ShakeOffListener mShakeOffListener; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); shkePic = (ImageView) findViewById(R.id.id_hand_shake_off); mShakeOffListener = new ShakeOffListener(this); mShakeOffListener.setShakeListener(new ShakeOffListener.OnShakeListener() &#123; @Override public void onShake() &#123; //TODO 处理业务请求 Logger.d(\"onShake~\"); Animation shakeAnim = AnimationUtils.loadAnimation(TestActivity.this, R.anim.shake); shakeAnim.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; mShakeOffListener.pause(); &#125; @Override public void onAnimationEnd(Animation animation) &#123; mShakeOffListener.resume(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); shkePic.startAnimation(shakeAnim); &#125; &#125;); mShakeOffListener.resume(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (mShakeOffListener != null)&#123; mShakeOffListener.pause(); mShakeOffListener = null; &#125; &#125;&#125; 在TestActivity中，通过在onCreate方法中，初始化ShakeOffListener同时实现了自定义的摇晃事件接口，巧妙的利用Animation的执行流程的回调方法，防止了摇晃事件的重复触发，摇晃事件的间隔取决于动画的时长，只需要在动画开始和结束使用pause和resume方法便可以暂停和恢复对摇晃事件的监听。最后在Activity被销毁时会回调的onDestroy方法中解除对摇晃监听器的注册，防了止内存泄露。用到的Animation摇晃动画资源文件shake.xml：12345&lt;translate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"500\" android:fromXDelta=\"0\" android:interpolator=\"@anim/cycle_7\" android:toXDelta=\"50\"/&gt; 以及使用到的插值器cycle_7.xml：12&lt;cycleInterpolator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:cycles=\"5.0\" /&gt; 还有在对传感器进行注册的时候，第一个参数是加速度传感器监听器实例，本例中是实现了SensorEventListener接口了的，第二个是加速度传感器实例，实现摇晃功能需要Sensor.TYPE_ACCELEROMETER类型，最后一个参数代表着传感器反应的速度类型，这个有如下几类： SENSOR_DELAY_NORMAL：默认的获取传感器数据的速度； SENSOR_DELAY_UI：若使用传感器更新UI，推荐使用； SENSOR_DELAY_GAME：如果利用传感器开发游戏，建议使用； SENSOR_DELAY_FASTEST：在特别灵敏的处理下推荐使用，但该模式可能造成手机电力大量消耗；对于摇晃功能的实现，也只需要使用默认的即SENSOR_DELAY_NORMAL便可以满足监听传感器加速度变化的需求：123mSensorManager.registerListener(this, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL); 摇晃前截图 摇晃成功截图 总结摇一摇功能用到的知识点有传感器、动画以及利用动画的执行周期巧妙的实现业务需求，但不得不说的是，对于合理设定摇晃阈值才是整个摇晃功能实现的关键，目前这个版本设定的值是19,对于大多数手机是能够实现功能的，但是相信有更好方法利用X、Y、Z轴加速度的值去处理这个阈值，这个是待完善的地方。","tags":[{"name":"Sensor","slug":"Sensor","permalink":"https://hjw541988478.github.io/tags/Sensor/"},{"name":"Vibrator","slug":"Vibrator","permalink":"https://hjw541988478.github.io/tags/Vibrator/"}]},{"title":"Android应用自动检测更新机制的实现","date":"2015-08-25T12:42:39.000Z","path":"2015/08/25/Android应用自动检测更新机制的实现/","text":"需求在安卓应用程序中，随着业务的升级或者BUG的修复，往往需要进行版本的迭代与更新。在更新的过程中，选择合理的更新方式显得尤为重要。但大多数思路都是一样，从服务端获取版本号比对当前包的版本号，如果大于当前版本号则提示用户升级，而对于某些需要强制更新的版本号，则不允许用户取消版本的升级，必须强制更新。整个流程大概如下图所示： 更新流程图 可以看到，整个流程的关键在于对VerisonCode版本号的大小比较，VersionCode标识了同一应用的不同版本号，对于修改版本号后打包的安装包便是最新版本的安装包。在AndroidStudio中，VersionCode的配置一般在应用模块的*.build文件中，如下：1234567defaultConfig &#123; applicationId &quot;com.test.app&quot; minSdkVersion 9 targetSdkVersion 22 versionCode 6 #这里便是对版本号的设置 versionName &quot;2.0.0&quot;&#125; 对于本地版本号的获取，使用1curCode = mActivity.getPackageManager().getPackageInfo(mActivity.getPackageName(), 0).versionCode; 便可以获取，然后直接去比较从服务端获取下来的版本号，便可以知晓应用是否需要更新。 分析使用Service组件去完成整个功能，鉴于它有着不可见，运行在后台的特性，并使用本地服务，直接startService或者stopService便可以完成服务的启动和停止，整个流程分为3个部分，服务端获取最新版本信息-&gt;下载最新版本，并实时更新UI-&gt;下载完成，覆盖安装。 服务端获取最新版本通过服务端提供的API或者第三方SDK提供的API实现，在自定义的Application中，应用启动时便异步发起检测更新的请求，这样应用每次启动都能知晓是否需要更新。对于异步请求，可以使用OkHttp、AsyncHttp等知名的第三方库，同时也可以使用AsyncTask类去实现，当然，视项目的网络请求框架而定，直接复用网络框架中的请求即可。 下载最新版本，更新进度条在获取到服务端返回的结果中，解析最新版本安装包的下载地址URL链接，同时使用NotificationManager去唤起一个新的Notification，对于有进度条需求的，便需要使用自定义的UI，在Notification中获取到视图的ID和引用，这样便可以适时的去更新UI。对于UI更新机制，推荐使用主UI线程的Handler去维护管理消息队列，在下载线程中只需要使用sendMessage方法将相关数据带过去，让Handler去实现具体的UI更新内容。需要注意的时，对于更新频率的控制，在复用Notification时候，更新频率过高的时候，会占用大量内存，可能会引起UI线程的阻塞，从而影响用户体验。 下载完成，覆盖安装如何监听下载完成的事件呢?其实可以有两种方式实现，即BroadcastReceiver或者EventBus，但无论哪种方式，下载完成的关键便是网络数据已经完全请求完成，也就是下载进度达到了100%。而覆盖安装的关键在于Intent的Flags和DataAndType的设置，根据之前设定好的下载文件的路径，并可以发起调用覆盖安装的请求。 实现 UpdateService实现12345678910111213141516171819202122232425262728293031public class UpdateService extends Service &#123; // 安装包下载地址 private String url = null; // 新的安装包本地存储路径 private String filePath = null; // 通知管理器 private NotificationManager updateNotificationManager = null; // 通知 private Notification updateNotification = null; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; // 获取传值 url = intent.getStringExtra(\"url\"); if (url != null) &#123; String fileName = url.substring(url.lastIndexOf(\"/\")); File uDir = new File(Environment.getExternalStorageDirectory() + \"/test/download/\"); if (!uDir.exists() || !uDir.isDirectory()) &#123; uDir.mkdirs(); &#125; // 本地目录存储路径 filePath = uDir + fileName; // 使用AsyncTask执行下载请求 new DownloadAsyncTask().execute(url); &#125; return super.onStartCommand(intent, 0, 0); &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125;&#125; UpdateService先会把本地存储路径和Notification初始化，然后使用AsyncTask进行新安装包的下载和NotificationUI的更新工作。记得在使用Service前进行动态注册或者在AndroidManifest.xml文件中配置好Service节点。 DownloadAsyncTask实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293class DownloadAsyncTask extends AsyncTask&lt;String, Integer, Void&gt; &#123; //构造Notification @Override protected void onPreExecute() &#123; updateNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); updateNotification = new Notification(); updateNotification.icon = R.drawable.ic_launcher; updateNotification.contentView = new RemoteViews(getPackageName(), R.layout.view_notification_download); updateNotification.contentView.setProgressBar(R.id.notify_progress, 100, 0, false); updateNotification.contentView.setTextViewText(R.id.notify_title, \"已下载:0%\"); updateNotification.contentIntent = PendingIntent.getActivity(getApplicationContext(), 0, new Intent(), 0); updateNotification.flags = Notification.FLAG_AUTO_CANCEL; updateNotificationManager.notify(101, updateNotification); &#125; @Override protected Void doInBackground(String... params) &#123; // 下载百分比 int downPercentage = 0; // 上次缓存文件大小 int cachedSize = 0; // 临时文件大小 long tmpTotalSize = 0; // 待下载文件总大小 int totalSize = 0; HttpURLConnection httpUrlConn = null; InputStream httpInputStream = null; FileOutputStream fileOutputStream = null; try &#123; URL url = new URL(params[0]); httpUrlConn = (HttpURLConnection) url.openConnection(); if (cachedSize &gt; 0) &#123; // 方便以后实现断点续传 httpUrlConn.setRequestProperty(\"RANGE\", \"bytes=\" + cachedSize + \"-\"); &#125; httpUrlConn.setConnectTimeout(NetworkConfig.CONNECT_TIMEOUT); httpUrlConn.setReadTimeout(NetworkConfig.CONNECT_TIMEOUT); // 获取文件总大小 totalSize = httpUrlConn.getContentLength(); if (httpUrlConn.getResponseCode() == 200) &#123; httpInputStream = httpUrlConn.getInputStream(); fileOutputStream = new FileOutputStream(new File(filePath)); byte buffer[] = new byte[4096]; int bufferSize = 0; while ((bufferSize = httpInputStream.read(buffer)) &gt; 0) &#123; fileOutputStream.write(buffer, 0, bufferSize); tmpTotalSize += bufferSize; int tmpDownPercentage = (int) (tmpTotalSize * 100 / totalSize); if (tmpDownPercentage - downPercentage &gt; 5) &#123; downPercentage += 5; publishProgress(tmpDownPercentage); &#125; &#125; // 下载结束 publishProgress(100); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); publishProgress(-1); &#125; finally &#123; try &#123; if (httpUrlConn != null) httpUrlConn.disconnect(); if (httpInputStream != null) httpInputStream.close(); if (fileOutputStream != null) fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); publishProgress(-1); &#125; &#125; return null; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; if (values[0] != -1) &#123; updateNotification.contentView.setTextViewText(R.id.notify_title, values[0] &gt;= 100 ? \"已完成下载\" : \"已下载:\" + values[0] + \"%\"); updateNotification.contentView.setProgressBar(R.id.notify_progress, 100, values[0] &gt;= 100 ? 100 : values[0], false); &#125; else &#123; updateNotification.contentView.setTextViewText(R.id.notify_title, \"下载失败!\"); &#125; updateNotification.flags = Notification.FLAG_AUTO_CANCEL; updateNotificationManager.notify(101, updateNotification); &#125; @Override protected void onPostExecute(Void result) &#123; Intent installIntent = new Intent(Intent.ACTION_VIEW); installIntent.addFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED | Intent.FLAG_ACTIVITY_NEW_TASK); installIntent.setDataAndType(Uri.fromFile(new File(filePath)), \"application/vnd.android.package-archive\"); startActivity(installIntent); stopSelf(); &#125; &#125; DownloadAsyncTask充分利用了AsyncTask的特点，分别在onPreExecute中进行了Notification的构造以及唤醒工作，在doInBackground中进行着网络数据下载工作，然后在数据不断缓存的过程中，当数据缓存的比例大于5%时，则调用publishProgress方法，更新Notification中的进度条，这样做的目的是，在频繁更新Notification并唤醒的过程中，会阻塞UI线程导致ANR，因此一般在进度变化累积到5%的时候再去更新UI，保证应用的流畅性。具体涉及到UI的更新工作放在onProgressUpdate方法中，包括进度和文字提示的更新，其中包含了更新失败的情况，同样也需要提示。最后在onPostExecute方法中进行下载文件的获取和安装，并弹出安装界面指导安装。 下载中状态 下载完成状态 安装状态 总结Andriod应用的更新机制主要使用到的知识点有NotificationManager、Notification、ProgressBar、Service、AsyncTask。通过对上面主要的分析与实现，可以看到涉及到的点还是比较多的，但大多都是基础的知识点，以后在实现复杂功能的时候，也应该通过对业务流程的分析、知识点的理解，综合运用，达到目的。","tags":[{"name":"Service","slug":"Service","permalink":"https://hjw541988478.github.io/tags/Service/"},{"name":"Handler","slug":"Handler","permalink":"https://hjw541988478.github.io/tags/Handler/"},{"name":"Notification","slug":"Notification","permalink":"https://hjw541988478.github.io/tags/Notification/"}]},{"title":"PropertyAnimation使用总结","date":"2015-08-24T11:27:14.000Z","path":"2015/08/24/PropertyAnimation使用总结/","text":"ObjectAnimator 淡入效果123ObjectAnimator.ofFloat(tv, \"alpha\", 0.0f, 1.0f) .setDuration(500) .start(); ofFloat对应着三个参数值，分别是目标View，动画属性名Property，以及属性值，一个则为终点值，两个对应着起点和终点值，多个则为起点值，将会调用的值和终点值。与ofFloat类似的还有ofInt、ofObject，这些都是用来设置动画动作的元素。 同时缩小和淡出效果123456789101112131415ObjectAnimator anim = ObjectAnimator .ofFloat(view, \"hjw\", 1.0F, 0.0F) .setDuration(500); anim.start(); anim.addUpdateListener(new AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float cVal = (Float) animation.getAnimatedValue(); view.setAlpha(cVal); view.setScaleX(cVal); view.setScaleY(cVal); &#125; &#125;); 可以看到，使用这种非常规的方式也可以达到预期的效果，只需要在使用了未知的Property，然后再回调方法中按照时间插值和持续时间计算值，我们自己手动调用实现各个属性的值。 ValueAnimator 抛物线运动效果12345678910111213141516171819202122ValueAnimator animator = new ValueAnimator(); animator.setDuration(3000); animator.setObjectValues(new PointF(0, 0)); animator.setInterpolator(new LinearInterpolator()); animator.setEvaluator(new TypeEvaluator&lt;PointF&gt;() &#123; @Override public PointF evaluate(float fraction, PointF startValue, PointF endValue) &#123; PointF pointF = new PointF(); pointF.x = 100 * fraction; pointF.y = 0.5f * (fraction * 100) * (fraction * 100); return pointF; &#125; &#125;); animator.start(); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; PointF point = (PointF) animation.getAnimatedValue(); circleView.setX(point.x); circleView.setY(point.y); &#125; &#125;); 可以看到与ObjectAnimator相比，并没有指定Property的操作，也就是说，ValueAnimator只关心值的变化，但是带来的变化是只需要根据计算好的动画值，重写TypeEvaluator类，在evaluate回调方法中返回任何想要调用的值，类似上面那种非常规的方式，也无需使用到反射。 AnimationSet 淡入淡出效果123456789ObjectAnimator alphaOutAnim = new ObjectAnimator(); alphaOutAnim.ofFloat(tv, \"alpha\", 0f, 1f); ObjectAnimator alphaInAnim = new ObjectAnimator(); alphaInAnim.ofFloat(tv, \"alpha\", 1f, 0f); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.setInterpolator(new LinearInterpolator()); animatorSet.setDuration(2000); animatorSet.playSequentially(alphaOutAnim, alphaInAnim); animatorSet.start(); AnimationSet主要是用来对多动画的执行顺序进行控制，包括playTogether同时执行、playSequentially顺序执行和after with before等方法控制。 监听动画变化事件 监听动画事件123456789101112131415161718192021ObjectAnimator anim = ObjectAnimator.ofFloat(tv, \"alpha\", 0.5f); anim.addListener(new AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; // 动画开始执行 &#125; @Override public void onAnimationRepeat(Animator animation) &#123; // 动画重复执行 &#125; @Override public void onAnimationEnd(Animator animation) &#123; // 动画执行结束 &#125; @Override public void onAnimationCancel(Animator animation) &#123; // 取消动画执行 &#125; &#125;); anim.start(); 对于常用的开始、重复、结束和取消动画事件都能够被监听到，只需要在回调方法中实现所需要实现的业务即可。 XML创建PropertyAnimation XML方式描述淡出效果1234567&lt;objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"1000\" android:propertyName=\"alpha\" android:valueFrom=\"0.0\" android:valueTo=\"1.0\" android:valueType=\"floatType\" &gt;&lt;/objectAnimator&gt; 在res/animator目录下创建alpha.xml文件，然后进行调用：123Animator anim = AnimatorInflater.loadAnimator(this, R.animator.alpha); anim.setTarget(mMv); anim.start() 如果需要多个动画去执行，只需要在XML文件中增加Set节点：123456789101112131415&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:ordering=\"together\" &gt; &lt;objectAnimator android:duration=\"1000\" android:propertyName=\"scaleX\" android:valueFrom=\"1\" android:valueTo=\"0.5\" &gt; &lt;/objectAnimator&gt; &lt;objectAnimator android:duration=\"1000\" android:propertyName=\"scaleY\" android:valueFrom=\"1\" android:valueTo=\"0.5\" &gt; &lt;/objectAnimator&gt;&lt;/set&gt; 通过改变ordering属性的值去控制多个动画之间的执行顺序。 Layout Animations(布局动画)改变ViewGroup的子View移除或者添加的动画效果12345678910LayoutTransition transition = new LayoutTransition(); transition.setAnimator(LayoutTransition.CHANGE_APPEARING, transition.getAnimator(LayoutTransition.CHANGE_APPEARING)); transition.setAnimator(LayoutTransition.APPEARING, null); transition.setAnimator(LayoutTransition.DISAPPEARING, null); transition.setAnimator(LayoutTransition.CHANGE_DISAPPEARING, null); mLayout.setLayoutTransition(transition); 需要注意的四种类型： LayoutTransition.APPEARING：当一个View在ViewGroup中出现时，对此View设置的动画； LayoutTransition.CHANGE_APPEARING： 当一个View在ViewGroup中出现时，此View对其他View位置造成的效果，对其他View设置的动画； LayoutTransition.DISAPPEARING：当一个View在ViewGroup中消失时，对此View设置的动画； LayoutTransition.CHANGE_DISAPPEARING：当一个View在ViewGroup中消失时，此View对其他View位置造成效果，对其他View设置的动画； LayoutTransition.CHANGE：不是由于View出现或消失造成对其他View位置造成效果，对其他View设置的动画。","tags":[{"name":"Animation","slug":"Animation","permalink":"https://hjw541988478.github.io/tags/Animation/"}]},{"title":"多行文本的可展开折叠的TextView实现","date":"2015-08-23T11:28:19.000Z","path":"2015/08/23/多行文本可折叠展开TextView实现/","text":"需求在实现商家评论区的需求时，对于多行评论的显示，采用的是使用maxLines属性去限定显示的行数，同时使用android:ellipsize=end在限定行数的末尾显示...，这种方式可以很好的避免评论文字过多显示过长的情况。但是对于有价值的评论，有必要显示所有评论文字，采用展开折叠的交互，能够更加的灵活地去应对长文字的多行显示，给用户给好的体验。 思路首先，继承LinearLayout，并对文本和标记组件进行一层包装，通过对折叠状态下的行数、展开折叠的动画时长、展开和折叠状态的视图控制，进行可自定义的属性封装。然后对父类的onClick方法进行重写，用户在对组件点击的时候，文本会自动的展开或折叠。然而当文本正在处于折叠或展开过程的动画中时，应该重写onInterceptTouchEvent方法拦截所有的点击事件，防止出现异常。其次，在整个流程中我们需要了解到文本的真实高度，用来在初始化的时候去判断是否需要进入折叠模式，因此需要重写onMeasure方法，如果组件不需要重新绘制或者组件的可见性为View.GONE，则直接使用父类的onMeasure方法。然后，但是如果组件需要重新绘制，便会初始化组件的状态，并对组件进行测量，判断真实文本的行数，如果小于设置的最大显示行数，则直接显示，否则按最大显示行数显示文本并让展开状态的View可见，保存当前折叠状态下显示的高度。最后，对于视图复用的问题，一般情况下，视图被滑出了屏幕看不见后，这个视图数据便消失了，重新让视图进入屏幕中时，视图会重新初始化，而对于那些展开或者折叠状态的视图也会默认变为折叠模式。因此需要一个标记量去使用额外的标记决定视图显示的位置和状态，这里使用到的是SparseBooleanArray，实质上基于稀疏矩阵和折半查找的HashMap&lt;Integer,Boolean&gt;的优化版本，key用来记录位置，value用来记录状态。 实现 通过在attrs.xml中进行属性的自定义，并通过下面的代码去获取在布局文件中配置的自定义的属性值，包括了最多显示行数，展开、折叠资源等。 12345678910111213141516171819202122 private void init(AttributeSet attrs) &#123; TypedArray typedArray = getContext().obtainStyledAttributes(attrs, R.styleable.ExpTextView); //最多行数 mMaxLines = typedArray.getInt(R.styleable.Exp_maxCollapsedLines, MAX_COLLAPSED_LINES); //动画时长 mAnimDuration = typedArray.getInt(R.styleable.ExpTextView_animDuration, DEFAULT_ANIM_DURATION); // 动画透明度渐变初始值 mAnimAlphaStart = typedArray.getFloat(R.styleable.ExpTextView_animAlphaStart, DEFAULT_ANIM_ALPHA_START); mExpandDrawable = typedArray.getDrawable(R.styleable.ExpTextView_expandDrawable); mCollapseDrawable = typedArray.getDrawable(R.styleable.ExpTextView_collapseDrawable); if (mExpandDrawable == null) &#123; mExpandDrawable = getDrawable(getContext(), ); &#125; if (mCollapseDrawable == null) &#123; mCollapseDrawable = getDrawable(getContext(), R.drawable.ic_mer_detail_collapse); &#125; typedArray.recycle(); //只能是垂直布局 setOrientation(LinearLayout.VERTICAL); //默认是不显示的 setVisibility(GONE);&#125; 重写onMeasure方法，目的是判断当前文本的状态和初始化在不同状态下必要的数据。 1234567891011121314151617181920212223242526272829303132333435363738@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 如果没有改变直接返回当前状态 if (!mRelayout || getVisibility() == View.GONE) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); return; &#125; mRelayout = false; // 初始化默认状态 mButton.setVisibility(View.GONE); mTv.setMaxLines(Integer.MAX_VALUE); // 测量控件尺寸 super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 文本显示的行数小于限定值，直接返回 if (mTv.getLineCount() &lt;= mMaxCollapsedLines) &#123; return; &#125; // 获得文本的真实高度 mTextHeightWithMaxLines = getRealTextViewHeight(mTv); // 处于折叠模式中，只显示限定值的行数 if (mCollapsed) &#123; mTv.setMaxLines(mMaxCollapsedLines); &#125; mButton.setVisibility(View.VISIBLE); // 重新测量控件尺寸 super.onMeasure(widthMeasureSpec, heightMeasureSpec); if (mCollapsed) &#123; // 获得文本与容器的外间距值 mTv.post(new Runnable() &#123; @Override public void run() &#123; mMarginBetweenTxtAndBottom = getHeight() - mTv.getHeight(); &#125; &#125;); // 保存当前测量值的高度 mCollapsedHeight = getMeasuredHeight(); &#125;&#125; 获取TextView真实高度的方法。 12345private static int getRealTextViewHeight(TextView textView) &#123; int textHeight = textView.getLayout().getLineTop(textView.getLineCount()); int padding = textView.getCompoundPaddingTop() + textView.getCompoundPaddingBottom(); return textHeight + padding; &#125; 重写onClick方法，处理点击事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic void onClick(View view) &#123; if (mButton.getVisibility() != View.VISIBLE) &#123; return; &#125; // 折叠模式状态值与上次相反 mCollapsed = !mCollapsed; mButton.setImageDrawable(mCollapsed ? mExpandDrawable : mCollapseDrawable); if (mCollapsedStatus != null) &#123; // 存放状态值 mCollapsedStatus.put(mPosition, mCollapsed); &#125; // 动画播放标记置true mAnimating = true; Animation animation; if (mCollapsed) &#123; animation = new ExpandCollapseAnimation(this, getHeight(), mCollapsedHeight); &#125; else &#123; animation = new ExpandCollapseAnimation(this, getHeight(), getHeight() + mTextHeightWithMaxLines - mTv.getHeight()); &#125; // 保持动画后的状态 animation.setFillAfter(true); animation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; applyAlphaAnimation(mTv, mAnimAlphaStart); &#125; @Override public void onAnimationEnd(Animation animation) &#123; // 防止多次调用applyTransformation() clearAnimation(); // 动画播放标记置false mAnimating = false; // 如果外部有设置监听事件，则触发监听事件 if (mListener != null) &#123; mListener.onExpandStateChanged(mTv, !mCollapsed); &#125; &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); clearAnimation(); startAnimation(animation);&#125; 展开折叠动画类。 1234567891011121314151617181920212223242526272829class ExpandCollapseAnimation extends Animation &#123; private final View mTargetView; private final int mStartHeight; private final int mEndHeight; public ExpandCollapseAnimation(View view, int startHeight, int endHeight) &#123; mTargetView = view; mStartHeight = startHeight; mEndHeight = endHeight; setDuration(mAnimationDuration); &#125; @Override protected void applyTransformation(float interpolatedTime, Transformation t) &#123; final int newHeight = (int) ((mEndHeight - mStartHeight) * interpolatedTime + mStartHeight); mTv.setMaxHeight(newHeight - mMarginBetweenTxtAndBottom); if (Float.compare(mAnimAlphaStart, 1.0f) != 0) &#123; applyAlphaAnimation(mTv, mAnimAlphaStart + interpolatedTime * (1.0f - mAnimAlphaStart)); &#125; mTargetView.getLayoutParams().height = newHeight; mTargetView.requestLayout(); &#125; @Override public void initialize(int width, int height, int parentWidth, int parentHeight) &#123; super.initialize(width, height, parentWidth, parentHeight); &#125; @Override public boolean willChangeBounds() &#123; return true; &#125;&#125; 其他必要重写的方法。 12345678910@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; // 如果动画正在播放就不分发触摸时间给子View return mAnimating;&#125;@Overrideprotected void onFinishInflate() &#123; // 结束加载时初始化控件ID findViews();&#125; 效果 多行文本展开状态效果图 多行文本收缩状态效果图","tags":[{"name":"CustomView","slug":"CustomView","permalink":"https://hjw541988478.github.io/tags/CustomView/"}]}]