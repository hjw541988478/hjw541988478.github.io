<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Android插件化原理探索 | Garvin 杂记</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="MultiProcess,AIDL,插件化">
    <meta name="description" content="代理模式（委托模式）限制对象的直接访问，保护内部对象； 静态代理AIDL中asInterface方法中有应用到静态代理，如果不在同一进程就会返回Proxy对象，而且几乎所有系统服务采用代理模式。 动态代理运行时指定代理类，实现InvocationHandler接口，重写invoke方法，通过Proxy.newInstance返回代理对象。分为jdk动态代理和cglib动态代理；  jdk动态代理：">
<meta name="keywords" content="MultiProcess,AIDL,插件化">
<meta property="og:type" content="article">
<meta property="og:title" content="Android插件化原理探索">
<meta property="og:url" content="https://hjw541988478.github.io/2017/05/Android插件化原理探索/index.html">
<meta property="og:site_name" content="Garvin 杂记">
<meta property="og:description" content="代理模式（委托模式）限制对象的直接访问，保护内部对象； 静态代理AIDL中asInterface方法中有应用到静态代理，如果不在同一进程就会返回Proxy对象，而且几乎所有系统服务采用代理模式。 动态代理运行时指定代理类，实现InvocationHandler接口，重写invoke方法，通过Proxy.newInstance返回代理对象。分为jdk动态代理和cglib动态代理；  jdk动态代理：">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-08-18T15:39:35.844Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android插件化原理探索">
<meta name="twitter:description" content="代理模式（委托模式）限制对象的直接访问，保护内部对象； 静态代理AIDL中asInterface方法中有应用到静态代理，如果不在同一进程就会返回Proxy对象，而且几乎所有系统服务采用代理模式。 动态代理运行时指定代理类，实现InvocationHandler接口，重写invoke方法，通过Proxy.newInstance返回代理对象。分为jdk动态代理和cglib动态代理；  jdk动态代理：">
    
        <link rel="alternate" type="application/atom+xml" title="Garvin 杂记" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Garvin</h5>
          <a href="mailto:huangjiawendanny@gmail.com" title="huangjiawendanny@gmail.com" class="mail">huangjiawendanny@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                存档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Android插件化原理探索</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Android插件化原理探索</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-05-16T14:01:00.000Z" itemprop="datePublished" class="page-time">
  2017-05-16
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#代理模式（委托模式）"><span class="post-toc-number">1.</span> <span class="post-toc-text">代理模式（委托模式）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#静态代理"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">静态代理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#动态代理"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">动态代理</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Hook机制"><span class="post-toc-number">2.</span> <span class="post-toc-text">Hook机制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Binder机制"><span class="post-toc-number">3.</span> <span class="post-toc-text">Binder机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AIDL（以ActivityManager为例）："><span class="post-toc-number">3.1.</span> <span class="post-toc-text">AIDL（以ActivityManager为例）：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ClassLoader"><span class="post-toc-number">4.</span> <span class="post-toc-text">ClassLoader</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#官方MultiDex方案"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">官方MultiDex方案</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ClassLoader-1"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">ClassLoader</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为啥PathClassLoader的optimizedDirectory可以为null？"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">为啥PathClassLoader的optimizedDirectory可以为null？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Activity启动流程分析"><span class="post-toc-number">5.</span> <span class="post-toc-text">Activity启动流程分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Activity启动流程总结"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">Activity启动流程总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#简单插件化实现"><span class="post-toc-number">6.</span> <span class="post-toc-text">简单插件化实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#思路"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">思路</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#代码动态加载"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">代码动态加载</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#实现"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#插件Activity为啥就有生命周期了呢？"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">插件Activity为啥就有生命周期了呢？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#资源动态加载"><span class="post-toc-number">7.</span> <span class="post-toc-text">资源动态加载</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#系统资源加载分析"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">系统资源加载分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#插件如何拿到创建好的Resources资源呢-？"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">插件如何拿到创建好的Resources资源呢 ？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考"><span class="post-toc-number">8.</span> <span class="post-toc-text">参考</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Android插件化原理探索"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Android插件化原理探索</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-05-16 22:01:00" datetime="2017-05-16T14:01:00.000Z"  itemprop="datePublished">2017-05-16</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="代理模式（委托模式）"><a href="#代理模式（委托模式）" class="headerlink" title="代理模式（委托模式）"></a>代理模式（委托模式）</h2><p>限制对象的直接访问，保护内部对象；</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>AIDL中<code>asInterface</code>方法中有应用到静态代理，如果不在同一进程就会返回Proxy对象，而且几乎所有系统服务采用代理模式。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>运行时指定代理类，实现<code>InvocationHandler</code>接口，重写invoke方法，通过<code>Proxy.newInstance</code>返回代理对象。分为jdk动态代理和cglib动态代理；</p>
<ul>
<li>jdk动态代理：基于类的反射机制，而且目标类基于同一的接口，Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理；</li>
<li>cglib动态代理：借助asm实现，没有jdk动态代理的限制；<a id="more"></a>
<h2 id="Hook机制"><a href="#Hook机制" class="headerlink" title="Hook机制"></a>Hook机制</h2>对一些方法进行拦截，当这些方法被调用时，能够执行我们自定义的代码，大致思路：</li>
</ul>
<p>找到需要拦截的方法；<br>利用代理模式来代理系统类的运行拦截我们需要拦截的方法；<br>使用反射方法把系统类替换成你的代理类； ##反射机制<br>java的反射机制是在运行态中，对于任意一个类都能知道其属性和方法，对于任意一个对象都能调用其方法和属性，这种动态获取信息以及动态调用对象的方法称为反射机制；</p>
<ol>
<li><p>实例化对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forNmae(完整类名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(完整类名);</span><br><span class="line">Class&lt;?&gt; superClass = clazz.getSuperclass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取实现接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(完整类名);</span><br><span class="line">Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取指定参数构造函数以及实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(完整类名);</span><br><span class="line">Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); <span class="comment">// 公共构造</span></span><br><span class="line"><span class="keyword">for</span>( .. ) &#123;</span><br><span class="line">    Class&lt;?&gt; clazzs[] = constructor.getParameterTypes(); <span class="comment">// 获取参数类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无参数实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(完整类名);</span><br><span class="line">clazz.newInstance();</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取字段修改字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(完整类名);</span><br><span class="line">Field field = clazz.getField(name); <span class="comment">// 获取公共字段</span></span><br><span class="line">Field[] fields = clazz.getFields(); <span class="comment">// 获取所有公共字段</span></span><br><span class="line">Field field = clazz.getDeclaredField(<span class="string">"heihei"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置java取消访问检查，也就是说如果是私有的也可以访问,</span></span><br><span class="line">field.set(obj, <span class="string">"Java反射机制"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取方法运行方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Method method = clazz.getMethod(<span class="string">"add"</span>,<span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">method.setAccessiable(<span class="keyword">true</span>);</span><br><span class="line">method.invoke(clazz.newInstance(), <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取数组或者list中的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; componentType = clazz.getComponentType();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以hook剪切板服务为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Context.getSystemService(CLIPBOARD_SERVICE) -&gt;</span><br><span class="line">ContextImpl.getSystemService() -&gt;</span><br><span class="line">SystemServiceRegistry.getSystemService() -&gt;</span><br><span class="line">SYSTEM_SERVICE_FETCHERS.get() -&gt;</span><br><span class="line">ServiceManager.getService()获取IBinder -&gt;</span><br><span class="line">IBinder.asInterface()获取到远程服务接口 -&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.content.<span class="function">IClipboard <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); <span class="comment">// Hook点</span></span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> android.content.IClipboard))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((android.content.IClipboard) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android.content.IClipboard.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体实现：</p>
<ol>
<li><p>剪切板服务，是在系统的<code>ServiceManager</code>中的<code>getSerVice</code>方法中得到的，我们先拿到<code>ServiceManager</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; serviceMangerClass = Class.forName(<span class="string">"android.os.ServiceManager"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>拿到<code>getService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method getServiceMethod = serviceMangerClass.getDeclaredMethod(<span class="string">"getService"</span>, String.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过这个方法，拿到原本的系统服务代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IBinder binder = (IBinder) getServiceMethod.invoke(<span class="keyword">null</span>,<span class="string">"clipboard"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们通过这个对象，创建我们自己的代理对象，瞒天过海骗过系统</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IBinder myBinder = (IBinder) Proxy.newProxyInstance(serviceMangerClass.getClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> Class[]&#123;IBinder.class&#125;,<span class="keyword">new</span> MyClipProxy(binder));</span><br></pre></td></tr></table></figure>
</li>
<li><p>拿到 ServiceManager 中的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Field field = serviceMangerClass.getDeclaredField(<span class="string">"sCache"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Map&lt;String, IBinder&gt; map = (Map) field.get(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//将我们的服务类存入map</span></span><br><span class="line">map.put(<span class="string">"clipboard"</span>,myBinder);</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClipProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mBase;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClipProxy</span><span class="params">(IBinder binder)</span> </span>&#123;</span><br><span class="line">        mBase = binder;<span class="comment">//这里传入的是原系统的代理类</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//拦截原系统类查询本地是否有这个代理的方法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"queryLocalInterface"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="comment">//我们这里要创建我们自己的系统类，然后返回</span></span><br><span class="line">            <span class="comment">//1.拿到系统的aidl类中的stub，因为这个对象本来就是个代理,而且源码执行了</span></span><br><span class="line"><span class="comment">//            static private IClipboard getService() &#123;</span></span><br><span class="line"><span class="comment">//                synchronized (sStaticLock) &#123;</span></span><br><span class="line"><span class="comment">//                    if (sService != null) &#123;</span></span><br><span class="line"><span class="comment">//                        return sService;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                    IBinder b = ServiceManager.getService("clipboard");</span></span><br><span class="line"><span class="comment">//                    sService = IClipboard.Stub.asInterface(b);</span></span><br><span class="line"><span class="comment">//                    return sService;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            Class&lt;?&gt; mStubClass = Class.forName(<span class="string">"android.content.IClipboard$Stub"</span>);</span><br><span class="line">            <span class="comment">//2.在拿到IClipboard本地对象类</span></span><br><span class="line">            Class&lt;?&gt; mIClipboard = Class.forName(<span class="string">"android.content.IClipboard"</span>);</span><br><span class="line">            <span class="comment">//3.创建我们自己的代理</span></span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(mStubClass.getClassLoader(),</span><br><span class="line">                    <span class="keyword">new</span> Class[]&#123;mIClipboard&#125;,</span><br><span class="line">                    <span class="keyword">new</span> MyClip(mBase,mStubClass));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不是这个方法还是返回原系统的执行</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(mBase,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClip</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object mBase;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClip</span><span class="params">(IBinder base, Class stub)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拿到asInteface方法，因为源码中执行了这一句，我们也要执行这一句</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method asInterface = stub.getDeclaredMethod(<span class="string">"asInterface"</span>, IBinder.class);</span><br><span class="line">            mBase = asInterface.invoke(<span class="keyword">null</span>,base);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//这里我们拦截粘贴的方法，</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"getPrimaryClip"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="keyword">return</span> ClipData.newPlainText(<span class="keyword">null</span>,<span class="string">"我是刘镓旗，我改了系统源码，哈哈哈"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再拦截是否有复制的方法，放系统认为一直都有</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"hasPrimaryClip"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其他启动还是返回原有的</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(mBase,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h2><h3 id="AIDL（以ActivityManager为例）："><a href="#AIDL（以ActivityManager为例）：" class="headerlink" title="AIDL（以ActivityManager为例）："></a>AIDL（以ActivityManager为例）：</h3><p><code>ActivityManager</code>其实是AMS在主进程中的一个代理包装类，内部使用<code>AMN.getDefault()</code>进行操作：</p>
<ul>
<li><p>asInterface()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** &#123;<span class="doctag">@hide</span>&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerNative</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IActivityManager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cast a Binder object into an activity manager interface, generating</span></span><br><span class="line"><span class="comment">     * a proxy if needed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager in =</span><br><span class="line">            (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> in;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActivityManagerProxy(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>onTransact()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> START_ACTIVITY_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">        IBinder b = data.readStrongBinder();</span><br><span class="line">        IApplicationThread app = ApplicationThreadNative.asInterface(b);</span><br><span class="line">        String callingPackage = data.readString();</span><br><span class="line">        Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">        String resolvedType = data.readString();</span><br><span class="line">        IBinder resultTo = data.readStrongBinder();</span><br><span class="line">        String resultWho = data.readString();</span><br><span class="line">        <span class="keyword">int</span> requestCode = data.readInt();</span><br><span class="line">        <span class="keyword">int</span> startFlags = data.readInt();</span><br><span class="line">        ProfilerInfo profilerInfo = data.readInt() != <span class="number">0</span></span><br><span class="line">                ? ProfilerInfo.CREATOR.createFromParcel(data) : <span class="keyword">null</span>;</span><br><span class="line">        Bundle options = data.readInt() != <span class="number">0</span></span><br><span class="line">                ? Bundle.CREATOR.createFromParcel(data) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> result = startActivity(app, callingPackage, intent, resolvedType,</span><br><span class="line">                resultTo, resultWho, requestCode, startFlags, profilerInfo, options);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        reply.writeInt(result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其实<code>ActivityManagerNative</code>相当于<code>IActivityManager</code>的代理内部类Stub，当不是一个进程会使用代理类Proxy来操作，将创建好的参数写入data中，当前线程挂起发起远程调用m<code>Remote.transact()</code>方法，此时调用服务端的<code>onTransact()</code>方法，直到有返回结果，然后从reply中取result；<br>服务端请求走到<code>onTransact</code>方法时，通过code确定是属于哪个方法，然后从data取出需要的参数，并调用相应方法，将返回值写入reply。</p>
<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><h3 id="官方MultiDex方案"><a href="#官方MultiDex方案" class="headerlink" title="官方MultiDex方案"></a>官方MultiDex方案</h3><p>一个APK包含多个dex文件，除了第一个dex文件以外，其他dex文件是以资源形式加载的，也就是说，Application初始化前，将dex文件注入到系统的ClassLoader中，在Android的类加载机制中，同一个类只会被加载一次，为了让修复后的类替换原有的类，必须让补丁包优先加载，也就是插入到原有dex之前。</p>
<h3 id="ClassLoader-1"><a href="#ClassLoader-1" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>Android中有主要的两个ClassLoader，<code>PathClassLoader</code>和<code>DexClassLoader</code>，它们都继承自<code>BaseDexClassLoader</code>，具体加载方法是findClass：</p>
<ul>
<li>PathClassLoader：<br>加载系统类和主dex，也就意味着optimiszedDirectory为null，通过注释可知，被用来加载本地文件系统上的文件或目录，不能从网络加载；<br>DexClassLoader：<br>用于加载其他dex文件中的类。其构造：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dexPath：需要被加载的dex文件地址；</span></span><br><span class="line"><span class="comment">//optimizedDirectory：dex文件被编译器优化后的存放路径，禁止为null，应该提供应用私有路径；</span></span><br><span class="line"><span class="comment">//libraryPath：包含本地库的列表；</span></span><br><span class="line"><span class="comment">//parent：父类构造器</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="为啥PathClassLoader的optimizedDirectory可以为null？"><a href="#为啥PathClassLoader的optimizedDirectory可以为null？" class="headerlink" title="为啥PathClassLoader的optimizedDirectory可以为null？"></a>为啥PathClassLoader的optimizedDirectory可以为null？</h3><p>在初始化时，会构造一个叫pathList的<code>DexPathList</code>对象，在findClass的时候使用pathList调用findClass，查看DexPathList源码发现，如果<code>optimizedDirectory</code>为空则使用系统默认的文件夹，我们的应用已经安装并优化了，优化后的dex存在于/data/dalvik-cache目录下，这样就无法修改该optimizedDirectory；<br>在<code>DexClassLoader</code>初始化时，会将参数中的dex文件都保存在<code>Element</code>数组中，这样在findClass的时候，只需要遍历<code>dexElements</code>，从中查找目标类并返回便停止遍历。</p>
<h2 id="Activity启动流程分析"><a href="#Activity启动流程分析" class="headerlink" title="Activity启动流程分析"></a>Activity启动流程分析</h2><p>Launcher.startActivityForSafely() -&gt; Activity.startActivity() -&gt; startActivityForResult() -&gt; Instrumention.execStartActiviy() -&gt; ActivityMangerNative.getDefault().startActivity() -&gt;<br>（先调用checkStartActivityResult()来检查Activity是否有效合法）-&gt; AMS.startActivity()/AMS代理类请求AMS启动一个Activity -&gt; AMS.startActivityAsUser()-&gt;ActivityStarter.startActivityMayWait() -&gt;<br>ActivityStackSupervisor.realStartActivityLocked() -&gt; app.thread.scheduleLaunchActivity()/调用ActivityThread的内部类ApplicationThread，其中ApplicationThread是IApplicationThread子类，是Binder对象 -&gt; ActivityThread.scheduleLaunchActivity()-&gt; sendMessage()/发送消息到内部类H中 -&gt; H.handleMessage() -&gt;handleLaunchActivity() -&gt; performLaunchActivity() -&gt; Instrumention.newActivity( )/1.创建Activity -&gt; ActivityClientRecord.package.makeApplication()/2. 创建Application，如果Application已经创建则直接返回，否则创建并调用callApplicationOnCreate() -&gt; createBaseContextForActivity()/activity.attach()/mInstrumention.callActivityOnCreate()/3.创建Context对象并attach，onCrerate方法；</p>
<h3 id="Activity启动流程总结"><a href="#Activity启动流程总结" class="headerlink" title="Activity启动流程总结"></a>Activity启动流程总结</h3><ol>
<li>待启动的Activity会去AMS中校验是否合法；</li>
<li>回调ActivityThread中内部类ApplicationThread的scheduleLaunchActivity发送到内部类H中，H继承于Handler；</li>
<li>反射创建Activity以及Application并回调相应生命周期方法；</li>
</ol>
<h2 id="简单插件化实现"><a href="#简单插件化实现" class="headerlink" title="简单插件化实现"></a>简单插件化实现</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>加载插件的ClassLoader通过LoadedApk对象获得的，通过我们构建一个LoadedApk对象，修改其中的ClassLoader对象，创建自己的ClassLoader对象，全面接管加载过程，再使用hook的方式把构建的LoaderApk对象存入mPackages的map中，这样会优先获取缓存也能获取到插件的LoadedApk了。不过需要hook系统中的很多方法，因为创建loadedapk需要ApplicationInfo对象，这个对象从AndroidManifest红来，还需要手动解析AndroidManifest，这个过程相对复杂很多，360的DroidPlugin采用的这种方法。</li>
<li>既然启动插件需要classloader，那也可以将我们的插件apk告诉系统classloader，让系统ClassLoader来接管创建，系统通过PathClassLoader加载系统类和主Dex类，DexClassLoader则用于加载其他dex中的类。</li>
</ol>
<h3 id="代码动态加载"><a href="#代码动态加载" class="headerlink" title="代码动态加载"></a>代码动态加载</h3><p>apk被安装后，apk文件代码以及资源会被放在/data/app/package_name/base-1.apk中，系统进行类加载的时候，会自动在这个路径去寻找，当然未安装的apk是没办法做到的。既然类加载是通过BaseDexClassLoader的findClass方法，最终调用的是DexPathList类里面的findClass，而实际上使用的是此类里面的dexElements数组，这个数组就是用来存放dex文件的数组，我们只需要将插件apk中的dex文件插入到dexElements数组中就可以实现，让系统自动加载并创建类了。<br>对于Activity而言稍有不一样，因为AMS会检查待启动的Activity是否又在AndroidManifest中注册，而插件apk却是灵活的，因此需要hook代理startActivity，采用占坑方式，在校验的时候使用占坑activity通过校验，在真正启动的时候hookActivity创建方法，替换回来启动真正的Activity；<br>总结下需要注意的点：</p>
<ol>
<li>startActivity最终走到AMS的startActivity；</li>
<li>AMS验证activity是否合法；</li>
<li>Activity创建时使用的ClassLoader为PathClassLoader；</li>
<li>分析ClassLoader可以知道，在装载类的时候最终使用的是BaseDexClassloader维护的dexElements数组来进行findClass的；</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现插件DexClassLoader，并合宿主的pathList：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DexClassLoader pluginClassLoader = <span class="keyword">new</span> DexClassLoader(apkPath, cacheDir, cacheDir, getClassLoader());</span><br><span class="line">PathClassLoader hostClassLoader = (PathClassLoader) getContext().getClassLoader();</span><br><span class="line">Object pluginElements = getDexElements(pluginClassLoader);</span><br><span class="line">Object hostElements = getDexElements(hostClassLoader);</span><br><span class="line">Object mergedElements = Array.newInstance(Element.class, totalLen);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k &lt; totalLen; k ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; hostLen) &#123;</span><br><span class="line">        Array.set(mergedElements,k,Array.get(host, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Array.set(mergedElements,k,Array.get(plugin, k - hostLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setField(<span class="string">"dexElements"</span>, mergedElements);</span><br></pre></td></tr></table></figure></p>
<p>此时对于普通的插件Class便可以达到加载的目的了，而对于Activity还需要做一些微小的工作；</p>
<ol>
<li><p>代理启动Activity，在AMS验证的时候需要先将Activity替换成占坑的Activity，分析源码可知，在AMS验证之前的一步操作是ActivityManagerNative.getDefault().startActivity()，使用ActivityManger的本地代理类来启动Activity，这里的Hook点便在此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ActivityManagerNative的类</span></span><br><span class="line">Class&lt;?&gt; activityManagerNativeClass = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line"><span class="comment">//拿到gDefault字段</span></span><br><span class="line">Field gDefaultField = activityManagerNativeClass.getDeclaredField(<span class="string">"gDefault"</span>);</span><br><span class="line">gDefaultField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//从gDefault字段中取出这个对象的值</span></span><br><span class="line">Object gDefault = gDefaultField.get(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// gDefault是一个 android.util.Singleton对象; 我们取出这个单例里面的字段</span></span><br><span class="line">Class&lt;?&gt; singleton = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line"><span class="comment">//这个gDefault是一个Singleton类型的，我们需要从Singleton中再取出这个单例的AMS代理</span></span><br><span class="line">Field mInstanceField = singleton.getDeclaredField(<span class="string">"mInstance"</span>);</span><br><span class="line">mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//ams的代理对象</span></span><br><span class="line">Object rawIActivityManager = mInstanceField.get(gDefault);</span><br><span class="line"><span class="comment">// 创建一个这个对象的代理对象, 然后替换这个字段, 让我们的代理对象帮忙干活,这里我们使用动态代理,</span></span><br><span class="line"><span class="comment">//动态代理依赖接口，而ams实现与IActivityManager</span></span><br><span class="line">Class&lt;?&gt; iActivityManagerInterface = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line"><span class="comment">//返回代理对象,IActivityManagerHandler是我们自己的代理对象，具体代码请下载demo</span></span><br><span class="line">Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line"><span class="keyword">new</span> Class&lt;?&gt;[] &#123; iActivityManagerInterface &#125;, <span class="keyword">new</span> IActivityManagerHandler(rawIActivityManager));</span><br><span class="line"><span class="comment">//将我们的代理设值给singleton的单例</span></span><br><span class="line">mInstanceField.set(gDefault, proxy);</span><br><span class="line">代理IActivityManager的类如下，只是拦截了startActivity并使用占坑的Activity顺带把插件Activity存入Intent：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IActivityManagerHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"startActivity"</span>.equals(method.getName())) &#123;</span><br><span class="line">Log.e(<span class="string">"Main"</span>,<span class="string">"startActivity方法拦截了"</span>);</span><br><span class="line"><span class="comment">// 找到参数里面的第一个Intent 对象</span></span><br><span class="line">Intent raw;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">index = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">raw = (Intent) args[index];</span><br><span class="line"><span class="comment">//创建一个要被掉包的Intent</span></span><br><span class="line">Intent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line"><span class="comment">// 替身Activity的包名, 也就是我们自己的"包名"</span></span><br><span class="line">String stubPackage = MyApplication.getContext().getPackageName();</span><br><span class="line"><span class="comment">// 这里我们把启动的Activity临时替换为 ZhanKengActivitiy</span></span><br><span class="line">ComponentName componentName = <span class="keyword">new</span> ComponentName(stubPackage, ZhanKengActivitiy.class.getName());</span><br><span class="line">newIntent.setComponent(componentName);</span><br><span class="line"><span class="comment">// 把我们原始要启动的TargetActivity先存起来</span></span><br><span class="line">newIntent.putExtra(AMSHookHelper.EXTRA_TARGET_INTENT, raw);</span><br><span class="line"><span class="comment">// 替换掉Intent, 达到欺骗AMS的目的</span></span><br><span class="line">args[index] = newIntent;</span><br><span class="line">Log.e(<span class="string">"Main"</span>,<span class="string">"startActivity方法 hook 成功"</span>);</span><br><span class="line">Log.e(<span class="string">"Main"</span>,<span class="string">"args[index] hook = "</span> + args[index]);</span><br><span class="line"><span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在检查完之后，还需要在ActivityThread中的H中替换需要启动的Activity，也就是Hook点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">先获取到当前的ActivityThread对象</span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line"><span class="comment">//他有一个方法返回了自己</span></span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//执行方法得到ActivityThread对象</span></span><br><span class="line">Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 由于ActivityThread一个进程只有一个,我们获取这个对象的mH字段，也就是H这个Handler</span></span><br><span class="line">Field mHField = activityThreadClass.getDeclaredField(<span class="string">"mH"</span>);</span><br><span class="line">mHField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//得到H这个Handler</span></span><br><span class="line">Handler mH = (Handler) mHField.get(currentActivityThread);</span><br><span class="line"><span class="comment">//创建一个我们的CallBack并赋值给mH</span></span><br><span class="line">Field mCallBackField = Handler.class.getDeclaredField(<span class="string">"mCallback"</span>);</span><br><span class="line">mCallBackField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//设置我们自己的CallBackField，具体替换信息代码请下载demo查看</span></span><br><span class="line">mCallBackField.set(mH, <span class="keyword">new</span> ActivityThreadHandlerCallback(mH));</span><br><span class="line">同样的，需要代理H类的mCallback对象，在startActivity时恢复插件的Activity：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThreadHandlerCallback</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">Handler mBase;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityThreadHandlerCallback</span><span class="params">(Handler base)</span> </span>&#123;</span><br><span class="line">mBase = base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">Log.e(<span class="string">"Main"</span>,<span class="string">"handleMessage what = "</span> + msg.what);</span><br><span class="line"><span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line"><span class="comment">// ActivityThread里面 "LAUNCH_ACTIVITY" 这个字段的值是100</span></span><br><span class="line"><span class="comment">// 本来使用反射的方式获取最好, 这里为了简便直接使用硬编码</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">handleLaunchActivity(msg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mBase.handleMessage(msg);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里简单起见,直接取出TargetActivity;</span></span><br><span class="line">Log.e(<span class="string">"Main"</span>,<span class="string">"handleLaunchActivity方法 拦截"</span>);</span><br><span class="line">Object obj = msg.obj;</span><br><span class="line"><span class="comment">// 根据源码:</span></span><br><span class="line"><span class="comment">// 这个对象是 ActivityClientRecord 类型</span></span><br><span class="line"><span class="comment">// 我们修改它的intent字段为我们原来保存的即可.</span></span><br><span class="line"><span class="comment">// switch (msg.what) &#123;</span></span><br><span class="line"><span class="comment">// case LAUNCH_ACTIVITY: &#123;</span></span><br><span class="line"><span class="comment">// Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart");</span></span><br><span class="line"><span class="comment">// final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span></span><br><span class="line"><span class="comment">// r.packageInfo = getPackageInfoNoCheck(</span></span><br><span class="line"><span class="comment">// r.activityInfo.applicationInfo, r.compatInfo);</span></span><br><span class="line"><span class="comment">// handleLaunchActivity(r, null);</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 把替身恢复成真身</span></span><br><span class="line">Field intent = obj.getClass().getDeclaredField(<span class="string">"intent"</span>);</span><br><span class="line">intent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Intent raw = (Intent) intent.get(obj);</span><br><span class="line">Intent target = raw.getParcelableExtra(AMSHookHelper.EXTRA_TARGET_INTENT);</span><br><span class="line">raw.setComponent(target.getComponent());</span><br><span class="line">Log.e(<span class="string">"Main"</span>,<span class="string">"target = "</span> + target);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"hook launch activity failed"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="插件Activity为啥就有生命周期了呢？"><a href="#插件Activity为啥就有生命周期了呢？" class="headerlink" title="插件Activity为啥就有生命周期了呢？"></a>插件Activity为啥就有生命周期了呢？</h3><p>AMS与ActivityThread之间对于Activity的生命周期的交互，并没有直接使用Activity对象进行交互，而是使用一个token来标识，这个token是binder对象，因此可以方便地跨进程传递。Activity里面有一个成员变量mToken代表的就是它，token可以唯一地标识一个Activity对象，这里我们只不过替换了要启动Activity的信息，并没有替换这个token，所以系统并不知道运行的这个Activity并不是原来的那个。</p>
<h2 id="资源动态加载"><a href="#资源动态加载" class="headerlink" title="资源动态加载"></a>资源动态加载</h2><h3 id="系统资源加载分析"><a href="#系统资源加载分析" class="headerlink" title="系统资源加载分析"></a>系统资源加载分析</h3><p>宿主应用中正常情况下是无法访问插件资源，例如使用R或者getResource()的方式，因此如果如果宿主如果不存在资源ID，应用便会crash。LoadedApk对象表示了apk文件在内存中的表示，包括代码和资源，回顾LoadedApk的构建，其中需要ApplicationInfo作为参数，而这个ApplicationInfo是宿主的并不是插件的，而宿主的资源中并没有插件资源，因此插件apk无法使用插件的资源。<br>在代码中使用资源的形式一般都是R类或者getResources()这两种方式，其实R文件查找也是通过context.getResources()来查找ID来完成的，而context具体的实现类为ContextImpl：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> mResources;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到只是仅仅返回mResources成员变量，查找其如何创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里拿到了一个ResourcesManager,单例的，说明我们应用当中使用的都是同一套资源</span></span><br><span class="line"></span><br><span class="line">mResourcesManager = ResourcesManager.getInstance();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//LoadedApk对象中得到Resources对象</span></span><br><span class="line">Resources resources = packageInfo.getResources(mainThread);</span><br><span class="line">Resources resources = packageInfo.getResources(mainThread);</span><br><span class="line"><span class="keyword">if</span> (resources != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (activityToken != <span class="keyword">null</span></span><br><span class="line">|| displayId != Display.DEFAULT_DISPLAY</span><br><span class="line">|| overrideConfiguration != <span class="keyword">null</span></span><br><span class="line">|| (compatInfo != <span class="keyword">null</span> &amp;&amp; compatInfo.applicationScale</span><br><span class="line">!= resources.getCompatibilityInfo().applicationScale)) &#123;</span><br><span class="line"><span class="comment">//给resource赋值</span></span><br><span class="line">resources = mResourcesManager.getTopLevelResources(packageInfo.getResDir(),</span><br><span class="line">packageInfo.getSplitResDirs(), packageInfo.getOverlayDirs(),</span><br><span class="line">packageInfo.getApplicationInfo().sharedLibraryFiles, displayId,</span><br><span class="line">overrideConfiguration, compatInfo, activityToken);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给mResources赋值</span></span><br><span class="line">mResources = resources;</span><br></pre></td></tr></table></figure></p>
<p><code>ResourcesManager.getInstance()</code>是单例的这样保证了我们每个Context获取的都是同样的资源，resources通过getTopLevelResources方法赋值，而getTopLevelResources方法真正的获取资源的步骤，但主要分三步来创建Resources：</p>
<ol>
<li>创建AssetManager对象；</li>
<li>通过隐藏的addAssetPath方法将资源路径添加给AssetManager；</li>
<li>拿到AssetManager对象后，便可以创建真正的Resources对象；</li>
</ol>
<h3 id="插件如何拿到创建好的Resources资源呢-？"><a href="#插件如何拿到创建好的Resources资源呢-？" class="headerlink" title="插件如何拿到创建好的Resources资源呢 ？"></a>插件如何拿到创建好的Resources资源呢 ？</h3><ol>
<li><p>在使用前初始化好Resources资源 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建我们自己的Resource</span></span><br><span class="line">String apkPath = Environment.getExternalStorageDirectory().getAbsolutePath() + <span class="string">"/chajian_demo.apk"</span>;</span><br><span class="line"><span class="comment">//创建AssetManager</span></span><br><span class="line">assetManager = AssetManager.class.newInstance();</span><br><span class="line">Method addAssetPathMethod = assetManager.getClass().getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">addAssetPathMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">addAssetPathMethod.invoke(assetManager, apkPath);</span><br><span class="line">Method ensureStringBlocks = AssetManager.class.getDeclaredMethod(<span class="string">"ensureStringBlocks"</span>);</span><br><span class="line">ensureStringBlocks.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ensureStringBlocks.invoke(assetManager);</span><br><span class="line">Resources supResource = getResources();</span><br><span class="line">Log.e(<span class="string">"Main"</span>, <span class="string">"supResource = "</span> + supResource);</span><br><span class="line">newResource = <span class="keyword">new</span> Resources(assetManager, supResource.getDisplayMetrics(), supResource.getConfiguration());</span><br><span class="line">mTheme = newResource.newTheme();</span><br><span class="line">mTheme.setTo(<span class="keyword">super</span>.getTheme())</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写getResources和getAssets方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AssetManager <span class="title">getAssets</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> assetManager == <span class="keyword">null</span> ? <span class="keyword">super</span>.getAssets() : assetManager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> newResource == <span class="keyword">null</span> ? <span class="keyword">super</span>.getResources() : newResource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在插件Activity中记得重写getResources方法，毕竟默认使用宿主的Resource：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AssetManager <span class="title">getAssets</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(getApplication() != <span class="keyword">null</span> &amp;&amp; getApplication().getAssets() != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> getApplication().getAssets();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getAssets();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resources.<span class="function">Theme <span class="title">getTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(getApplication() != <span class="keyword">null</span> &amp;&amp; getApplication().getTheme() != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> getApplication().getTheme();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getTheme();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<ol>
<li><a href="http://blog.csdn.net/yulong0809/article/category/6745120" target="_blank" rel="noopener">插件化系列基础</a></li>
</ol>
</blockquote>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        

        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2017/05/Android插件化原理探索/" target="_blank" rel="external">https://hjw541988478.github.io/2017/05/Android插件化原理探索/</a>
        
    </div>
    
    <footer>
        <a href="https://hjw541988478.github.io">
            <img src="/img/avatar.jpg" alt="Garvin">
            Garvin
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AIDL/">AIDL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MultiProcess/">MultiProcess</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/插件化/">插件化</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://hjw541988478.github.io/2017/05/Android插件化原理探索/&title=《Android插件化原理探索》 — Garvin 杂记&pic=https://hjw541988478.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://hjw541988478.github.io/2017/05/Android插件化原理探索/&title=《Android插件化原理探索》 — Garvin 杂记&source=代理模式（委托模式）限制对象的直接访问，保护内部对象；
静态代理AIDL中asInterface方法中有应用到静态代理，如果不在同一进程就会返回Proxy..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://hjw541988478.github.io/2017/05/Android插件化原理探索/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Android插件化原理探索》 — Garvin 杂记&url=https://hjw541988478.github.io/2017/05/Android插件化原理探索/&via=https://hjw541988478.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://hjw541988478.github.io/2017/05/Android插件化原理探索/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/06/Java常用线程池理解/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Java常用线程池理解</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/04/AIDL基本使用理解/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">AIDL基本使用理解</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "Av3sk2Q4QhL7up87ziVVSeeS-gzGzoHsz",
            appKey: "hVI7cltsWA2q1fvsUNRWEJ4e",
            avatar: "retro",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Garvin &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://hjw541988478.github.io/2017/05/Android插件化原理探索/&title=《Android插件化原理探索》 — Garvin 杂记&pic=https://hjw541988478.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://hjw541988478.github.io/2017/05/Android插件化原理探索/&title=《Android插件化原理探索》 — Garvin 杂记&source=代理模式（委托模式）限制对象的直接访问，保护内部对象；
静态代理AIDL中asInterface方法中有应用到静态代理，如果不在同一进程就会返回Proxy..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://hjw541988478.github.io/2017/05/Android插件化原理探索/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Android插件化原理探索》 — Garvin 杂记&url=https://hjw541988478.github.io/2017/05/Android插件化原理探索/&via=https://hjw541988478.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://hjw541988478.github.io/2017/05/Android插件化原理探索/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACqElEQVR42u3a0U4kMQwEQP7/p7nHOwnt0G0nCydVntCyM0kFKTG2Pz7i8fll/Pt58p3n8Tzj17kODzw8PLz10pMl5kt5XmI+V75leHh4eO/hvTpRk2XNRv7mZD0vP8fDw8P7BbzZ4k5dGHh4eHj/Iy/PADy/7VR4jYeHh/dTvFng+7zcZJZ8+67nWvDw8PC6etNH++qf/flKfQ8PDw9vXVVPimHtIvJgep8yxsPDw7vBa8PZJDk7C6Y3CYhvtgkPDw/vKO9su1V7hezTEN98Hw8PD+8Crw1qk4N7X04rwuUYjIeHh3eWt/pXf1T4b9eQpHeH9T08PDy8ES9JOmzAs0B582Y8PDy8d/I2QXObgJildPNNx8PDw7vBS4LUtgy2KW4Vf4E8dYuHh4f3Ft7+UN4c92264eVVhIeHh3eZ15amZldIm8zNT/iXnRF4eHh4R3mb4v0mSZFfSKdau/Dw8PDO8vJcb3tYtyWu5Eqorxw8PDy8o7y8/H+qrNUCZluGh4eHd4/XFvufn0p+22KKcterefHw8PAu81rY2XD8bPMBHh4e3g1em7eYNQFsGrmirHObjMDDw8Nb8260rubLyvtL23IdHh4e3j3eLD3aBtPt9kWA503Bw8PDu8CbHdCzgtbZN+dP4eHh4d3g3WgO2BTP2kJaHXHj4eHhHeLNLoa6kH909oiNh4eHd5mXH9mzM7lNduznwsPDwzvL+yzH83a0adw2fVw3deHh4eFd4LXHbtIikE+cB+WzZ/Hw8PDu8WaXQZsOnrUUtGmIOrDGw8PDW/D2x33ehrW5hIosCx4eHt6v4W2O7Bw/u6gOXAx4eHh4F3ibGlPbkpWkgK/ce3h4eHiH8pyzVoD9ZdCuBA8PD+82b98+tQmv8xmT7bvSHYaHh4f3d/wBifhf9Mu+nkEAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


lazyScripts.push('//s95.cnzz.com/z_stat.php?id=1274482147&web_id=1274482147')

</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
