<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Garvin 杂记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hjw541988478.github.io/"/>
  <updated>2018-08-18T18:06:17.308Z</updated>
  <id>https://hjw541988478.github.io/</id>
  
  <author>
    <name>Garvin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>18.4Sum</title>
    <link href="https://hjw541988478.github.io/2018/08/18-4Sum/"/>
    <id>https://hjw541988478.github.io/2018/08/18-4Sum/</id>
    <published>2018-08-18T16:08:56.000Z</published>
    <updated>2018-08-18T18:06:17.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://leetcode.com/problems/4sum/description/" target="_blank" rel="noopener">https://leetcode.com/problems/4sum/description/</a></p><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p><p>Note:</p><p>The solution set must not contain duplicate quadruplets.</p><p>Example:</p><p>Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</p><p>A solution set is:<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]<br><a id="more"></a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>沿用3sum的思路，将数组升序后，逐个比较，第一层遍历到倒数第4个数，第二层遍历到倒数第3个数，最后两个只要找到求2Sum的方法便可以找到所有的情况，注意此处也可以优化的地方，重复的可以跳过比较。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">3</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">2</span>; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> l = j + <span class="number">1</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[l] + nums[r] == target) &#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));</span><br><span class="line">                        l ++;</span><br><span class="line">                        r --;</span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="number">1</span>]) &#123;</span><br><span class="line">                            l ++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>]) &#123;</span><br><span class="line">                            r --;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] + nums[l] + nums[r] &lt; target) &#123;</span><br><span class="line">                        l ++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r --;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/4sum/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/4sum/description/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;The solution set must not contain duplicate quadruplets.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;p&gt;Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.&lt;/p&gt;
&lt;p&gt;A solution set is:&lt;br&gt;[&lt;br&gt;  [-1,  0, 0, 1],&lt;br&gt;  [-2, -1, 1, 2],&lt;br&gt;  [-2,  0, 0, 2]&lt;br&gt;]&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://hjw541988478.github.io/categories/Leetcode/"/>
    
    
      <category term="3sum" scheme="https://hjw541988478.github.io/tags/3sum/"/>
    
  </entry>
  
  <entry>
    <title>16.3Sum Closet</title>
    <link href="https://hjw541988478.github.io/2018/08/16-3Sum-Closet/"/>
    <id>https://hjw541988478.github.io/2018/08/16-3Sum-Closet/</id>
    <published>2018-08-18T16:03:56.000Z</published>
    <updated>2018-08-18T18:06:24.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://leetcode.com/problems/3sum-closest/description/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum-closest/description/</a></p><p>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p>Example:</p><p>Given array nums = [-1, 2, 1, -4], and target = 1.</p><p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).<br><a id="more"></a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先升序排序，从头和尾往中靠拢，如果三数之和大于target，则右边缩进一位，否则左边扩大一位，边遍历的同时检查是否有更合适的数并记录。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> result = num[<span class="number">0</span>] + num[<span class="number">1</span>] + num[num.length - <span class="number">1</span>];</span><br><span class="line">       Arrays.sort(num);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> start = i + <span class="number">1</span>, end = num.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">               <span class="keyword">int</span> sum = num[i] + num[start] + num[end];</span><br><span class="line">               <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                   end--;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   start++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (Math.abs(sum - target) &lt; Math.abs(result - target)) &#123;</span><br><span class="line">                   result = sum;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/3sum-closest/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/3sum-closest/description/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;p&gt;Given array nums = [-1, 2, 1, -4], and target = 1.&lt;/p&gt;
&lt;p&gt;The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="https://hjw541988478.github.io/categories/Leetcode/"/>
    
    
      <category term="3sum" scheme="https://hjw541988478.github.io/tags/3sum/"/>
    
      <category term="TwoPointers" scheme="https://hjw541988478.github.io/tags/TwoPointers/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="https://hjw541988478.github.io/2017/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hjw541988478.github.io/2017/08/设计模式之单例模式/</id>
    <published>2017-08-02T12:52:00.000Z</published>
    <updated>2018-08-18T15:42:41.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h2><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>确保某个类只有一个对象的场景，例如日志类，访问 IO 和数据库资源。</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/08/设计模式之单例模式/singleton.png" alt="单例模式UML图" title="">                </div>                <div class="image-caption">单例模式UML图</div>            </figure><a id="more"></a><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>单例模式的实现有很多种不同的方式，包括饿汉式、懒汉式、双重锁式、静态内部类式、枚举式、容器式。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 静态单例，提前在类加载的时候初始化，保证线程安全。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IvoryTower</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 私有构造函数，保证外部没法初始化</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">IvoryTower</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 静态初始化对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IvoryTower INSTANCE = <span class="keyword">new</span> IvoryTower();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IvoryTower <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程安全，延迟加载，需要 synchronization 加锁同步</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeLazyLoadedIvoryTower</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ThreadSafeLazyLoadedIvoryTower instance;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ThreadSafeLazyLoadedIvoryTower</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 延迟加载，只有在被调用时，才会初始化</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ThreadSafeLazyLoadedIvoryTower <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> ThreadSafeLazyLoadedIvoryTower();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重加锁式"><a href="#双重加锁式" class="headerlink" title="双重加锁式"></a>双重加锁式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 双重加锁式</span></span><br><span class="line"><span class="comment">* &lt;p/&gt;</span></span><br><span class="line"><span class="comment">* http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</span></span><br><span class="line"><span class="comment">* &lt;p/&gt;</span></span><br><span class="line"><span class="comment">* Broken under Java 1.4.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> mortezaadi@gmail.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeDoubleCheckLocking</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 被volatile修饰的变量的值，不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而</span></span><br><span class="line">  <span class="comment">// 保证线程正确的处理该变量。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ThreadSafeDoubleCheckLocking instance;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 私有构造方法防止外部初始化</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ThreadSafeDoubleCheckLocking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 防止反射初始化</span></span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already initialized."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取单例的入口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadSafeDoubleCheckLocking <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本地变量能改善25%的性能</span></span><br><span class="line">    <span class="comment">// Joshua Bloch "Effective Java, Second Edition", p. 283-284</span></span><br><span class="line">    </span><br><span class="line">    ThreadSafeDoubleCheckLocking result = instance;</span><br><span class="line">    <span class="comment">// 检查单例是否创建，如果已创建直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 检查到单例还未创建，但不保证其他线程可能已经创建了单例，因此需要加锁同步再次检查</span></span><br><span class="line">      <span class="keyword">synchronized</span> (ThreadSafeDoubleCheckLocking.class) &#123;</span><br><span class="line">        <span class="comment">// 再次给本地变量赋值，检查是否已被其他线程创建，由于当前线程已被阻塞，如果此时不为空，直接将已创建的对象返回即可</span></span><br><span class="line">        result = instance;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 此时实例还未初始化，所以在此处进行初始化，实现单例</span></span><br><span class="line">          instance = result = <span class="keyword">new</span> ThreadSafeDoubleCheckLocking();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类式"><a href="#静态内部类式" class="headerlink" title="静态内部类式"></a>静态内部类式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 延迟初始化线程安全的单例，充分利用了类初始化的特点，也无需其他类似 volatile、synchronized 关键词限定，只有调用了 getInstance 的时候才会初始化。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializingOnDemandHolderIdiom</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">InitializingOnDemandHolderIdiom</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InitializingOnDemandHolderIdiom <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HelperHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HelperHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InitializingOnDemandHolderIdiom INSTANCE =</span><br><span class="line">        <span class="keyword">new</span> InitializingOnDemandHolderIdiom();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举式"><a href="#枚举式" class="headerlink" title="枚举式"></a>枚举式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 枚举式单例，写法简单，线程安全。</span></span><br><span class="line"><span class="comment">* Effective Java 2nd Edition (Joshua Bloch) p. 18</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumIvoryTower &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getDeclaringClass().getCanonicalName() + <span class="string">"@"</span> + hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容器式"><a href="#容器式" class="headerlink" title="容器式"></a>容器式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 注册到容器, 根据key获取对象.一般都会有多种相同属性类型的对象会注册到一个map中，典型的是在对 WMS，AMS 系统服务的获取能够体现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Singleton&gt; objMap = <span class="keyword">new</span> HashMap&lt;string Singleton&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Singleton instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!objMap.containsKey(key) ) &#123;</span><br><span class="line">        objMap.put(key, instance) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getService</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> objMap.get(key) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Android-源码实现"><a href="#Android-源码实现" class="headerlink" title="Android 源码实现"></a>Android 源码实现</h2><p>各种各样的系统服务，我们在使用到时采用的是<code>context.getSystemService(xxx)</code>的形式，其初始化和获取的实现类通过跟踪源码可以到<code>ContextImpl</code>中查看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Contex</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 1 : service容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, ServiceFetcher&gt; SYSTEM_SERVICE_MAP =</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;String, ServiceFetcher&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sNextPerContextServiceCacheIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2: 注册服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, ServiceFetcher fetcher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(fetcher <span class="keyword">instanceof</span> StaticServiceFetcher)) &#123;</span><br><span class="line">            fetcher.mContextCacheIndex = sNextPerContextServiceCacheIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        SYSTEM_SERVICE_MAP.put(serviceName, fetcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3: 静态语句块, 第一次加载该类时执行 ( 只执行一次, 保证实例的唯一性. )</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//  代码省略</span></span><br><span class="line">        <span class="comment">// 注册Activity Servicer</span></span><br><span class="line">        registerService(ACTIVITY_SERVICE, <span class="keyword">new</span> ServiceFetcher() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ActivityManager(ctx.getOuterContext(), ctx.mMainThread.getHandler());</span><br><span class="line">                &#125;&#125;);</span><br><span class="line">        <span class="comment">// 注册LayoutInflater service</span></span><br><span class="line">        registerService(LAYOUT_INFLATER_SERVICE, <span class="keyword">new</span> ServiceFetcher() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> PolicyManager.makeNewLayoutInflater(ctx.getOuterContext());</span><br><span class="line">                &#125;&#125;);</span><br><span class="line">        <span class="comment">// 代码省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4: 根据key获取对应的服务,</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据name来获取服务</span></span><br><span class="line">        ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name);</span><br><span class="line">        <span class="keyword">return</span> fetcher == <span class="keyword">null</span> ? <span class="keyword">null</span> : fetcher.getService(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ContextImpl 类为 Context 的实现类，在虚拟机第一次加载时会注册各种用到的服务，这些服务以键值对的形势存储在一个 HashMap 中，用户使用时只需要根据 key 来获取到对应的服务。系统核心服务以单例形式存在，减少资源消耗。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例模式实现的核心在于，将构造函数私有化，同时保证类在多线程、序列化和反序列化时能够只获取到唯一的实例。</p><ul><li>由于需要控制类的创建和生命周期，违背了 SRP（单一职责） 设计原则；</li><li>使用唯一的全局访问点，优化共享资源；</li><li>太够耦合，难以测试；</li><li>几乎无法实现单例类的子类，难以扩展；</li><li>Android 中持有 Context 对象，可能导致内存泄露；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/singleton/mr.simple" target="_blank" rel="noopener">Android 设计模式源码解析之单例模式</a></li><li><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">java-design-patterns 开源库</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模式介绍&quot;&gt;&lt;a href=&quot;#模式介绍&quot; class=&quot;headerlink&quot; title=&quot;模式介绍&quot;&gt;&lt;/a&gt;模式介绍&lt;/h2&gt;&lt;h3 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;#模式定义&quot; class=&quot;headerlink&quot; title=&quot;模式定义&quot;&gt;&lt;/a&gt;模式定义&lt;/h3&gt;&lt;p&gt;确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;确保某个类只有一个对象的场景，例如日志类，访问 IO 和数据库资源。&lt;/p&gt;
&lt;h2 id=&quot;UML图&quot;&gt;&lt;a href=&quot;#UML图&quot; class=&quot;headerlink&quot; title=&quot;UML图&quot;&gt;&lt;/a&gt;UML图&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;/2017/08/设计模式之单例模式/singleton.png&quot; alt=&quot;单例模式UML图&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;单例模式UML图&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="DesignPattern" scheme="https://hjw541988478.github.io/categories/DesignPattern/"/>
    
    
      <category term="DesignPattern" scheme="https://hjw541988478.github.io/tags/DesignPattern/"/>
    
      <category term="Singleton" scheme="https://hjw541988478.github.io/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之七大基本原则</title>
    <link href="https://hjw541988478.github.io/2017/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%83%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>https://hjw541988478.github.io/2017/07/设计模式之七大基本原则/</id>
    <published>2017-07-31T11:52:00.000Z</published>
    <updated>2018-08-18T15:43:36.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/07/设计模式之七大基本原则/designpattern_index.png" alt="七大原则" title="">                </div>                <div class="image-caption">七大原则</div>            </figure><a id="more"></a><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则（SRP）用于在类的粒度上，一个类只负责一个功能领域中相应职责。同时也应该看到一个类不应该承担太多的职责，这意味着被复用的可能性越小。当其中一个职责变化时，可能会影响到其他职责的运作，因此需要将不同的职责封装在不同的类中，如果多个职责总是同时发生改变，则可以将它们封装在同一类中。<br>作为高内聚、低耦合的指导，需要设计人员发现类的不同职责并将其分离，发现类的多重职责需要较强的分析设计能力。</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则（OCP）表示的是一个软件实体应该对扩展开放，对修改关闭，即软件实体应尽量在不修改原代码的情况下进行扩展。软件实体可以指一个软件模块、一个由多各类组成的局部结构或一个独立的类。<br>在软件的重构阶段或者需求的迭代阶段，使用抽象化设计，抽象化在具体的编程语言中可以是使用接口或者抽象类，无须修改已有的代码，灵活地对系统进行扩展，使得软件拥有良好的系统稳定性和延续性。</p><h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><p>里氏代换原则（LSP）指所有引用基类的地方必须能透明替换使用其子类的对象。在软件中将一个基类对象替换成其子类对象，那么程序将不会发生任何错误，反过来则不成立。<br>里氏代换原则是实现OCP的重要方式之一，由于使用基类对象的地方可以使用子类对象，因此可以使用基类类型来对对象定义，在运行时确定其子类类型，用子类对象来替换父类对象。需要注意的点：</p><ol><li>子类所有方法必须在父类中声明，为了系统的扩展性，如果父类没有子类方法的声明，那么无法使用父类类型的对象使用该方法；</li><li>尽量把父类设计成抽象类或者接口，让子类继承父类或实现父接口，然后在运行时进行替换；</li><li>Java在编译时期会对程序进行是否符合 LSP ，这只是纯语法意义上的检查；</li></ol><h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>依赖倒转原则（DIP）是系统抽象化的具体实现，抽象不依赖于细节，细节应当依赖于抽象，也就是说针对接口编程。一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多的方法，否则无法调用子类中增加的新方法。<br>在实现依赖倒转原则时，需要针对抽象层编程，将具体类的对象通过 DI 的方式注入其他对象中，DI 是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象，常用的注入方式有：构造注入、Setter 注入和接口注入。构造注入指通过构造函数来传入具体类的对象，Setter 注入指通过 Setter 方法来传入具体类的对象，接口注入指通过接口中声明的业务方法来传入具体类对象。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>接口隔离原则（ISP）指使用多个专门的接口，而不使用单一的总接口，即实现类不应该依赖不需要的对象。当一个接口太大时，应该把它分割成更细小的接口，使用该接口的类只需要知道与之相关的方法。对于接口的理解：</p><ol><li>按逻辑上划分可以看成一个类型所提供的所有方法特征的集合。接口的划分直接带来类型的划分，可以把接口理解成角色，一个接口代表一个角色，这个原则叫角色隔离原则；</li><li>注意控制接口的粒度，太小会导致系统中接口泛滥，当然也不能太大会违背接口隔离原则，一般而言，接口中只包含为某一类用户定制的方法。</li></ol><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>又称为组合/聚合原则（CARP），尽量使用组合，而不是继承达到复用目的。在 OOD 中，可以选择组合或通过继承来实现，但首先应该考虑的是组合，组合使系统更加灵活，降低类与类之间的耦合度，其次才考虑继承，使用继承时需要遵循里氏代换原则，降低复杂度。<br>继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，那么如果基类发生变化，子类的实现也不得不发生改变，缺乏足够的灵活性。</p><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>迪米特法则（LoD）指在一个软件实体应当尽可能少地与其他实体发生相互作用。一个对象只能与直接“朋友”交互，不要与非“朋友”直接交互，这样会降低系统的耦合度，一个对象的改变不会给太多其他对象的影响。<br>迪米特法则要求我们在设计系统时，应该尽可能减少对象之间的交互，如果两个对象不必彼此直接通信，那么这两个对象就不应该发生任何直接相互作用，如果其中 一个对象需要调用另一个对象的某一个方法，可以通过第三者转发这个调用。在类的划分时，应当尽量创建松耦合的类，类之间耦合度越低越利于复用，在类的设计上，只要有可能，应当设计成不变类，在对其他类引用上，一个对象对其他对象的引用应当降到最低。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><ol><li><a href="https://www.gitbook.com/book/quanke/design-pattern-java/details" target="_blank" rel="noopener">设计模式Java版</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;/2017/07/设计模式之七大基本原则/designpattern_index.png&quot; alt=&quot;七大原则&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;七大原则&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="DesignPattern" scheme="https://hjw541988478.github.io/categories/DesignPattern/"/>
    
    
      <category term="DesignPattern" scheme="https://hjw541988478.github.io/tags/DesignPattern/"/>
    
  </entry>
  
  <entry>
    <title>SO库热修复探究(Part3)</title>
    <link href="https://hjw541988478.github.io/2017/07/SO%E5%BA%93%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8E%A2%E7%A9%B6-Part3/"/>
    <id>https://hjw541988478.github.io/2017/07/SO库热修复探究-Part3/</id>
    <published>2017-07-25T13:50:00.000Z</published>
    <updated>2018-08-18T12:36:29.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SO-库加载原理"><a href="#SO-库加载原理" class="headerlink" title="SO 库加载原理"></a>SO 库加载原理</h2><p>Java 提供两个接口加载 so 库：</p><ul><li><code>System.loadLibrary(String libName)</code>：参数为so库名称，位于 apk 压缩文件中的 libs 目录，最后复制到 apk 安装目录下；</li><li><p><code>System.load(String pathName)</code>：参数为 so 库在磁盘中完整的路径，可以加载自定义外部 so 库文件；<br>其实最终都会调用 nativeLoad 这个 native 方法，这个方法参数为 so 库在磁盘中完整路径名。在 JNI 编程中，动态注册的 native 方法必须实现 JNI_OnLoad 方法，同时实现一个 JNINativeMethod[ ] 数组，静态注册的 native 方法必须是 Java+类完整路径+方法名 的格式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> -&gt;<span class="params">(JNI_OnLoad nativeMethods[] 匹配映射)</span> -&gt; 动态注册 <span class="keyword">void</span> <span class="title">test</span><span class="params">(env,jobject)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> -&gt;<span class="params">(<span class="number">1.</span> test第一次执行dvmResolvedNativeCass <span class="number">2.</span> hashtable中查找匹配findMethodInLib)</span> -&gt; 静态注册 <span class="keyword">void</span> Java_包名_类名<span class="title">_test</span><span class="params">(env,jobject)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>动态注册的 native 方法映射通过加载 so 库过程中调用 JNI_OnLoad 方法调用完成；</p></li><li>静态注册的 native 方法映射在 native 方法第一次执行的时候完成映射，当然前提是 so 库已经 load 过。<a id="more"></a><h2 id="SO-库热部署实时生效分析"><a href="#SO-库热部署实时生效分析" class="headerlink" title="SO 库热部署实时生效分析"></a>SO 库热部署实时生效分析</h2><h3 id="动态注册-native-方法实时生效"><a href="#动态注册-native-方法实时生效" class="headerlink" title="动态注册 native 方法实时生效"></a>动态注册 native 方法实时生效</h3>动态注册的 native 方法调用一次 JNI_OnLoad 方法都会重新完成一次映射，所以我们可以先加载原来的 so 库，再加载补丁 so 库，就能完成 Java 层 native 方法到 native 层 patch 后新方法的映射，实测 art 是没问题的，但是 Dalvik 无法实时生效，原因在于 Dalvik 第二次 load 补丁 so 库执行的仍然是原来 so 库的 JNI_OnLoad 方法，而非补丁 so 库的。<br>定位到主要的两个方法：</li><li>dlopen()：返回给我们一个动态链接库的句柄；</li><li>dlsym()：通过 dlopen 得到动态链接库句柄，来查找一个 symbol；<br>在 Dalvik 中 dlopen 的实现，源码在 /bionic/linker/dlfcn.cpp 中，调用关系：dlopen -&gt; do_dlopen -&gt; find_library -&gt; find_library_internal，其中有：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">soinfo* si = find_loaded_library(name);</span><br><span class="line"><span class="keyword">if</span> (si != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (si -&gt; flags &amp; FLAG_LINKED) &#123;</span><br><span class="line">           <span class="keyword">return</span>  si;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>find_loaded_library 方法判断 name 表示的 so 库是否加载过，如果加载过直接返回，如果没有加载过则进行加载。而其中判断是否已经加载过的是依赖 so 库的文件名作为 key，那么补丁 so 库的路径与原来 so 库就算不一样，也会看作是同一 so 库，这样执行的还是原来 so 库的 JNI_OnLoad 方法，ART是以完整路径作为 key 去查找加载的，自然也不存在这种问题。<br>所以解决 Dalvik 下的这个问题，可以对 so 进行改名，自然会重新加载。</p><h3 id="静态注册-native-方法生效"><a href="#静态注册-native-方法生效" class="headerlink" title="静态注册 native 方法生效"></a>静态注册 native 方法生效</h3><p>静态注册 native 方法的映射是在 native 方法第一次执行的时候就完成了映射，系统 JNI API 提供了解注册的接口，UnregisterNatives 函数会把 jclazz 所在类的所有 native 方法都重新指向为 dvmResolveNativeMethod，所以调用了 UnRegisterNatives 之后，不管静态注册还是动态注册的 native 方法都会重新去做映射。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patchNativeMethod</span><span class="params">(JNIEnv *env, jclass clz)</span> </span>&#123;</span><br><span class="line">     env -&gt; UnregisterNatives(clz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们知道了哪个类需要解注册 native 方法，然后 load 补丁 so 库之后，再次指向该 native 方法，但实际上，java 层的 native 方法可能映射到原 so 库方法，也有可能映射到补丁 so 库的新方法。<br>如果静态注册的 native 方法从未执行，首先尝试解析该方法，或者调用了 unregisterJNINativeMethods 解注册方法，那么该方法指向 meth -&gt; nativeFunc = dvmResolveNativeMethod，实际运行该方法的时候，执行的是 dvmResolveNativeMethod 函数，该函数主要完成 java 层 native 方法到 native 层的映射。其中具体涉及到的关键变量为 gDvm.nativeLibs ，它是一个全局变量，是一个 hashtable，存放着整个虚拟机加载 so 库的 SharedLib 结构指针，通过它找到对应 native 函数指针，如果找到就直接 return。</p><blockquote><p>c.hashtable 与 java.hashtable 异同点：<br>共同点：都是数组实现，容量超过默认值会进行扩容，都是对 key 进行 hash 计算后与 hashtable 的长度进行取模作为 bucket；<br>不同点：Dalvik 下 hashtable put/get 操作方法比 java hashmap 简单一些，java hashmap 要处理 hash 冲突的情况，一般情况下增加一个链表处理冲突，然后 get 实现会遍历这个链表 通过 equals 方法比较 value 是否一致进行查找，而在 dalvik 下 hashtable 的 put 实&gt; 现只是简单 的把指针下移直到下一个空节点，get实现则是根据 hash 值计算出 bucket 位置，通过 cmpFunc 比较值是否一致，不一致指针下移。<br>如果在对补丁 so 库重命名后，补丁 so 库在 hashtable 中的位置比原 so 库靠前，就可以修复，否则就无法修复。</p></blockquote><h3 id="SO-库实时生效方案总结"><a href="#SO-库实时生效方案总结" class="headerlink" title="SO 库实时生效方案总结"></a>SO 库实时生效方案总结</h3><ol><li>so 库为了兼容 Dalvik 动态注册的 native 方法的实时生效，必须对 so 文件改名；</li><li>针对 so 库静态注册的 native 方法的实时生效，需要先解注册静态注册的 native 方法，难点在于无法知道哪几个 native 方法发生了变更。假设我们知道静态注册的 native 方法需要解注册，重新 load 补丁 so 库有可能也无法生效不被修复；</li><li>如果补丁 so 库足够多足够大，在加载过程中，可能导致 JNI 层的 OOM；</li><li>如果补丁 so 库新增动态注册方法，而 dex 中没有相应方法，直接去加载会报 NoSuchMethodError 异常，具体逻辑在 dvmRegisterJNIMethod 中。此时只能冷启动生效。</li></ol><h2 id="SO-库冷部署重启生效方案"><a href="#SO-库冷部署重启生效方案" class="headerlink" title="SO 库冷部署重启生效方案"></a>SO 库冷部署重启生效方案</h2><h3 id="接口调用替换方案"><a href="#接口调用替换方案" class="headerlink" title="接口调用替换方案"></a>接口调用替换方案</h3><p>使用<code>SOPatchManager.loadLibrary</code>接口加载 so 库优先尝试加载 sdk 指定目录下的补丁 so：</p><ul><li>如果存在，则加载补丁 so 库而不去加载 apk 目录下的 so 库；</li><li>如果不存在 so，那么调用 System.loadLibrary 加载 apk 目录下的 so 库。<br>这个方案的优缺点：</li><li>优点：不需要对不同 sdk 版本兼容，因为所有 sdk 版本都有 System.loadLibrary 这个接口；</li><li>缺点：调用方需要替换 System 默认加载 so 库接口为 sdk 提供的接口，如果是已经编译混淆好的三方库的 so 库 patch，很难做到接口替换，无法修复三方包 so 库；</li></ul><h3 id="反射注入方案"><a href="#反射注入方案" class="headerlink" title="反射注入方案"></a>反射注入方案</h3><p><code>System.loadLibrary(&quot;native-lib&quot;)</code>，在加载过程中，最终传给 native 方法执行的参数是 so 库在磁盘中的完整路径，比如：<code>/data/app-lib/com.test.jni/libnative-lib.so</code>，so 库会在 <code>DexPathList.nativeLibraryDirectories/nativeLibraryPathElements</code> 变量所表示的目录下遍历搜索。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sdk &lt; 23, DexPathList.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FIle[] nativeLibararyDirectories;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String libraryName)</span> </span>&#123;</span><br><span class="line">     String fileName = System.mapLibraryName(libraryName);</span><br><span class="line">     <span class="keyword">for</span> (File directory : nativeLibraryDirectories) &#123;</span><br><span class="line">           String path = <span class="keyword">new</span> File(directory, fileName).getPath();</span><br><span class="line">            <span class="comment">// path文件存在同时可读，返回</span></span><br><span class="line">            <span class="keyword">if</span> (IoUtils.canOpenReadOnly(path)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> path;    </span><br><span class="line">            &#125;   </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>IoUtils.canOpenReadOnly(path)</code>返回 true 的前提必须 path 表示的 so 文件存在，我们可以采用反射注入方式，把我们补丁 so 库的路径插入到 nativeLibraryDirectories 数组的最前面，就可以达到加载的是补丁 so 库而不是原来 so 库。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sdk&gt;=23 DexPathList.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Element[] nativeLibraryPathElements;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String libraryName)</span> </span>&#123;</span><br><span class="line">     String fileName = System.mapLibraryName(libraryName);</span><br><span class="line">     <span class="keyword">for</span> (Element element : nativeLibraryPathElements) &#123;    </span><br><span class="line">             String path = element.findNativeLibrary(fileName);</span><br><span class="line">             <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="keyword">return</span> path;</span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 sdk23 以上使用的是Element类，与上面类似，我们只需要把补丁 so 库完整路径作为参数构建一个 Element 对象，插入到 nativeLibraryPathElements 数组最前面。<br>这种方案的特点：</p><ul><li>可以修复三方库的 so 库，同时接入方不需要强制侵入用户接口调用；</li><li>需要对 sdk 做兼容适配，以 sdk23 为分界线，findLibrary 接口实现已经发生变化；</li></ul><h2 id="如何正确复制补丁-SO-库"><a href="#如何正确复制补丁-SO-库" class="headerlink" title="如何正确复制补丁 SO 库"></a>如何正确复制补丁 SO 库</h2><p>如果支持64位并且 apk 文件 libs 目录中存在 arm64-v8a，则 使用 arm64-v8a，否则检查是否是 32 位系统，如果存在 armabi-v7a，则使用 armabi-v7a，否则只能使用 armabi，具体可以参考 PMS 加载 SO 库的过程。补丁 so 库文件放到补丁包的 libs 目录，libs 目录和 .dex 文件和 res 资源文件打包成一个压缩文件作为补丁包，libs 目录可能包含多个 abis 目录，所以需要选择最合适的 primaryCpuAbi，然后从 libs 目录下选择 primaryCpuAbi 子目录插入到 nativeLibraryDirectories/nativeLibraryPathElements 数组中。所以关键点在于如何选取 primaryCpuAbi，在 sdk 中：</p><ul><li>sdk&gt;=21 时，直接反射拿到 Application 对象的 primaryCpuAbi 即可；</li><li>sdk&lt;21 时，由于不支持 64 位，所以把 Build.CPU_ABI，Build.CPU_ABI2 作为 primaryCpuAbi 即可。<br>此后拿到 primaryCpuAbi 便可可以构造 PathClassLoader 加载 so 库。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从稳定性出发，使用反射注入的方案进行 SO 库修复，重启生效，更具有普遍性，但是实时生效的需求也可以做到部分，只是存在着限制。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653577702&amp;idx=1&amp;sn=1288c77cd8fc2db68dc92cf18d675ace&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">Android 动态链接库加载原理及 HotFix 方案介绍</a></li><li>阿里Android热修复技术原理.pdf</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SO-库加载原理&quot;&gt;&lt;a href=&quot;#SO-库加载原理&quot; class=&quot;headerlink&quot; title=&quot;SO 库加载原理&quot;&gt;&lt;/a&gt;SO 库加载原理&lt;/h2&gt;&lt;p&gt;Java 提供两个接口加载 so 库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;System.loadLibrary(String libName)&lt;/code&gt;：参数为so库名称，位于 apk 压缩文件中的 libs 目录，最后复制到 apk 安装目录下；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;System.load(String pathName)&lt;/code&gt;：参数为 so 库在磁盘中完整的路径，可以加载自定义外部 so 库文件；&lt;br&gt;其实最终都会调用 nativeLoad 这个 native 方法，这个方法参数为 so 库在磁盘中完整路径名。在 JNI 编程中，动态注册的 native 方法必须实现 JNI_OnLoad 方法，同时实现一个 JNINativeMethod[ ] 数组，静态注册的 native 方法必须是 Java+类完整路径+方法名 的格式。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; -&amp;gt;&lt;span class=&quot;params&quot;&gt;(JNI_OnLoad nativeMethods[] 匹配映射)&lt;/span&gt; -&amp;gt; 动态注册 &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(env,jobject)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; -&amp;gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; test第一次执行dvmResolvedNativeCass &lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; hashtable中查找匹配findMethodInLib)&lt;/span&gt; -&amp;gt; 静态注册 &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Java_包名_类名&lt;span class=&quot;title&quot;&gt;_test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(env,jobject)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态注册的 native 方法映射通过加载 so 库过程中调用 JNI_OnLoad 方法调用完成；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;静态注册的 native 方法映射在 native 方法第一次执行的时候完成映射，当然前提是 so 库已经 load 过。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="HotFix" scheme="https://hjw541988478.github.io/tags/HotFix/"/>
    
      <category term="SoLibHotFix" scheme="https://hjw541988478.github.io/tags/SoLibHotFix/"/>
    
  </entry>
  
  <entry>
    <title>资源热修复探究(Part2)</title>
    <link href="https://hjw541988478.github.io/2017/07/%E8%B5%84%E6%BA%90%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8E%A2%E7%A9%B6-Part2/"/>
    <id>https://hjw541988478.github.io/2017/07/资源热修复探究-Part2/</id>
    <published>2017-07-21T13:43:00.000Z</published>
    <updated>2018-08-18T15:42:47.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="资源热修复原理"><a href="#资源热修复原理" class="headerlink" title="资源热修复原理"></a>资源热修复原理</h2><h3 id="InstantRun分两步"><a href="#InstantRun分两步" class="headerlink" title="InstantRun分两步"></a>InstantRun分两步</h3><ol><li>构造新的 AssetManager，并反射调用 addAssetPath，把完整资源包加入到 AssetManager 中，这样得到一个含有所有新资源的 AssetManager；</li><li>找到所有之前引用到原有 AssetManager 地方，通过反射，把引用处替换为新的 AssetManager；<br>addAssetPath 在 native 层由 c++ 实现，通过传入资源包路径，先得到 resources.arsc，然后解析它的格式，存放在底层的 AssetManager 的 mResources 成员中：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> ResTable* mResources;</span><br></pre></td></tr></table></figure></li></ol><p>mResources 是一个 ResTable 结构体，其成员 mPackageGroups 为资源包的实体，包含所有解析过的资源包的集合，任何一个资源包都含有 resources.arsc，它记录了所有资源 id 分配情况以及资源中的所有字符串，以二进制形式存储，底层的AssetManager就是用来解析这个文件，把相关信息存储到 mPackageGroups 中。<br><a id="more"></a></p><h3 id="资源文件的格式"><a href="#资源文件的格式" class="headerlink" title="资源文件的格式"></a>资源文件的格式</h3><p>resources.arsc 文件实际上是一个个 ResChunk 拼接起来的，其结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ResChunk_header</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;</span><br><span class="line">    <span class="keyword">uint16_t</span> headerSize;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 type 字段可以知道这个 chunk 是什么类型的，从而知道如何解析这个 chunk，解析完成后，从chunk+size 的位置开始，得到下一个 chunk 的起始位置，这样一次读完整个文件的数据内容。<br>一般来说，一个 resources.arsc 包含若干个 package，不过默认情况下只含有一个 package，包含了所有的资源信息。<br>在 Android 中，资源编号是唯一的，由一个32位数字，十六进制如 0xPPTTEEEE，PP为 package id，TT为 type id，EEEE 为 entery id。</p><ul><li>package id：每个 package 对应类型为 RES_TABLE_PACKAGE_TYPE 的 ResTable_package 结构体，其 id 表示它的 package id；</li><li>type id：对应 RES_TATBLE_TYPE_SPEC_TYPE 的 ResTable_typeSpec 结构体，具体什么类型需要在 Type String Pool 中解析，一般有 attr、drawable、mipmap、layout字符串，一次对应的 id 为 1、2、3、4；</li><li>entry id：表示一个资源项，比如第一个为 0x000，第二个为 0x001，依次自动编号；</li></ul><h3 id="运行时资源解析"><a href="#运行时资源解析" class="headerlink" title="运行时资源解析"></a>运行时资源解析</h3><p>默认aapt工具打包的资源包的 package id 为 0x7f，系统资源包为 0x01，在 app 运行之前，系统已经为我们添加了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># android.app.ResourceMananger.java</span></span><br><span class="line"><span class="function">Resources <span class="title">getTopLevelResources</span><span class="params">(....)</span> </span>&#123;</span><br><span class="line">    AssestManager assets = <span class="keyword">new</span> AssetManager ();</span><br><span class="line">    <span class="keyword">if</span> ( resDir != null） &#123;</span><br><span class="line">           <span class="keyword">if</span> ( assets.addAssetPath(resDir) == <span class="number">0</span> ) &#123;</span><br><span class="line">                   <span class="keyword">return</span> null;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，这个 AssetManager 里面就已经包含了系统资源包和 app 的安装包，也就是 package id 为 0x01 和 0x 7f 的app安装包资源。<br>如果再次调用 addAssetPath 完整补丁包，由于补丁包也是 package id 也是 0x7f ，会发生什么呢？<br>在 Android L 之后是没问题的，会把后来的包添加到之前的包的同一个 PackageGroup 下面。而在解析的时候，会与之前的包比较同一个 type id 对应的类型，如果资源项目数不一致，会打出一条 warning log，但是仍旧加入到该类型的 TypeList 中。<br>在获取某个 Type 的资源时，从前往后遍历，也就是先获取原有安装包的资源，除非后面资源的 config 比前面更详细才会覆盖，而对于同一个 config 而言，补丁包的资源就永远无法生效了，所以在 Android L 以上版本，在原有的 AssetManager 直接加入补丁包是不起效的。而在 Android 4.4 以及以下版本， addAssetPath 只是把路径添加到 mAssetPath 中，真正解析资源包的逻辑在 app 第一次执行 AssetManager::getResTable 的时候 。而在执行到加载补丁代码的时候，getResTable以及执行过无数次了，所以也只是将路径添加到了 mAssetPath，并不会发生解析，也就是说，一定要一个全新的 AssetManager ，然后加入完整的资源包，替换掉原有的才行。</p><h2 id="资源修复解决方案"><a href="#资源修复解决方案" class="headerlink" title="资源修复解决方案"></a>资源修复解决方案</h2><p>既要保证补丁包足够小，不在运行时占用资源，又有不侵入打包流程。即：构造一个 package id 在 0x01~0x7f 之间的资源包，只包含改变的资源项，然后在原有的 AssetManager 中 addAssetPath 这个包。</p><ul><li>对于新增的资源，直接加入补丁包，然后在新代码里引用就可以了；</li><li>对于减少的资源，不使用就行；</li><li>对于修改的资源，视为新增资源，在打入补丁的时候，代码在引用处也会修改，也就是把原来使用的旧资源 id 变成新 id。</li></ul><h3 id="新增资源及其导致-id-偏移"><a href="#新增资源及其导致-id-偏移" class="headerlink" title="新增资源及其导致 id 偏移"></a>新增资源及其导致 id 偏移</h3><p>新增资源会导致所属 type 中在它们之后的资源 id 发生位移，比如 id 由 0x7f020002 变为 0x7f020003。新资源插入的位置是随机的，与 aapt 打包时解析 xml 的顺序有关，发生位移的资源不会加入 patch，但是在 patch 的代码中会调整 id 的引用处。</p><h3 id="内容发生改变的资源"><a href="#内容发生改变的资源" class="headerlink" title="内容发生改变的资源"></a>内容发生改变的资源</h3><p>重新编号新的 id ，并加入到 patch 中。</p><h3 id="删除了的资源"><a href="#删除了的资源" class="headerlink" title="删除了的资源"></a>删除了的资源</h3><p>不影响补丁包。</p><h3 id="对于-type-的影响"><a href="#对于-type-的影响" class="headerlink" title="对于 type 的影响"></a>对于 type 的影响</h3><p>如果 type0x01 的资源没有变化，那么 type0x01 的资源就不会加入到 patch 中，会使得后面的 type 的 id 往前移一位，因此 Type String Pool 的字符串也要修正，使得 0x01 的 type 指向 drawable，而不是原来的 attr。<br>所以复杂的地方在于如何构造 patch，分析流程：把新旧的资源包解开，分别解析 resources.arsc 文件，对比不同，然后重新打成带有新 package id 的资源包。</p><h2 id="优雅替换-AssetManager"><a href="#优雅替换-AssetManager" class="headerlink" title="优雅替换 AssetManager"></a>优雅替换 AssetManager</h2><p>在 Android L 以后，直接在原有 AssetManager 上应用 patch 就行，这样省去反射替换操作，提高效率，但在 Android KK 以下版本， addAssetPath 不会加载资源，但我们也不想重新构造 AssetManager 的方式加入 patch，所以看看源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># android/content/res/AssetManager.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AssetManager</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span> <span class="params">( )</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span> <span class="params">( )</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>init 方法用于在 native 层创建一个没有添加过的资源，并且 mResources 没有初始化的 AssetManager，然后再 addAssetPath，由于 mResources 没有初始化，这样就可以正常走到解析 mResources 逻辑，然后把资源 add 进去了；<br>destroy 方法用于释放加载了资源，析构它所有的成员；<br>实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Method initMeth = assetManagerMethod(<span class="string">"init"</span>);</span><br><span class="line">Method destroyMeth = assetManagerMethod(<span class="string">"destroy"</span>);</span><br><span class="line">Method addAssetPathMeth = assetManagerMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line"><span class="comment">// 析构 AssetManager</span></span><br><span class="line">destroyMeth.invoke(am);</span><br><span class="line"><span class="comment">// 重新构造 AssetManager</span></span><br><span class="line">initMeth.invoke(am);</span><br><span class="line"><span class="comment">// 置空 mStringBlocks</span></span><br><span class="line">assetManagerField(<span class="string">"mStringBlocks"</span>).set(am, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 重新添加原有 AssetManager 中加载过的资源路径</span></span><br><span class="line"><span class="keyword">for</span> (String path : loadedPaths) &#123;</span><br><span class="line">    addAssetPathMeth.invke(am, path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 patch 资源路径</span></span><br><span class="line">addAssetPathMeth.invoke(am, patchPath);</span><br><span class="line"><span class="comment">// 重新对 mStringBlocks 赋值</span></span><br><span class="line">assetManagerMethod(<span class="string">"ensureStringBlocks"</span>).invoke(am);</span><br></pre></td></tr></table></figure></p><p>mStringBlocks 记录着加载过得所有资源包的 String Pool，因此很多访问字符串是通过它找到的，如果不重新构造会崩溃。直接对原有 AssetManager 进行析构和重构，引用没有发生改变，避免了频繁修改，Instant Run 也是有优化空间的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述流程的优势：</p><ul><li>不侵入打包流程，直接对比新旧资源产生补丁资源包（对比修改 aapt）；</li><li>不下发完整包，补丁包只包含变动资源（对比 Instant Run）；</li><li>不需要运行时合成完整包，不占用运行时计算和内存（对比 Tinker）；<br>对资源修复的过程中，有个过程是查找旧的 id，替换成新的 id，如果恰巧使用到了 0x7f** 这样相等的值，那就有可能造成错误替换，但是罕见，不过也要注意它的存在。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li>阿里Android热修复技术原理.pdf</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;资源热修复原理&quot;&gt;&lt;a href=&quot;#资源热修复原理&quot; class=&quot;headerlink&quot; title=&quot;资源热修复原理&quot;&gt;&lt;/a&gt;资源热修复原理&lt;/h2&gt;&lt;h3 id=&quot;InstantRun分两步&quot;&gt;&lt;a href=&quot;#InstantRun分两步&quot; class=&quot;headerlink&quot; title=&quot;InstantRun分两步&quot;&gt;&lt;/a&gt;InstantRun分两步&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;构造新的 AssetManager，并反射调用 addAssetPath，把完整资源包加入到 AssetManager 中，这样得到一个含有所有新资源的 AssetManager；&lt;/li&gt;
&lt;li&gt;找到所有之前引用到原有 AssetManager 地方，通过反射，把引用处替换为新的 AssetManager；&lt;br&gt;addAssetPath 在 native 层由 c++ 实现，通过传入资源包路径，先得到 resources.arsc，然后解析它的格式，存放在底层的 AssetManager 的 mResources 成员中：&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mutable&lt;/span&gt; ResTable* mResources;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;mResources 是一个 ResTable 结构体，其成员 mPackageGroups 为资源包的实体，包含所有解析过的资源包的集合，任何一个资源包都含有 resources.arsc，它记录了所有资源 id 分配情况以及资源中的所有字符串，以二进制形式存储，底层的AssetManager就是用来解析这个文件，把相关信息存储到 mPackageGroups 中。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="HotFix" scheme="https://hjw541988478.github.io/tags/HotFix/"/>
    
      <category term="ResourceHotFix" scheme="https://hjw541988478.github.io/tags/ResourceHotFix/"/>
    
  </entry>
  
  <entry>
    <title>代码热修复探究(Part1)</title>
    <link href="https://hjw541988478.github.io/2017/07/%E4%BB%A3%E7%A0%81%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8E%A2%E7%A9%B6-Part1/"/>
    <id>https://hjw541988478.github.io/2017/07/代码热修复探究-Part1/</id>
    <published>2017-07-20T12:22:00.000Z</published>
    <updated>2018-08-18T15:44:44.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="热修复技术介绍"><a href="#热修复技术介绍" class="headerlink" title="热修复技术介绍"></a>热修复技术介绍</h2><h3 id="代码修复技术"><a href="#代码修复技术" class="headerlink" title="代码修复技术"></a>代码修复技术</h3><p>底层替换：已经加载的类直接替换原有方法，由于修改了原来的类，导致方法数的变化，索引无法正常工作，不稳定，可能产生无法预知的结果；<br>类加载：在 app 重新启动后让 classloader 加载新的类，由于已加载的类无法卸载，于是不重启无法加载新类，在重启以后，赶在业务逻辑之前抢先加载补丁的新类，达到热修复的目的。市场主流方案选择：</p><ul><li>QZoneFix：侵入打包流程，不优雅；</li><li>QFix：获取底层虚拟机函数，不稳定；</li><li>Tinker：全量dex加载，粒度过细，性能消耗过大；</li></ul><h3 id="资源修复"><a href="#资源修复" class="headerlink" title="资源修复"></a>资源修复</h3><ol><li>构造新的 AssetManager，反射调用 addAssetPath，把完整新资源包加入 AssetManager 中；</li><li>找到所有引用原 AssetManager 地方，通过反射，把引用处替换成新的。<br>优点：</li></ol><ul><li>只使用一个 package id 为 0x66 的资源包，该包只包含了改变了资源，然后直接在原 AssetManager 中 addAssetPath；</li><li>不修改 AssetManager 引用处；</li><li>不必下发完整包；</li><li>不需要在运行时合成完整包<br>；<a id="more"></a><h3 id="SO库修复"><a href="#SO库修复" class="headerlink" title="SO库修复"></a>SO库修复</h3>SO 库修复本质是对 native 方法的修复和替换。采用类似修复反射注入的方式，把补丁的路径插入到 nativeLibraryDirectories 数组的最前面，达到加载到的 so 库是补丁库，达到修复目的。</li></ul><h2 id="代码热修复技"><a href="#代码热修复技" class="headerlink" title="代码热修复技"></a>代码热修复技</h2><p>术### 底层热替换<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(smeth, dmeth, <span class="keyword">sizeof</span>(ArtMehod));</span><br></pre></td></tr></table></figure></p><p>不替换 ArtMethod 的成员，而是整个替换；由于 sizeof 计算可能有偏差，使用内部起止方法的地址差值作为 methSize 便可以解决问题；<br>这里关键点便是，忽略 ArtMethod 结构差异，使用统一的 memcpy，只要保证 ArtMethod 数组以线性结构排列，就可以适配。</p><h3 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h3><p>dex2oat 生成 AOT 机器码是会做一些检查和优化的，由于 dex2oat 编译机器码时确认了两个方法属于同一个类，所以便不会存在权限问题。<br>在补丁类访问同包名其他类，会存在权限问题，是因为补丁包使用的类加载器不是原来的 classloader，也只需要设置新类的 classloader 为原来的 classloader 便可以了。</p><h3 id="反射调用非静态方法"><a href="#反射调用非静态方法" class="headerlink" title="反射调用非静态方法"></a>反射调用非静态方法</h3><p>热替换的非静态方法，在反射调用时，由于 VerifyObjectlsClass 新旧类不匹配，导致检验不通过，而静态方法是在类级别上的，也就不需要接收对象实例作为参数，自然不会存在这个问题；</p><h3 id="及时生效的限制"><a href="#及时生效的限制" class="headerlink" title="及时生效的限制"></a>及时生效的限制</h3><p>只支持方法的替换，无法增加或减少方法以及成员字段的增加或减少。是因为补丁类中方法的增加或减少，导致 Dex 方法数的变化，从而导致索引的变化，这样访问方法时无法索引到正确的方法了。总之，2种限制情况：</p><ul><li>引起原有类结构变化的修改</li><li>修复的非静态方法会被反射调用时</li></ul><h2 id="Java知识基础"><a href="#Java知识基础" class="headerlink" title="Java知识基础"></a>Java知识基础</h2><h3 id="内部类编译"><a href="#内部类编译" class="headerlink" title="内部类编译"></a>内部类编译</h3><p>内部类会在编译期被编译为跟外部类一样顶级的类，非静态内部类持有外部类引用，而静态内部类不持有。</p><ol><li>内部类与外部类互相访问<br>外部类为了访问内部类私有域/方法，编译期会为自动类生产 access&amp;** 方法，用于返回其值或者相关方法给内部类使用；</li><li>热部署解决<br>避免自动生成 access&amp;*** 方法：</li></ol><ul><li>一个外部类如果有内部类，把所有 method/field 的 private 访问权限改成 protected 或者 default 或者 public；</li><li>内部类所有 method/field 的 private 权限改成 protected 或者默认权限；</li></ul><h3 id="匿名内部类编译"><a href="#匿名内部类编译" class="headerlink" title="匿名内部类编译"></a>匿名内部类编译</h3><ol><li>编译规则<br>匿名内部类的格式一般是外部类 &amp;numble，后面的 numble 是编译期根据该匿名内部类在外部类中出现的先后关系，依次累加命名；</li><li>解决方案<br>匿名内部类插入到外部类末尾是允许的，其他都是不可取的；</li></ol><h3 id="域编译"><a href="#域编译" class="headerlink" title="域编译"></a>域编译</h3><ol><li>静态域与非静态域<br>不支持 <clinit> 修复，这个方法在 Dalvik 虚拟机类加载的时候进行类初始化的时候调用，是 android 编译器自动合成的方法，静态 field 和代码块的初始化会被编译在 <clinit> 中；</clinit></clinit></li><li>静态 field 初始化与静态代码块<br>静态代码块和静态域初始化在 clinit 中的先后关系就是在源码中的先后关系，类加载初始化的时候，一个类仅加载一次，可能会导致加载一个类的情况：</li></ol><ul><li>new一个类的对象；</li><li>调用类的静态方法；</li><li>调用静态域的值；<br>执行流程：<code>dvmResolveClass-&gt;dvmLinkClass-&gt;dvmInitClass</code>，类的初始化在第三步，先对父类初始化，然后才调用本来的 clinit 方法；</li></ul><ol start="3"><li>非静态 field 初始化和非静态代码块<br>被翻译在 <init> 默认无参构造函数中，其执行顺序和源码顺序一致。如果是有参构造函数，每个有参构造函数都会执行一个非静态域和非静态代码块的初始化； <clinit> 在类加载初始化的时候被调用，<init> 在类对象初始化时候被调用，类似下面这样<code>String s = new String(&quot;test&quot;);</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new-instance v0, Ljava/lang/String;</span><br><span class="line">invke-direct &#123;v0&#125;, Ljava/lang/String; -&gt; &lt;init&gt;()V</span><br></pre></td></tr></table></figure></init></clinit></init></li></ol><p>首先分配堆内存，如果类没加载过则尝试加载类，然后指令调用类的init构造函数方法进行对象初始化；</p><ol start="4"><li>热部署解决方案<br>由于不支持 <clinit> 方法热部署，只能冷启动生效。但是非静态 field 和代码块被翻译到 <init> 中，可以热部署；</init></clinit></li></ol><h3 id="final-staitic-域编译"><a href="#final-staitic-域编译" class="headerlink" title="final staitic 域编译"></a>final staitic 域编译</h3><p>final static 域并没有翻译到 clinit 方法中；</p><ol><li>final static 域编译规则</li></ol><ul><li>final static 修饰的原始类型和 String 类型域（非引用类型），并不会翻译在 clinit 方法汇总，而是在 initSFields 方法中初始化；</li><li>final static 修饰的引用类型仍然在 clinit 中；</li></ul><ol start="2"><li>final static 域优化<br>如果一个 field 是常量，那么使用 static 修饰，其实只对原始类型和 String 类型有用，对于引用类型是没有任何优化的；</li><li>热部署方案</li></ol><ul><li>修改 final static 基本类型或者 String 类型（非引用类型）域，由于编译期间引用基本类型地方被立即数替换，引用到 String 类型（非引用类型）地方被常量池索引 ID 替换，所以可以热更；</li><li>修改 final static 引用类型域是不允许的，因为会翻译 clinit 方法，所以没法热部署；</li></ul><h3 id="方法编译"><a href="#方法编译" class="headerlink" title="方法编译"></a>方法编译</h3><ol><li>应用混淆方法编译<br>除了以上内部类/匿名内部类可能会造成 method 新增，混淆也有可能导致方法的内联和裁剪，导致 method 的增加或减少；</li><li>方法内联</li></ol><ul><li>方法没有被其他任何地方运用到；</li><li>方法简单，比如只有一行会被内联掉；</li><li>方法只被一个地方引用，会被替换掉；</li></ul><ol start="3"><li>方法裁剪<br>有参的方法会被裁剪成无参的方法，那么只能冷启动；</li><li>热部署解决<br>加上 -dontoptimize 参数即可；<br>混淆步骤：<br>input jars -&gt;shrink -&gt;optimize -&gt;obfuscate -&gt; preverify -&gt; output jars<br>optimize：不是入口的类和方法被设置为 private、static 或 final，无用参数被移除，一些方法可能会被内联或者裁剪，因此最好加上 -dontoptimize 参数；<br>preverification：对 .classs 预校验，在 .class 文件加上 StackMapTable 信息，这样在类校验阶段省去步骤，加载更快，android 中有自己的校验逻辑 dvmVerifyClass，所以最好加上 -dontpreverify 参数；</li></ol><h3 id="switch-case-语句编译"><a href="#switch-case-语句编译" class="headerlink" title="switch case 语句编译"></a>switch case 语句编译</h3><p>一个资源 id 肯定是 const final static 遍历，如果 switch case 语句被翻译成 packed-switch 指令，修改 smali 反编译流程，将 packed-switch 指令强转为 sparese-switch 指令，:pswitch_N 强转为 :sswitch_N 指令，然后替换资源 id，回编译 smali 为 dex，步骤为反编译-&gt;资源id替换-&gt;回编译；</p><h3 id="泛型编译"><a href="#泛型编译" class="headerlink" title="泛型编译"></a>泛型编译</h3><p>泛型完全在编译器中实现，由编译器执行类型检查和类型推断，然后生成普通的非泛型字节码，这种技术叫做擦除，编译器使用泛型类型保证类型安全；<br>Java5 才引入泛型，扩展虚拟机指令集是不可取的，所以采用完全在编译器中实现擦除方法。<br>泛型在编译器实现，生成的字节码是不包含泛型中的类型信息的，使用参数时会在编译时候去掉，这个过程称为类型擦除；</p><ol><li>类型擦除与多态的冲突和解决<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> T t;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> t;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.t = t;  </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> Number n;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Number <span class="title">get</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Number n)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> Number n;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Number <span class="title">get</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Number n)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>@Override<br>表明方法可以重写，也就是子类中的方法与父类的具有相同的方法名，返回类型和参数表。<br>受类型擦除影响，A 类中 set(T t) 在字节码中实际上是 set(Object t)，B的 set(Number n)方法参数不一样，所以此时类 B 的 set 方法为重载，而本意为重写，实现多态，可是类型擦除后变成了重载，这样存在了冲突。</p></blockquote><p>但实际上，JVM 在字节码中使用了 bridge 方法完成重写。可以得到的结论就是：<br>子类中真正完成重写基类方法的是编译器自动合成的 bridge 方法，而类 B 定义的 get 和 set 方法上面的 @Override 只不过是假象，bridge 方法内部实现调用重写的 print 方法。虚拟机巧妙的使用了桥方法解决了冲突问题。<br>一般情况下，方法的重载只能以方法参数表区分而无法以返回类型区分，但虚拟机却允许这么做，<br>是因为编译器为了泛型的多态的实现。</p><ul><li>泛型类型转换<br>编译器发现如果有一个变量的申明加上了泛型类型的话，编译器会自动加上 check-cast 类型转换，而不需要在源码中强制类型转换，只是因为类型转换编译器自动帮我们完成了而已。</li><li>热部署解决方案<br>在类型擦除中，如果 B extends A 变成了 B extends A，那么会增加对应的桥方法，此时新增方法，只能冷部署。<br>泛型方法内部实际上会生成一个 dalvik/annotation/Signature 系统注解，如果更换签名，泛型的类型擦除，方法的逻辑实际上没有发生任何变化，只是注解发生了变化而已。所以再热部署中，避免这种性能的修复。</li></ul><h3 id="Lambda-表达式编译"><a href="#Lambda-表达式编译" class="headerlink" title="Lambda 表达式编译"></a>Lambda 表达式编译</h3><p>java7 引入的一种表达式，类似匿名内部类，但是也有区别，也有可能导致方法的新增和减少。</p><ol><li>Lambda 编译规则<br>函数式接口主要特征，是一个接口，这个接口具有唯一的抽象方法，我们将满足这两个特性的接口称为函数式接口。java.lang.Runnable 和 java.util.Comparator 是典型的函数式接口，与匿名内部类的区别：</li></ol><ul><li>关键字 this 匿名类的 this 关键字指向匿名类，而 lambda 表达式的 this 关键字指向包围的 lambda 表达式的类；</li><li>编译方式，Java 编译器将 lambda 表达式编译成类的私有方法，使用 invokedynamic 字节码指令动态绑定这个方法，奖匿名内部类编译成外部类 &amp;numble 的新类；<br>比较匿名内部类与 Lambda 表达式的字节码可以发现：</li><li>编译期间自动生成私有静态的 lambda$main$*() 方法，这个方法的实现就是 lambda 表达式里面的逻辑；</li><li>invokedynamic 指令执行 lambda 表达式；</li><li>相比较匿名内部类的区别，没有生成外部类 &amp;numble 的新类；<br>invokedynamic 指令：指令执行时，实际上会去调用 java/lang/invke/LambdaMetafactory 的 metafactory 静态方法，这个静态方法实际上会在运行时生成实现函数式接口的具体类，然后具体类会调用私有静态 lambda$main$*() 方法。当然这只是对标准 JVM 的执行而言。<br>android 虚拟机中会先把 javac 编译成 .class，然后再通过 dx 工具优化成适合移动设备的 dex 字节码文件。但是如果要使用 Java8 语言特性，还需要新的 Jack 工具链才行。Jack 将源码编译成 Android 可读取的 Dalvik 可执行字节码，.jack 格式，它可以将源码直接编译成 Dalvik 字节码。<br>对比发现，旧版本的 javac ：<br>javac(.java -&gt; .class) -&gt; dx(.class -&gt; .dex)<br>新版本：<br>Jack(.java -&gt; .jack -&gt; .dex)<br>反编译 .dex 字节码对比 .class 字节码可以看到：<br>共同点：编译期间为外部类合成一个 static 辅助方法，内部逻辑实现 lambda 表达式；<br>不通点：1. class 字节码通过 invokedynamic 指令执行 lambda 表达式，而 .dex 字节码执行 lambda 表达式跟普通方法没差； 2. .class 字节码运行时生成新类，.dex字节码在编译期生成新类；</li></ul><ol start="2"><li>热部署解决方案<br>新增一个 lambda 表达式，会导致外部类新增一个辅助方法，所以不支持热部署，可以看到合成类名的规则 Test$$Lambda$void_main_java_lang_String_args_LamdaImp10.smali：外部类名+Lambda+Lambda 表达式所在方法的签名+LambdaImpl+出现的顺序号，构成的合成类。所以如果增加或者减少 Lambda 表达式，会导致类方法乱套。<br>那么对于只修改 lambda 内部逻辑，如果 lambda 表达式访问外部类的非静态 field/method 场景，如果生成的辅助类一开始没有持有外部类的引用，而修改后需要持有外部类的引用，这样就会导致热部署失败。</li></ol><ul><li>增加/减少一个 lambda 表达式会导致类方法错乱，所以热部署失败；</li><li>修改一个 lambda 表达式，可能导致新增 field，也会热部署失败。</li></ul><h3 id="访问权限检查对热替换的影响"><a href="#访问权限检查对热替换的影响" class="headerlink" title="访问权限检查对热替换的影响"></a>访问权限检查对热替换的影响</h3><ol><li>类加载阶段父类/实现接口访问权限检查<br>一个类的加载，必须经历 resolve -&gt; link -&gt; init 三个阶段，父类/实现接口权限检查发生在 link 阶段。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dvmLinkClass</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(...) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dvmCheckClassAccess(..interface)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!dvmCheckClassAccess(..super)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过源码可以看到，会先对实现的接口和父类进行访问权限检查，如果当前类和实现接口/父类是非 public，同时加载两者的 classLoader 不一样的情况下，会 return false。所以如果不进行任何处理的话，那么在类加载阶段就报错。</p><ol><li>类校验阶段访问权限检查<br>在单独的补丁 dex 中，如果需要加载这个 dex，必须进行 dexopt，dexopt 会执行 dvmVerifyClass 校验 dex 每个类，方法调用链为：dvmVerifyClass 校验类 -&gt; verifyMethod 校验类中方法 -&gt; (dvmVerifyCodeFlow -&gt; doCodeVerification) 对每个方法逻辑校验 -&gt;verifyInstruction 校验指令。所以可以看到，补丁类中如果引用了非 public 类，那么 verifyInstruction 方法执行的结果会更新为潜在的错误指令码，最后会抛出异常，程序中断。</li><li><code>&lt;clinit&gt;</code>方法<br>如果使用热部署的话，那么就没法改变类结构以及无法改变<clinit>方法，所以此时只能走冷启动生效。</clinit></li></ol><h2 id="冷启动类加载原理"><a href="#冷启动类加载原理" class="headerlink" title="冷启动类加载原理"></a>冷启动类加载原理</h2><h3 id="冷启动实现方案概述"><a href="#冷启动实现方案概述" class="headerlink" title="冷启动实现方案概述"></a>冷启动实现方案概述</h3><p>qzone：单独放一个帮助类在 dex 中让其他类调用，阻止类被打上 CLASS_ISPREVERIFIED 标志，最后加载补丁 dex 得到 dexFile 对象作为参数构建一个 Element 对象插入到 dexElements 数组最前面。没有合成完整包，产物小。Dalvik 下影响类加载性能，Art 下类地址写死，导致必须包含引用，补丁包大。<br>Tinker：提供 dex 差量包，整体替换 dex 方案。差量得到 patch.dex 与 classes.dex 合并得到完整dex，替换原来的 dexElements 数组。补丁包小，dex merge完成合并操作，不影响性能 dex 消耗在 vm heap 上，容易 OOM，导致合并失败。</p><p>dex merge ：<br>在 java 层面的，所有对象分配都是在 java heap 上，如果此时进程申请的 java heap 对象超过了 vm heap 的大小，那么进程可能会发生 OOM，导致合成失败。另外在 jni 层面 C++ new/malloc 申请的内存分配在 native heap 中，native heap 的增长并不受 vm heap 大小限制，如果 ram 不足也会被杀死闪退。如果从 dex merge 方面思考，只在 jni 层面进行 dex merge，可以提高 dex 合并成功率，避免 OOM。</p><h3 id="插桩实现前因后果"><a href="#插桩实现前因后果" class="headerlink" title="插桩实现前因后果"></a>插桩实现前因后果</h3><p>加载一个 dex 文件到本地内存的时候，如果不存在 odex 文件，那么首先会执行 dexopt，dexopt 的入口在 dalvik/opt/OptMain.cpp 的 main 方法中，最后调用 verifyAndOptimizeClass 执行真正的 verify/optimize 操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verifyAndOptimizeClass</span><span class="params">(....)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (doVerify) &#123;</span><br><span class="line">             <span class="keyword">if</span> (dvmVerifyClass(clazz)) &#123;</span><br><span class="line">                      ( (DexClassDef*) pClassDef) -&gt; accessFlags |= CLASS_ISPREVERIFIED;            </span><br><span class="line">                      verified = <span class="keyword">true</span>;</span><br><span class="line">             &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (doOpt) &#123;</span><br><span class="line">              bool needVerify = (gDvm.dexOptMode == OPTIMIZE_MODE_VERIFIED || gDvm.dexOptMode == OPTIMIZE_MODE_FULL);</span><br><span class="line">              <span class="keyword">if</span> (!verified &amp;&amp; needVerify() &#123;</span><br><span class="line">                    ....</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dvmOptimizeClass(clazz, <span class="keyword">false</span>);</span><br><span class="line">                    ( (DexClassDef*)pClassDef) -&gt;accessFlags |= CLASS_ISOPTIMIZED;</span><br><span class="line">              &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>apk 第一次安装的时候，会对原 dex 执行 dexopt，假如只有一个 dex，所以 dvmVerifyClass(clazz) 结果为 true。所以 apk 中所有的类都会被打上 CLASS_ISPREVERIFIED 标志，接下来执行 dvmOptimizeClass，接着被打上 CLASS_ISOPTIMIZED 标志。</p><ul><li>dvmVerifyClass：类校验，防止类被篡改，校验类的合法性。如果所有的类的所有方法中直接引用到的类（第一层）和当前类在同一个 dex 中的话，dvmVerifyClass 会返回 true。</li><li>dvmOptimizeClass：类优化，把部分指令优化成虚拟机内部指令，比如 invoke- 变成 invoke–quick，quick 指令从类的 vtable 表中直接取，vtable 是类的所有方法的一张大表，加快执行速率。<br>假如 A 类是补丁类，所以补丁 A 类在单独的 dex 中，类 B 中某个方法引用到类 A，所以此时会解析类 A :<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ClassObject * dvmResolveClass( ... ) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 如果类被打上了 CLASS_ISPREVERIFIED 标志</span></span><br><span class="line">        <span class="keyword">if</span> ( !fromUnverifiedConstant &amp;&amp; IS_CLASS_FLAG_SET(referrer, CLASS_ISPREVERIFIED)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (referrer -&gt; pDvmDex != resClassCheck -&gt; pDvmDex &amp;&amp; resClassCheck -&gt; classLoader != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                    dvmThrowIllegalAccessError(<span class="string">"Class ref in pre-verified class resolved to unexpected implementation"</span>);</span><br><span class="line">                    <span class="keyword">return</span> NULL;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>由于类 B 被打上了 CLASS_ISPREVERIFIED 标志，接下来 referrer 是类 B，resClassCheck 是补丁类 A，他们属于不同的 dex，所以 dvmThrowIllegalAccessError。为了解决这个问题，一个单独无关帮助类放在一个单独的 dex 中，原 dex 中所有类的构造函数都引用这个类，一般实现方法都是侵入 dex 打包流程，利用 .class 字节码修改技术，在所有 .class 文件的构造函数中引入这个帮助类，插桩由此而来。又由于 dvmVerifyClass 类校验返回 false，原 dex 中所有类都没有 CLASS_ISPREVERIFIED 标志，因此解决运行时的这个异常。<br>但是插桩会带来严重的效率问题，在 Dalvik 虚拟机中，一个类的加载一般分为三个阶段：dvmResolveClass -&gt; dvmLinkClass -&gt; dvmInitClass。dvmInitClass 阶段在类解析完毕开始初始化，这个方法主要完成父类的初始化，当前类的初始化，static 变量初始化赋值等。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dvmInitClass</span><span class="params">(ClassObject* clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (clazz -&gt; status &lt; CLASS_VERIFIED) &#123; <span class="comment">// 如果类还未打上 CLASS_ISPREVERIFIED 标志</span></span><br><span class="line">            clazz -&gt; status = CLASS_VERIFYING;</span><br><span class="line">            <span class="keyword">if</span> (!dvmVerifyClass(clazz)) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            clazz -&gt; status = CLASS_VERIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果类还没打上 CLASS_ISOPTIMIZED 标志</span></span><br><span class="line">        <span class="keyword">if</span> (!IS_CLASS_FLAG_SET(clazz, CLASS_ISOPTIMIZED) &amp;&amp; !gDvm.optimizing) &#123;</span><br><span class="line">            dvmOptimizeClass(clazz, essentialOnly);</span><br><span class="line">            SET_CLASS_FLAG(clazz, CLASS_ISOPTIMIZED);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类在初始化时，如果类未被打上 CLASS_ISPREVERIFIED/CLASS_ISOPTIMIZED 标志，那么会进行 verify 和 optimize 操作。正常情况下，这两个操作是在 apk 第一次安装执行 dexopt 进行的，而类的 verify 是很重的，会对所有方法的所有指令进行校验，如果同时加载大量类的话，耗时会被放大，影响效率了。</p><h3 id="插桩导致类加载性能影响"><a href="#插桩导致类加载性能影响" class="headerlink" title="插桩导致类加载性能影响"></a>插桩导致类加载性能影响</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/07/代码热修复探究-Part1/dexopt.jpg" alt="dexopt过程" title="">                </div>                <div class="image-caption">dexopt过程</div>            </figure><p>如果采用插桩所有类非 preverify，导致 verify 和 optimize 会在加载类时出发。经过数据测试发现，平均每个类 verify + optimize 耗时并不长，而且每个类只会有一次，但应用启动时同时加载大量类，容易白屏。</p><h3 id="避免插桩的-QFix-方案"><a href="#避免插桩的-QFix-方案" class="headerlink" title="避免插桩的 QFix 方案"></a>避免插桩的 QFix 方案</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/07/代码热修复探究-Part1/skip_dvmResolveClass.png" alt="dvmResolveClass绕过" title="">                </div>                <div class="image-caption">dvmResolveClass绕过</div>            </figure><p>想让 dvmDexGetResolvedClass 返回不为 null，只需调用过一次 dvmDexSetResolvedClass(pDvmDex, classIdx, resClass); 就行，举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">               A.a();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要 patch 的是类 A，所以类 A 被打入到独立的 dex 中。当执行到类 B 的 test 方法时，会去解析类 A，此时 dvmResolveCLass(const ClassObject* referrer, u4 classIdx, bool fromUnverifiedConstant) :</p><ul><li>referrer：实际上是类 B</li><li>classIdx：类 A 在原 dex 文件结构的索引 id</li><li>fromUnverifiedConstant：是否 const-class/instance-of 指令<br>此时调用 A 的静态 a 方法，invoke-static 指令不属于 const-class/instance-of 任意一个。不做处理的话，dvmDexGetResolvedClass 一开始是 null 的，然后 A 从补丁 dex 解析加载，B 是在原 dex 中，A 在补丁dex 中，所以 B -&gt; pDvmDex != A -&gt; pDvmDex，接下来抛异常。所以需要修改的地方在于，一开始的时候，把补丁 A 类添加到原来 dex(pDvmDex) 的 pResClasses 数组中。具体实现：</li><li>preResolveClz：需要 patch 的类 A 描述符，为了调试加上而已；</li><li>refererClz：需要 patch 的类 A 所在 dex 的人和一个类描述符，不限定必须是引用补丁类 A 的某个类，实际上只要是同一个 dex 任何一个即可。</li><li>classIdx：需要 patch 的类 A 在原 dex 文件中的索引 id。<br>然后通过 dlopen 拿到 libdvm.so 库的句柄，再通过 dlsym 拿到 so 库的 dvmResolveClass/dvmFindLoadedClass 函数指针。首先需要预加载引用类 android/support/annotation/AnimRes，这样 dvmFindLoadedClass(“android/support/annotation/AnimRes”) 才不会为 null ， dvmFindLoadedClass 执行结果得到的 ClassObject 作为第一个参数执行 dvmResolveClass(AnimRes, 2425, true) 即可。看看解决方案：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jboolean <span class="title">resolveColdPatchClasses</span><span class="params">(JNIEnv *env, jclass clz, jstring preResolveClz, jstring refererClz, jlong classIdx, <span class="keyword">dexstuff_t</span> *dexstuff)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 先调用 dvmFindLoadedClass</span></span><br><span class="line">    ClassObject *refererObj = dexStuff-&gt;dvmFindLoadedClass_fnPtr(JString2CStr(env, refererClz));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(refererObj-&gt;descriptor) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再调用 dvmResolveClass</span></span><br><span class="line">    ClassObject *resolveClass = dexStuff -&gt; dvmResolveClass_fnPtr(refererObj, classIdx, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(resolveClass-&gt;descriptor) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> JNI_FALSE;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>无需 hook 系统方法，直接在 native 层调用，无需插桩，需要注意的是：</p><ul><li>dvmResolveClass 的第三个参数 fromUnverifiedConstant 必须为 true；</li><li>apk 多 dex 情况下，dvmResolveClass 第一个参数 referrer 类必须跟需要 patch 的类在同一个 dex，但是无需存在引用关系，任何一个在同一个 dex 中的类都可以作为 referer；</li><li>referer 类必须提前加载；<br>然而 QFix 方案是在 dexopt 后进行绕过的，dexopt 会改变原先的很多逻辑，许多 odex 层面的优化会写死字段和方法的访问便宜，会导致严重的 BUG。</li></ul><h3 id="Art-下冷启动实现"><a href="#Art-下冷启动实现" class="headerlink" title="Art 下冷启动实现"></a>Art 下冷启动实现</h3><p>为了减少补丁包的大小，并没有为热部署和冷启动分别准备补丁，而是同一个热部署模式下的补丁能降级走冷启动，所以无需 dex merge。为了解决 Art 下类地址写死的问题， tinker 通过 dex merge 一个新的完整新 dex 替换就的 dexElements 数组。但事实上，Art 虚拟机默认支持多 dex 加载了。来具体分析 DexFile.loadDex 把一个 dex 文件解析到加载到 native 内存都发生了什么，都是调用了 DexFile.openDexFileNative 这个 native 方法。openDexFileNative -&gt; dvmJarFileOpen：<br>Dalvik 下：<br>static const char* kDexInJarName = “classes.dex”，明显 Dalvik 尝试加载一个压缩文件只会把 classes2.dex 加载到内存，如果存在着多 dex，那么会被忽略掉。<br>Art 下：<br>DexFile_openDexFileNative -&gt; openDexFilesFromOat -&gt;LoadDexFiles：<br>Art 下面可以看到默认支持加载多 dex，优先加载 primary dex，即 classes.dex，后续加载其他dex。所以得到的 Art 下冷启动方案：把补丁命名为 classes.dex，原 APK 中的 dex 一次名为 classes(2,3,4..）.dex 就好，然后一起打包成一个压缩文件。然后 DexFile.loadDex 得到 DexFile 对象，最后把 DexFile 对象替换旧的 dexElements 数组就好。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/07/代码热修复探究-Part1/tinker_new_sol.png" alt="新的Art下补丁包方案" title="">                </div>                <div class="image-caption">新的Art下补丁包方案</div>            </figure><br>需要注意的是：</p><ul><li>补丁 dex 必须命名为 classes.dex；</li><li>loadDex 得到的 DexFile 完整替换掉 dexElements 数组而不是插入；</li></ul><h3 id="其他点"><a href="#其他点" class="headerlink" title="其他点"></a>其他点</h3><p>DexFile.loadDex 尝试把一个 dex 文件解析并加载到 native 内存，在加载到 native 内存之前，如果 dex 不存在对应的 odex，那么 Dalvik 下会执行 dexopt，Art 下会执行 dexoat，最后得到的都是优化后的 odex，实际上虚拟机执行的也是 odex 而不是 dex。<br>如果 dex 足够大，那么 dexopt/dexoat 是很耗时的，Dalvik 影响比较小，因为 loadDex 仅仅是补丁包，但 Art 影响还是很大的，因为 loadDex 是补丁 dex 和原 dex 合并成的完整压缩包，所以 dexoat 非常耗时，所以如果优化后的 odex 没生成完整的 odex 时，会一直阻塞主线程。<br>所以，我们可以把 loadDex 当做一个事务来看，如果被打断，则删除 odex 文件，重启的时候发现存在 odex 文件，loadDex 完后，反射注入 dexElemens 数组，实现 patch，如果不存在 odex 文件，则重启子线程 loadDex，重启后再生效。再者为了安全性考虑，我们再虚拟机执行 odex 的时候，还需要对 odex 文件进行 md5 完整性校验，如果不匹配，重新生成 odex 文件。</p><h3 id="完整方案考虑"><a href="#完整方案考虑" class="headerlink" title="完整方案考虑"></a>完整方案考虑</h3><p>Dalvik 下采用全量 dex 方案，Art 下，由于默认支持多 dex 加载， 把补丁dex 作为主dex加载。</p><h2 id="多态对冷启动类加载影响"><a href="#多态对冷启动类加载影响" class="headerlink" title="多态对冷启动类加载影响"></a>多态对冷启动类加载影响</h2><h3 id="重新认识多态"><a href="#重新认识多态" class="headerlink" title="重新认识多态"></a>重新认识多态</h3><p>实现多态的技术叫做动态绑定，指在执行期间判断引用对象的实际类型，根据其实际类型调用相应方法。一般指非静态非 private 方法，field 和 静态方法不具有多态性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A b = <span class="keyword">new</span> B()；</span><br></pre></td></tr></table></figure></p><p>我们来分析下一个多态对象的实现，B 是 A 的子类，在执行 new 实例化 B 之后，尝试加载类 B，方法调用链 dvmResolveClass -&gt; dvmLinkClass -&gt; createVtable，此时类 B 创建一个 vtable，其实虚拟机中加载每个类都会为这个类生成一张 vtable 表，vtable 表就是当前类所有 virtual 方法的一个数组，当前类和所有继承父类的 public/protected/default 修饰的方法是可以被继承的。 private static 不属于。也就是说子类 vtable 的大小，等于子类 virtual 方法数 + 父类 vtable 大小：</p><ul><li>整个复制父类 vtable 到子类的 vtable；</li><li>遍历子类的 virtual 方法集合，如果方法原型一致，说明是重写父类方法，子类重写方法覆盖掉 vtable 中父类方法；</li><li>方法原型一致，则追加到 vtable 末尾；<br>如果父类A，vtable 为 vtable[0]=A.a_t1，vtable[1]=A.a_t2，那么子类B vtable为 vtable[0] = B.a_t1，vtable[1] = A.a_t2 ，vtable[2] =B.b_t1；而 field/static 为啥不具有多态性，是因为当前遍历的引用类型查找而不是从实际类型中查找，如果找不到父类才会递归查找。</li></ul><h3 id="冷启动方案限制"><a href="#冷启动方案限制" class="headerlink" title="冷启动方案限制"></a>冷启动方案限制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_addMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            A obj = <span class="keyword">new</span> A();</span><br><span class="line">            obj.a_t2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">void</span> a_t1 -&gt; print <span class="string">"a_t1"</span>;</span><br><span class="line">        <span class="keyword">void</span> a_t2 -&gt; print <span class="string">"a_t2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复后新增了 a_t1 方法，运行后发现输出的竟然是 “a_t1”，重新分析下原因：<br>dex 文件第一次加载的时候会进行 dexopt，包含了两个过程：verify + optimize；其中 optimize 过程指在优化虚拟机指令，重写 invoke-virtual 为 invoke-virtual-quick，紧接着跟着立即数，就是方法在 vtable 的索引值。<br>invoke-virtual-quick 相比 invoke-virtuak 效率更高，直接从实际类型 vtable 取，省去了 dvmResolveMethod 从变量引用类型到 vtable 索引 id的过程。所以可以理解错乱的原因是因为，在 odex 中，调用此方法的立即数对应了 patch 后的 a_t1 方法。</p><h3 id="终极解决方案"><a href="#终极解决方案" class="headerlink" title="终极解决方案"></a>终极解决方案</h3><p>由于多态的影响，QFix 无法进一步实施，可能也只能像 tinker 一样完整 dex 方案解决了。利用 google 已经开源的 dexmerge 方案，把补丁 dex 和原 dex 合并才完整的 dex，但也要考虑到 65535 方法数异常，内存不足导致失败，毕竟完整的 dex 合成在移动端进行还是相对复杂的。</p><h2 id="Dalvik下完整-DEX-方案的探索"><a href="#Dalvik下完整-DEX-方案的探索" class="headerlink" title="Dalvik下完整 DEX 方案的探索"></a>Dalvik下完整 DEX 方案的探索</h2><h3 id="冷启动类加载修复"><a href="#冷启动类加载修复" class="headerlink" title="冷启动类加载修复"></a>冷启动类加载修复</h3><p>最早的实现方案是 Q-Zone 提出的 dex 插入方案，主要思想是，插入新 dex 到 ClassLoader 索引路径的最前面，这样在 load 一个 class 的时候，会被优先找到补丁中的。Tinker 和 QFix 在此基础上做了改进，但遇到的共同的问题都是，如何解决在 Dalvik 下类的 pre-verify 问题。<br>比较三大框架：</p><ul><li>Q-Zone 处理方式是，在每个类中插入一个来自其他 dex 的 hack.class，由此让所有类都无法满足 pre-verified 条件；</li><li>Tinker 的方式，合成全量 Dex 文件，这样所有 class 都在全量 dex 中解决，消除 class 重复带来的冲突；</li><li>QFix 的方式，取得虚拟机中某些底层函数，提前 resolve 所有补丁类，绕过 pre-verify 检查；<br>总结可以发现，Q-Zone 方案会侵入打包流程，实现并不优雅，而 QFix 方案需要获取底层虚拟机函数，不够稳定可靠，而且比较大的问题是无法新增 public 函数。现在看来 Tinker 全量合成完整新 dex 是个不错的方案，但是缺点在于粒度过细，实现复杂，性能消耗严重。</li></ul><h3 id="新的全量-Dex-方案"><a href="#新的全量-Dex-方案" class="headerlink" title="新的全量 Dex 方案"></a>新的全量 Dex 方案</h3><p>思路就是原来的 dex 和 patch 里的 dex 重新合并成一个，对于补丁中变动的类，把原来基线包 dex 里面的已有的 class 去掉，也就是补丁 + 去除补丁类的基线包。<br>在 Android 原生的 multi-dex 中，把一个 apk 所有类拆分成 classes.dex、classes2.dex … classesN.dex，每个 dex 只包含了部分类的定义，但单个 dex 也是可以加载的，只要把所有的 dex 都 load 进去，本 dex 中不存在的类就可以在运行期间在其他 dex 中找到。<br>在基线包 dex 里面在去掉了补丁 class 后，基线包 dex 里就只包含不变的 class ，而这些不变的 class 要用到补丁中新 class 时会自动找到补丁dex，补丁包新 class 在需要用到不变的 class 时也会找到基线包 dex 的 class，这样的话，基线包里面不使用补丁类的 class 仍旧可以按照原来的逻辑做 odex ，最大化保证 dexopt 效果。<br>这样的话，我们不再需要像传统合成的思路判断类的增加和修改情况，而且也不需要处理合成时方法数超过的情况，对于 dex 结构也不需要破坏性重构，已经完全把问题简化为了如何在基线包 dex 里面去掉补丁包包含的所有类。<br>观察 DexHeader 结构体，可以取得 dex 的各个属性，取得 class_defs 属性，在我们解析这个 dex 的时候，移除定义的入口，而对于 Class 的具体内容不进行删除，可以最大可能地减少 offset 的修改。一个类所有的 DexClassDef ，也就是类定义，是从 pHeader-&gt;classDefsOff 偏移处开始的，一个接一个地线性排列，一个 dex 里面一共有 pHeader -&gt; classDefsSie 这个类定义。这样我们这可以找到 pHeader-&gt;classDefsOff 偏移处，一个个遍历所有 DexClassDef，如果 DexClassDef 的类名包含在我们补丁中就把它移除。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/07/代码热修复探究-Part1/header_classesdef_remove.png" alt="Dex 中 ClassDef 的移除" title="">                </div>                <div class="image-caption">Dex 中 ClassDef 的移除</div>            </figure><br>接着只要修改 pHeader-&gt;classDefsSize，变成去除补丁类之后的数目即可。而对于类的实体及其他 dex 信息不做移除，这样会把这个被移除类的无用信息残留在 dex 中，并不会有多大影响。</p><h3 id="对于-Application-处理"><a href="#对于-Application-处理" class="headerlink" title="对于 Application 处理"></a>对于 Application 处理</h3><p>Application 作为 app 的入口，在进入到替换完整的 dex 之前，一定会通过 Application 的代码，因此，Application 必然是加载在原来的老 dex 里面，只有在补丁加载后使用的类，会在新的完整 dex 里面找到。因此在加载补丁后，如果 Application 类使用了新 dex 里的类，由于不在同一个 dex ，如果 Application 被打上了 pre-verified 标志，会抛异常：java.lang.IllegalAccessError：Class ref in pre-verified class resolved unexpected implementation. 解决方法为清除 pre-verified 标志，类的标志位于 ClassObject 的accessFlags 成员，而 pre-verified 标志定义是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLASS_ISPREVERIFIED = (1&lt;&lt;16) // class has been pre-verified.</span><br></pre></td></tr></table></figure></p><p>因此只需要在 jni 层清楚掉它即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazzObj -&gt; accessFlags &amp;= ~CLASS_ISPREVERIFIED;</span><br></pre></td></tr></table></figure></p><p>这样在 dvmResolveClass 找到了新 dex 里的类后，由于 CLASS_ISPREVERIFIED 标志被情况，所以不会判断所在 dex 是否相同，从而成功避免抛出异常。对于这个问题，看看其他方案的做法。<br>Tinker 在 AndroidManifest.xml 声明中要求开发者将自己的 Application 直接替换成 TinkerApplication，而真正的 Application，要在初始化 TinkerApplication 作为参数传入，这样 TinkerApplication 会接管这个传入的 Application，在生命周期回调时通过反射的方式调用实际 Application 的相关逻辑，但接入成本高。<br>Amigo 是在编译过程中，用自定义的 gradle 插件将 app 的 Application 替换成 Amigo 的另一个 Application，并且将原来的 Application 的 name 保存起来，在修复完成之后再调用之前保存的 Application 的 attach(context)，然后将它设回到 loadedApk 中，最后调用其 onCreate()，执行原来 Application 中的逻辑。其实掩耳盗铃，对系统反射替换存在着稳定性的风险。</p><h3 id="dvmOptResolveClass-问题与对策"><a href="#dvmOptResolveClass-问题与对策" class="headerlink" title="dvmOptResolveClass 问题与对策"></a>dvmOptResolveClass 问题与对策</h3><p>上面的清除标志方案并不顺利，在开发工程中，发现如果入口 Application 没有 pre-verified ，反而更有问题。问你是，Dalvik 虚拟机如果发现某个类没有 pre-verified，就会在初始化这个类的时做 verified 操作，这将扫描这个类的所有代码，在扫描过程中对这个类代码里使用到的类都要进行 dvmOptResolveClass 操作。dvmOptResolveClass 会在 Resolve 的时候对使用到的类进行初始化，在一个 app 生命周期中，没有可能比 Application 初始化更早的时期了。<br>在多 dex 时，无法保证 Application 的用到的类和它处在同一个 dex 中，如果只有一个 dex，一般不会有问题。<br>多 dex 中要解决这个问题：</p><ul><li>第一种办法，让 Application 用到的所有非系统类和 Application 位于同一个 dex 里，这样保证 pre-verified 标志被打上，避免进入 dvmOptResolveClass，而在补丁加载完后，再清除 pre-verified 标志，保证使用其他类不会报错；</li><li>第二种办法，让 Application 里面除了热修复框架代码以外的其他代码都单独放在一个其他类里面，这样使得 Application 不会直接用到过多非系统类，这样保证这个单独拿出来的类和 Application 处于同一个 dex 的几率还是比较大的，如果更保险的方式，Application 可以采用反射方式访问这个类，这样彻底把 Application 和其他类隔绝开。</li></ul><p>第一种方法实现，官方 multi-dex 机智就是自动将 Application 用到的类都打包到主 dex 中，因此只要把热修复初始化放在 attachBaseContext 最前面就没有问题了。但是第二种可以一劳永逸地解决问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li>阿里Android热修复技术原理.pdf</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;热修复技术介绍&quot;&gt;&lt;a href=&quot;#热修复技术介绍&quot; class=&quot;headerlink&quot; title=&quot;热修复技术介绍&quot;&gt;&lt;/a&gt;热修复技术介绍&lt;/h2&gt;&lt;h3 id=&quot;代码修复技术&quot;&gt;&lt;a href=&quot;#代码修复技术&quot; class=&quot;headerlink&quot; title=&quot;代码修复技术&quot;&gt;&lt;/a&gt;代码修复技术&lt;/h3&gt;&lt;p&gt;底层替换：已经加载的类直接替换原有方法，由于修改了原来的类，导致方法数的变化，索引无法正常工作，不稳定，可能产生无法预知的结果；&lt;br&gt;类加载：在 app 重新启动后让 classloader 加载新的类，由于已加载的类无法卸载，于是不重启无法加载新类，在重启以后，赶在业务逻辑之前抢先加载补丁的新类，达到热修复的目的。市场主流方案选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QZoneFix：侵入打包流程，不优雅；&lt;/li&gt;
&lt;li&gt;QFix：获取底层虚拟机函数，不稳定；&lt;/li&gt;
&lt;li&gt;Tinker：全量dex加载，粒度过细，性能消耗过大；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;资源修复&quot;&gt;&lt;a href=&quot;#资源修复&quot; class=&quot;headerlink&quot; title=&quot;资源修复&quot;&gt;&lt;/a&gt;资源修复&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;构造新的 AssetManager，反射调用 addAssetPath，把完整新资源包加入 AssetManager 中；&lt;/li&gt;
&lt;li&gt;找到所有引用原 AssetManager 地方，通过反射，把引用处替换成新的。&lt;br&gt;优点：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;只使用一个 package id 为 0x66 的资源包，该包只包含了改变了资源，然后直接在原 AssetManager 中 addAssetPath；&lt;/li&gt;
&lt;li&gt;不修改 AssetManager 引用处；&lt;/li&gt;
&lt;li&gt;不必下发完整包；&lt;/li&gt;
&lt;li&gt;不需要在运行时合成完整包&lt;br&gt;；&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="HoxFix" scheme="https://hjw541988478.github.io/tags/HoxFix/"/>
    
      <category term="CodeHotFix" scheme="https://hjw541988478.github.io/tags/CodeHotFix/"/>
    
  </entry>
  
  <entry>
    <title>Android基础之Activity</title>
    <link href="https://hjw541988478.github.io/2017/07/Android%E5%9F%BA%E7%A1%80%E4%B9%8BActivity/"/>
    <id>https://hjw541988478.github.io/2017/07/Android基础之Activity/</id>
    <published>2017-07-13T11:52:00.000Z</published>
    <updated>2018-08-18T15:39:28.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/07/Android基础之Activity/activity_lifecycle.png" alt="生命周期" title="">                </div>                <div class="image-caption">生命周期</div>            </figure><ul><li>onCreate：生命周期只调用一次，用于初始化、必要对象创建等；</li><li>onStart：界面完全不可见变为可见时调用；</li><li>onResume：界面可点击交互，不被顶层任何其他Activity遮挡，开始执行界面交互；</li><li>onPause：界面交互不可点击，部分可见，此时应该停止交互相关的耗资源操作；</li><li>onStop：界面完全不可见，保存重要数据，在被强杀时onDestroy不会被调用；</li><li>onDestroy：生命周期只会被调用一次，界面完全被销毁，用于释放资源等；</li><li>onRestart：界面onStop后重新被打开调用；<a id="more"></a><h3 id="onPause和onStop调用时机？"><a href="#onPause和onStop调用时机？" class="headerlink" title="onPause和onStop调用时机？"></a>onPause和onStop调用时机？</h3></li><li>当Activity A打开透明熟悉的 B时，A只会调用onPause，onStop不会调用，A部分可见不可交互，此时按返回键关闭B，只会调用A的onResume，A.onResume -&gt; A.onPause -&gt; B.onCreate -&gt; B.onStart -&gt; B.onResume -&gt; B.onPause -&gt; B.onStop -&gt; A.onResume；</li><li>当A打开的不透明的B时，A.onPause -&gt; B.onCreate -&gt; B.onStart -&gt; B.onResume -&gt; A.onStop；<br>可以看到如果在onPause里面做太多的耗时操作，可能导致下一个界面的卡顿；</li></ul><h3 id="异常状态下的生命周期"><a href="#异常状态下的生命周期" class="headerlink" title="异常状态下的生命周期"></a>异常状态下的生命周期</h3><ul><li>系统配置改变<br>如屏幕旋转、键盘灯，会出发Activity的重建，若需要不触发重启，可以在AndroidManifest配置configChanges熟悉，常用的locale、orentation、keyboardHidden和screenSize。</li><li>系统资源不足<br>Activity优先级分为：</li></ul><ol><li>前台：可交互；</li><li>可见非前台：打开Dialog或者透明Activity；</li><li>后台：跳转到其他Activity；<br>内存不足由3到1进行销毁；</li></ol><h2 id="状态保存与恢复"><a href="#状态保存与恢复" class="headerlink" title="状态保存与恢复"></a>状态保存与恢复</h2><p>由于内存不足系统回收，可以使用Bundle进行数据存储与恢复；</p><ul><li>保存：在onStop之前调用onSaveInstanceState，在此处存储；</li><li>恢复：在onCreate方法里恢复，首先判断bundle是否为空，也可以在onRestoreSaveInstance里面完成；</li></ul><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><h3 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h3><p>AndroidManifest配置：无法配置clear_top标识；<br>intent中追加addFlags方法，以代码动态设置为准，无法设置singleInstance模式；</p><h3 id="Activity任务栈"><a href="#Activity任务栈" class="headerlink" title="Activity任务栈"></a>Activity任务栈</h3><ul><li>存放Activity，采用后进先出的结构；</li><li>从栈A启动到栈B，按返回键，先将栈B回退到空，再入栈A<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/07/Android基础之Activity/diagram_backstack_singletask_multiactivity.png" alt="Activity任务栈" title="">                </div>                <div class="image-caption">Activity任务栈</div>            </figure></li><li>查看命令： adb shel dumpsys activity</li></ul><h3 id="4种类型"><a href="#4种类型" class="headerlink" title="4种类型"></a>4种类型</h3><ol><li>standard：标准模式，每次启动新的Activity并加入到当前栈的顶部；</li><li>singleTop：栈顶复用模式，若打开的Activity位于栈顶，直接复用，按照onPause -&gt; onNewIntent -&gt; onResume 顺序出发，可以在onNewIntent内处理业务；</li><li>singleTask：栈内复用模式：Activity A在栈S1，若A打开singleTask模式的Activity B；<br>B目标栈为S2，S2不存在，则创建S2，将B入栈S2；<br>B目标栈为S1，S1存在且无B，则将B放入栈顶；<br>B目标栈为S1，S1存在且有B，复用B，将B上面的Activity出栈，回调onNewIntent方法；</li><li>singleInstance：单例模式，单独位于一个任务栈中，栈中不会有其他Activity；</li></ol><h2 id="标识FLAGS"><a href="#标识FLAGS" class="headerlink" title="标识FLAGS"></a>标识FLAGS</h2><ul><li>FLAG_ACTIVITY_NEW_TASK：不等同于singleTask；<br>目标栈不存在，则创建栈并入栈；<br>目标栈存在，若Activity未打开过，创建放入栈顶；<br>目标栈存在，若Activity已打开过，将目标栈移动到前台，不会创建新的；</li><li>FLAG_ACTIVITY_SINGLE_TOP：等同于singleTop；</li><li>FLAG_ACTIVITY_CLEAR_TOP：singleTask自带该效果；</li><li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：不出现在多任务列表中；</li></ul><h2 id="Activity到底进入哪个栈-？"><a href="#Activity到底进入哪个栈-？" class="headerlink" title="Activity到底进入哪个栈 ？"></a>Activity到底进入哪个栈 ？</h2><ol><li>taskAffinity：亲和关系，表示更倾向于进入哪个栈，所以并不是设置了该属性，就一定位于这个栈中；</li><li>taskAffinity不设置时，默认为包名；</li><li>当A启动standard、singleTop的B时，且不带FLAG_ACIVITY_NEW_TASK，则B加入A所在的栈顶；</li><li>只有singleTask、singleInstance或者带FLAG_ACTIVITY_NEW_TASK才能让taskAffinity生效；</li><li>allowTaskReparenting这个属性会让taskAffinity生效，如A启动带taskAffinity的B，B肯定放入taskAffinity声明的栈中；</li></ol><p>##参考</p><blockquote><ol><li><a href="http://www.jianshu.com/p/8aed27750f1e" target="_blank" rel="noopener">Activity你该懂的</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;/2017/07/Android基础之Activity/activity_lifecycle.png&quot; alt=&quot;生命周期&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;生命周期&lt;/div&gt;
            &lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;onCreate：生命周期只调用一次，用于初始化、必要对象创建等；&lt;/li&gt;
&lt;li&gt;onStart：界面完全不可见变为可见时调用；&lt;/li&gt;
&lt;li&gt;onResume：界面可点击交互，不被顶层任何其他Activity遮挡，开始执行界面交互；&lt;/li&gt;
&lt;li&gt;onPause：界面交互不可点击，部分可见，此时应该停止交互相关的耗资源操作；&lt;/li&gt;
&lt;li&gt;onStop：界面完全不可见，保存重要数据，在被强杀时onDestroy不会被调用；&lt;/li&gt;
&lt;li&gt;onDestroy：生命周期只会被调用一次，界面完全被销毁，用于释放资源等；&lt;/li&gt;
&lt;li&gt;onRestart：界面onStop后重新被打开调用；&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="Activity" scheme="https://hjw541988478.github.io/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>Java常用线程池理解</title>
    <link href="https://hjw541988478.github.io/2017/06/Java%E5%B8%B8%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%90%86%E8%A7%A3/"/>
    <id>https://hjw541988478.github.io/2017/06/Java常用线程池理解/</id>
    <published>2017-06-14T10:32:00.000Z</published>
    <updated>2018-08-18T15:39:48.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="why-？"><a href="#why-？" class="headerlink" title="why ？"></a>why ？</h2><ul><li>创建和销毁线程伴随着系统开销，如果频繁创建销毁线程，影响处理效率；（创建时间T1，执行任务T2，销毁T3。如果T1+T3&gt;T2，那就划不来）</li><li>线程并发数量过多，抢占系统资源导致阻塞；（线程共享系统资源，如果同时执行线程过多，导致系统资源不多而产生阻塞）</li><li>能对线程进行简单管理；（延时执行，定时循环执行）<a id="more"></a><h2 id="what-？"><a href="#what-？" class="headerlink" title="what ？"></a>what ？</h2>主要是Executor接口，实现类为<code>ThreadPoolExecutor</code>，对线程池的配置主要在于构造参数的配置；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br></pre></td></tr></table></figure></li></ul><p>还有<code>ThreadFactory，RejectedExecutionHandler</code>参数的构造，略有不同而已：</p><ul><li>int corePoolSize：核心线程数最大值；<br>线程池新建线程时，如果当前线程总数小于corePoolSize，则新建的是核心线程，否则是非核心线程，核心线程默认情况下会一直存活在线程池中，即使是闲置状态。如果指定了allowCoreThreadTimeOut为true，那么超时后就会被销毁掉。</li><li>int maximumPoolSize：线程池总数最大值；</li><li>long keepAliveTime：非核心线程闲置超时时长，如果设置了allowCoreThreadTimeOut=true，则会作用于核心线程；</li><li>TimeUnit unit：超时时长的单位，可以是1纳秒，微秒，毫秒，秒分别为1000的单位；</li><li>BlockingQueue workQueue：线程池中的任务队列，维护着等待执行的Runnable对象，常用的：<ul><li>SynchronousQueue：收到任务后直接交给线程处理，如果线程都在工作则新建线程，但不得超过最大数量，所以使用该任务队列时，一般指定最大线程数量为无限大；</li><li>LinkedBlockingQueue：收到任务后，如果线程数小于核心线程数，则新建核心线程处理，如果等于核心线程数，则进入队列等待，也就是说，超过核心线程数的任务永远被加入队列中等待，同时导致maximusPoolSize失效；</li><li>ArrayBlockingQueue：限定任务队列长度，收到任务后，如果没有达到corePoolSize，则新建coreThread处理，如果等于corePoolSize，则入队等候，如果队列已满，则新建非coreThread执行任务，如果达到了maximumPoolSize且队列已满，则发生错误；</li><li>DelayQueue：队列内元素必须实现Dealay接口，接收到任务时，先入队，达到指定延时时间才会执行任务；</li></ul></li><li>ThreadFactory：创建线程的接口，一般不用；</li><li>RejectedExecutionHandler handler：发生错误，用来抛出异常；</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>线程数量未达到corePoolSize，则新建核心线程执行任务；</li><li>线程数量达到了corePools，则将任务移入队列等待 ；</li><li>队列已满，则新建线程非核心线程处理；</li><li>队列已满并且总线程数达到了maximumPoolSize，则抛出异常；</li></ol><h2 id="常见四种线程池"><a href="#常见四种线程池" class="headerlink" title="常见四种线程池"></a>常见四种线程池</h2><h3 id="CachedThreadPool："><a href="#CachedThreadPool：" class="headerlink" title="CachedThreadPool："></a>CachedThreadPool：</h3><ul><li>无核心线程，没有工作的线程60s会自动被销毁；</li><li>线程数无限制；</li><li>有空线程则复用，无则新建线程；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;()); &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="FixedThreadPool："><a href="#FixedThreadPool：" class="headerlink" title="FixedThreadPool："></a>FixedThreadPool：</h3><ul><li>最大线程并发数等于核心线程数；</li><li>小于核心线程数时，不会复用闲置线程，超出核心线程数时会等待；</li><li>最多同时执行定长的线程；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()); &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ScheduledThreadPool："><a href="#ScheduledThreadPool：" class="headerlink" title="ScheduledThreadPool："></a>ScheduledThreadPool：</h3><ul><li>支持定时以及周期性任务；</li><li>优先复用闲置线程；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, <span class="keyword">new</span> DelayedWorkQueue()); &#125;</span><br><span class="line">scheduleAtFixedRate()：延迟n秒后，每隔m秒执行任务；</span><br><span class="line">scheduleWithFixedDelay()：延迟n秒后，任务完成后隔m秒执行任务；</span><br></pre></td></tr></table></figure></li></ul><h3 id="SingleThreadPool："><a href="#SingleThreadPool：" class="headerlink" title="SingleThreadPool："></a>SingleThreadPool：</h3><ul><li>有且仅有1个工作线程执行任务；</li><li>遵循队列规则执行；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())); &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="http://blog.csdn.net/lift_class/article/details/70216690" target="_blank" rel="noopener">线程池，这一篇或许就够了</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;why-？&quot;&gt;&lt;a href=&quot;#why-？&quot; class=&quot;headerlink&quot; title=&quot;why ？&quot;&gt;&lt;/a&gt;why ？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;创建和销毁线程伴随着系统开销，如果频繁创建销毁线程，影响处理效率；（创建时间T1，执行任务T2，销毁T3。如果T1+T3&amp;gt;T2，那就划不来）&lt;/li&gt;
&lt;li&gt;线程并发数量过多，抢占系统资源导致阻塞；（线程共享系统资源，如果同时执行线程过多，导致系统资源不多而产生阻塞）&lt;/li&gt;
&lt;li&gt;能对线程进行简单管理；（延时执行，定时循环执行）&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hjw541988478.github.io/categories/Java/"/>
    
    
      <category term="MultiThread" scheme="https://hjw541988478.github.io/tags/MultiThread/"/>
    
      <category term="ThreadPool" scheme="https://hjw541988478.github.io/tags/ThreadPool/"/>
    
  </entry>
  
  <entry>
    <title>Android插件化原理探索</title>
    <link href="https://hjw541988478.github.io/2017/05/Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/"/>
    <id>https://hjw541988478.github.io/2017/05/Android插件化原理探索/</id>
    <published>2017-05-16T14:01:00.000Z</published>
    <updated>2018-08-18T15:39:35.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式（委托模式）"><a href="#代理模式（委托模式）" class="headerlink" title="代理模式（委托模式）"></a>代理模式（委托模式）</h2><p>限制对象的直接访问，保护内部对象；</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>AIDL中<code>asInterface</code>方法中有应用到静态代理，如果不在同一进程就会返回Proxy对象，而且几乎所有系统服务采用代理模式。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>运行时指定代理类，实现<code>InvocationHandler</code>接口，重写invoke方法，通过<code>Proxy.newInstance</code>返回代理对象。分为jdk动态代理和cglib动态代理；</p><ul><li>jdk动态代理：基于类的反射机制，而且目标类基于同一的接口，Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理；</li><li>cglib动态代理：借助asm实现，没有jdk动态代理的限制；<a id="more"></a><h2 id="Hook机制"><a href="#Hook机制" class="headerlink" title="Hook机制"></a>Hook机制</h2>对一些方法进行拦截，当这些方法被调用时，能够执行我们自定义的代码，大致思路：</li></ul><p>找到需要拦截的方法；<br>利用代理模式来代理系统类的运行拦截我们需要拦截的方法；<br>使用反射方法把系统类替换成你的代理类； ##反射机制<br>java的反射机制是在运行态中，对于任意一个类都能知道其属性和方法，对于任意一个对象都能调用其方法和属性，这种动态获取信息以及动态调用对象的方法称为反射机制；</p><ol><li><p>实例化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forNmae(完整类名);</span><br></pre></td></tr></table></figure></li><li><p>获取父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(完整类名);</span><br><span class="line">Class&lt;?&gt; superClass = clazz.getSuperclass();</span><br></pre></td></tr></table></figure></li><li><p>获取实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(完整类名);</span><br><span class="line">Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br></pre></td></tr></table></figure></li><li><p>获取指定参数构造函数以及实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(完整类名);</span><br><span class="line">Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); <span class="comment">// 公共构造</span></span><br><span class="line"><span class="keyword">for</span>( .. ) &#123;</span><br><span class="line">    Class&lt;?&gt; clazzs[] = constructor.getParameterTypes(); <span class="comment">// 获取参数类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>无参数实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(完整类名);</span><br><span class="line">clazz.newInstance();</span><br></pre></td></tr></table></figure></li><li><p>获取字段修改字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(完整类名);</span><br><span class="line">Field field = clazz.getField(name); <span class="comment">// 获取公共字段</span></span><br><span class="line">Field[] fields = clazz.getFields(); <span class="comment">// 获取所有公共字段</span></span><br><span class="line">Field field = clazz.getDeclaredField(<span class="string">"heihei"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置java取消访问检查，也就是说如果是私有的也可以访问,</span></span><br><span class="line">field.set(obj, <span class="string">"Java反射机制"</span>);</span><br></pre></td></tr></table></figure></li><li><p>获取方法运行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Method method = clazz.getMethod(<span class="string">"add"</span>,<span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">method.setAccessiable(<span class="keyword">true</span>);</span><br><span class="line">method.invoke(clazz.newInstance(), <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure></li><li><p>获取数组或者list中的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; componentType = clazz.getComponentType();</span><br></pre></td></tr></table></figure></li></ol><p>以hook剪切板服务为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Context.getSystemService(CLIPBOARD_SERVICE) -&gt;</span><br><span class="line">ContextImpl.getSystemService() -&gt;</span><br><span class="line">SystemServiceRegistry.getSystemService() -&gt;</span><br><span class="line">SYSTEM_SERVICE_FETCHERS.get() -&gt;</span><br><span class="line">ServiceManager.getService()获取IBinder -&gt;</span><br><span class="line">IBinder.asInterface()获取到远程服务接口 -&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.content.<span class="function">IClipboard <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); <span class="comment">// Hook点</span></span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> android.content.IClipboard))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((android.content.IClipboard) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android.content.IClipboard.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体实现：</p><ol><li><p>剪切板服务，是在系统的<code>ServiceManager</code>中的<code>getSerVice</code>方法中得到的，我们先拿到<code>ServiceManager</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; serviceMangerClass = Class.forName(<span class="string">"android.os.ServiceManager"</span>);</span><br></pre></td></tr></table></figure></li><li><p>拿到<code>getService</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method getServiceMethod = serviceMangerClass.getDeclaredMethod(<span class="string">"getService"</span>, String.class);</span><br></pre></td></tr></table></figure></li><li><p>通过这个方法，拿到原本的系统服务代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IBinder binder = (IBinder) getServiceMethod.invoke(<span class="keyword">null</span>,<span class="string">"clipboard"</span>);</span><br></pre></td></tr></table></figure></li><li><p>我们通过这个对象，创建我们自己的代理对象，瞒天过海骗过系统</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IBinder myBinder = (IBinder) Proxy.newProxyInstance(serviceMangerClass.getClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> Class[]&#123;IBinder.class&#125;,<span class="keyword">new</span> MyClipProxy(binder));</span><br></pre></td></tr></table></figure></li><li><p>拿到 ServiceManager 中的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Field field = serviceMangerClass.getDeclaredField(<span class="string">"sCache"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Map&lt;String, IBinder&gt; map = (Map) field.get(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//将我们的服务类存入map</span></span><br><span class="line">map.put(<span class="string">"clipboard"</span>,myBinder);</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClipProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mBase;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClipProxy</span><span class="params">(IBinder binder)</span> </span>&#123;</span><br><span class="line">        mBase = binder;<span class="comment">//这里传入的是原系统的代理类</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//拦截原系统类查询本地是否有这个代理的方法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"queryLocalInterface"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="comment">//我们这里要创建我们自己的系统类，然后返回</span></span><br><span class="line">            <span class="comment">//1.拿到系统的aidl类中的stub，因为这个对象本来就是个代理,而且源码执行了</span></span><br><span class="line"><span class="comment">//            static private IClipboard getService() &#123;</span></span><br><span class="line"><span class="comment">//                synchronized (sStaticLock) &#123;</span></span><br><span class="line"><span class="comment">//                    if (sService != null) &#123;</span></span><br><span class="line"><span class="comment">//                        return sService;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                    IBinder b = ServiceManager.getService("clipboard");</span></span><br><span class="line"><span class="comment">//                    sService = IClipboard.Stub.asInterface(b);</span></span><br><span class="line"><span class="comment">//                    return sService;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            Class&lt;?&gt; mStubClass = Class.forName(<span class="string">"android.content.IClipboard$Stub"</span>);</span><br><span class="line">            <span class="comment">//2.在拿到IClipboard本地对象类</span></span><br><span class="line">            Class&lt;?&gt; mIClipboard = Class.forName(<span class="string">"android.content.IClipboard"</span>);</span><br><span class="line">            <span class="comment">//3.创建我们自己的代理</span></span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(mStubClass.getClassLoader(),</span><br><span class="line">                    <span class="keyword">new</span> Class[]&#123;mIClipboard&#125;,</span><br><span class="line">                    <span class="keyword">new</span> MyClip(mBase,mStubClass));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不是这个方法还是返回原系统的执行</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(mBase,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClip</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object mBase;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClip</span><span class="params">(IBinder base, Class stub)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拿到asInteface方法，因为源码中执行了这一句，我们也要执行这一句</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method asInterface = stub.getDeclaredMethod(<span class="string">"asInterface"</span>, IBinder.class);</span><br><span class="line">            mBase = asInterface.invoke(<span class="keyword">null</span>,base);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//这里我们拦截粘贴的方法，</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"getPrimaryClip"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="keyword">return</span> ClipData.newPlainText(<span class="keyword">null</span>,<span class="string">"我是刘镓旗，我改了系统源码，哈哈哈"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再拦截是否有复制的方法，放系统认为一直都有</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"hasPrimaryClip"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其他启动还是返回原有的</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(mBase,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h2><h3 id="AIDL（以ActivityManager为例）："><a href="#AIDL（以ActivityManager为例）：" class="headerlink" title="AIDL（以ActivityManager为例）："></a>AIDL（以ActivityManager为例）：</h3><p><code>ActivityManager</code>其实是AMS在主进程中的一个代理包装类，内部使用<code>AMN.getDefault()</code>进行操作：</p><ul><li><p>asInterface()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/** &#123;<span class="doctag">@hide</span>&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerNative</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IActivityManager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cast a Binder object into an activity manager interface, generating</span></span><br><span class="line"><span class="comment">     * a proxy if needed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager in =</span><br><span class="line">            (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> in;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActivityManagerProxy(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>onTransact()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> START_ACTIVITY_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">        IBinder b = data.readStrongBinder();</span><br><span class="line">        IApplicationThread app = ApplicationThreadNative.asInterface(b);</span><br><span class="line">        String callingPackage = data.readString();</span><br><span class="line">        Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">        String resolvedType = data.readString();</span><br><span class="line">        IBinder resultTo = data.readStrongBinder();</span><br><span class="line">        String resultWho = data.readString();</span><br><span class="line">        <span class="keyword">int</span> requestCode = data.readInt();</span><br><span class="line">        <span class="keyword">int</span> startFlags = data.readInt();</span><br><span class="line">        ProfilerInfo profilerInfo = data.readInt() != <span class="number">0</span></span><br><span class="line">                ? ProfilerInfo.CREATOR.createFromParcel(data) : <span class="keyword">null</span>;</span><br><span class="line">        Bundle options = data.readInt() != <span class="number">0</span></span><br><span class="line">                ? Bundle.CREATOR.createFromParcel(data) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> result = startActivity(app, callingPackage, intent, resolvedType,</span><br><span class="line">                resultTo, resultWho, requestCode, startFlags, profilerInfo, options);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        reply.writeInt(result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>其实<code>ActivityManagerNative</code>相当于<code>IActivityManager</code>的代理内部类Stub，当不是一个进程会使用代理类Proxy来操作，将创建好的参数写入data中，当前线程挂起发起远程调用m<code>Remote.transact()</code>方法，此时调用服务端的<code>onTransact()</code>方法，直到有返回结果，然后从reply中取result；<br>服务端请求走到<code>onTransact</code>方法时，通过code确定是属于哪个方法，然后从data取出需要的参数，并调用相应方法，将返回值写入reply。</p><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><h3 id="官方MultiDex方案"><a href="#官方MultiDex方案" class="headerlink" title="官方MultiDex方案"></a>官方MultiDex方案</h3><p>一个APK包含多个dex文件，除了第一个dex文件以外，其他dex文件是以资源形式加载的，也就是说，Application初始化前，将dex文件注入到系统的ClassLoader中，在Android的类加载机制中，同一个类只会被加载一次，为了让修复后的类替换原有的类，必须让补丁包优先加载，也就是插入到原有dex之前。</p><h3 id="ClassLoader-1"><a href="#ClassLoader-1" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>Android中有主要的两个ClassLoader，<code>PathClassLoader</code>和<code>DexClassLoader</code>，它们都继承自<code>BaseDexClassLoader</code>，具体加载方法是findClass：</p><ul><li>PathClassLoader：<br>加载系统类和主dex，也就意味着optimiszedDirectory为null，通过注释可知，被用来加载本地文件系统上的文件或目录，不能从网络加载；<br>DexClassLoader：<br>用于加载其他dex文件中的类。其构造：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dexPath：需要被加载的dex文件地址；</span></span><br><span class="line"><span class="comment">//optimizedDirectory：dex文件被编译器优化后的存放路径，禁止为null，应该提供应用私有路径；</span></span><br><span class="line"><span class="comment">//libraryPath：包含本地库的列表；</span></span><br><span class="line"><span class="comment">//parent：父类构造器</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="为啥PathClassLoader的optimizedDirectory可以为null？"><a href="#为啥PathClassLoader的optimizedDirectory可以为null？" class="headerlink" title="为啥PathClassLoader的optimizedDirectory可以为null？"></a>为啥PathClassLoader的optimizedDirectory可以为null？</h3><p>在初始化时，会构造一个叫pathList的<code>DexPathList</code>对象，在findClass的时候使用pathList调用findClass，查看DexPathList源码发现，如果<code>optimizedDirectory</code>为空则使用系统默认的文件夹，我们的应用已经安装并优化了，优化后的dex存在于/data/dalvik-cache目录下，这样就无法修改该optimizedDirectory；<br>在<code>DexClassLoader</code>初始化时，会将参数中的dex文件都保存在<code>Element</code>数组中，这样在findClass的时候，只需要遍历<code>dexElements</code>，从中查找目标类并返回便停止遍历。</p><h2 id="Activity启动流程分析"><a href="#Activity启动流程分析" class="headerlink" title="Activity启动流程分析"></a>Activity启动流程分析</h2><p>Launcher.startActivityForSafely() -&gt; Activity.startActivity() -&gt; startActivityForResult() -&gt; Instrumention.execStartActiviy() -&gt; ActivityMangerNative.getDefault().startActivity() -&gt;<br>（先调用checkStartActivityResult()来检查Activity是否有效合法）-&gt; AMS.startActivity()/AMS代理类请求AMS启动一个Activity -&gt; AMS.startActivityAsUser()-&gt;ActivityStarter.startActivityMayWait() -&gt;<br>ActivityStackSupervisor.realStartActivityLocked() -&gt; app.thread.scheduleLaunchActivity()/调用ActivityThread的内部类ApplicationThread，其中ApplicationThread是IApplicationThread子类，是Binder对象 -&gt; ActivityThread.scheduleLaunchActivity()-&gt; sendMessage()/发送消息到内部类H中 -&gt; H.handleMessage() -&gt;handleLaunchActivity() -&gt; performLaunchActivity() -&gt; Instrumention.newActivity( )/1.创建Activity -&gt; ActivityClientRecord.package.makeApplication()/2. 创建Application，如果Application已经创建则直接返回，否则创建并调用callApplicationOnCreate() -&gt; createBaseContextForActivity()/activity.attach()/mInstrumention.callActivityOnCreate()/3.创建Context对象并attach，onCrerate方法；</p><h3 id="Activity启动流程总结"><a href="#Activity启动流程总结" class="headerlink" title="Activity启动流程总结"></a>Activity启动流程总结</h3><ol><li>待启动的Activity会去AMS中校验是否合法；</li><li>回调ActivityThread中内部类ApplicationThread的scheduleLaunchActivity发送到内部类H中，H继承于Handler；</li><li>反射创建Activity以及Application并回调相应生命周期方法；</li></ol><h2 id="简单插件化实现"><a href="#简单插件化实现" class="headerlink" title="简单插件化实现"></a>简单插件化实现</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>加载插件的ClassLoader通过LoadedApk对象获得的，通过我们构建一个LoadedApk对象，修改其中的ClassLoader对象，创建自己的ClassLoader对象，全面接管加载过程，再使用hook的方式把构建的LoaderApk对象存入mPackages的map中，这样会优先获取缓存也能获取到插件的LoadedApk了。不过需要hook系统中的很多方法，因为创建loadedapk需要ApplicationInfo对象，这个对象从AndroidManifest红来，还需要手动解析AndroidManifest，这个过程相对复杂很多，360的DroidPlugin采用的这种方法。</li><li>既然启动插件需要classloader，那也可以将我们的插件apk告诉系统classloader，让系统ClassLoader来接管创建，系统通过PathClassLoader加载系统类和主Dex类，DexClassLoader则用于加载其他dex中的类。</li></ol><h3 id="代码动态加载"><a href="#代码动态加载" class="headerlink" title="代码动态加载"></a>代码动态加载</h3><p>apk被安装后，apk文件代码以及资源会被放在/data/app/package_name/base-1.apk中，系统进行类加载的时候，会自动在这个路径去寻找，当然未安装的apk是没办法做到的。既然类加载是通过BaseDexClassLoader的findClass方法，最终调用的是DexPathList类里面的findClass，而实际上使用的是此类里面的dexElements数组，这个数组就是用来存放dex文件的数组，我们只需要将插件apk中的dex文件插入到dexElements数组中就可以实现，让系统自动加载并创建类了。<br>对于Activity而言稍有不一样，因为AMS会检查待启动的Activity是否又在AndroidManifest中注册，而插件apk却是灵活的，因此需要hook代理startActivity，采用占坑方式，在校验的时候使用占坑activity通过校验，在真正启动的时候hookActivity创建方法，替换回来启动真正的Activity；<br>总结下需要注意的点：</p><ol><li>startActivity最终走到AMS的startActivity；</li><li>AMS验证activity是否合法；</li><li>Activity创建时使用的ClassLoader为PathClassLoader；</li><li>分析ClassLoader可以知道，在装载类的时候最终使用的是BaseDexClassloader维护的dexElements数组来进行findClass的；</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现插件DexClassLoader，并合宿主的pathList：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DexClassLoader pluginClassLoader = <span class="keyword">new</span> DexClassLoader(apkPath, cacheDir, cacheDir, getClassLoader());</span><br><span class="line">PathClassLoader hostClassLoader = (PathClassLoader) getContext().getClassLoader();</span><br><span class="line">Object pluginElements = getDexElements(pluginClassLoader);</span><br><span class="line">Object hostElements = getDexElements(hostClassLoader);</span><br><span class="line">Object mergedElements = Array.newInstance(Element.class, totalLen);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k &lt; totalLen; k ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; hostLen) &#123;</span><br><span class="line">        Array.set(mergedElements,k,Array.get(host, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Array.set(mergedElements,k,Array.get(plugin, k - hostLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setField(<span class="string">"dexElements"</span>, mergedElements);</span><br></pre></td></tr></table></figure></p><p>此时对于普通的插件Class便可以达到加载的目的了，而对于Activity还需要做一些微小的工作；</p><ol><li><p>代理启动Activity，在AMS验证的时候需要先将Activity替换成占坑的Activity，分析源码可知，在AMS验证之前的一步操作是ActivityManagerNative.getDefault().startActivity()，使用ActivityManger的本地代理类来启动Activity，这里的Hook点便在此：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ActivityManagerNative的类</span></span><br><span class="line">Class&lt;?&gt; activityManagerNativeClass = Class.forName(<span class="string">"android.app.ActivityManagerNative"</span>);</span><br><span class="line"><span class="comment">//拿到gDefault字段</span></span><br><span class="line">Field gDefaultField = activityManagerNativeClass.getDeclaredField(<span class="string">"gDefault"</span>);</span><br><span class="line">gDefaultField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//从gDefault字段中取出这个对象的值</span></span><br><span class="line">Object gDefault = gDefaultField.get(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// gDefault是一个 android.util.Singleton对象; 我们取出这个单例里面的字段</span></span><br><span class="line">Class&lt;?&gt; singleton = Class.forName(<span class="string">"android.util.Singleton"</span>);</span><br><span class="line"><span class="comment">//这个gDefault是一个Singleton类型的，我们需要从Singleton中再取出这个单例的AMS代理</span></span><br><span class="line">Field mInstanceField = singleton.getDeclaredField(<span class="string">"mInstance"</span>);</span><br><span class="line">mInstanceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//ams的代理对象</span></span><br><span class="line">Object rawIActivityManager = mInstanceField.get(gDefault);</span><br><span class="line"><span class="comment">// 创建一个这个对象的代理对象, 然后替换这个字段, 让我们的代理对象帮忙干活,这里我们使用动态代理,</span></span><br><span class="line"><span class="comment">//动态代理依赖接口，而ams实现与IActivityManager</span></span><br><span class="line">Class&lt;?&gt; iActivityManagerInterface = Class.forName(<span class="string">"android.app.IActivityManager"</span>);</span><br><span class="line"><span class="comment">//返回代理对象,IActivityManagerHandler是我们自己的代理对象，具体代码请下载demo</span></span><br><span class="line">Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line"><span class="keyword">new</span> Class&lt;?&gt;[] &#123; iActivityManagerInterface &#125;, <span class="keyword">new</span> IActivityManagerHandler(rawIActivityManager));</span><br><span class="line"><span class="comment">//将我们的代理设值给singleton的单例</span></span><br><span class="line">mInstanceField.set(gDefault, proxy);</span><br><span class="line">代理IActivityManager的类如下，只是拦截了startActivity并使用占坑的Activity顺带把插件Activity存入Intent：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IActivityManagerHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"startActivity"</span>.equals(method.getName())) &#123;</span><br><span class="line">Log.e(<span class="string">"Main"</span>,<span class="string">"startActivity方法拦截了"</span>);</span><br><span class="line"><span class="comment">// 找到参数里面的第一个Intent 对象</span></span><br><span class="line">Intent raw;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> Intent) &#123;</span><br><span class="line">index = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">raw = (Intent) args[index];</span><br><span class="line"><span class="comment">//创建一个要被掉包的Intent</span></span><br><span class="line">Intent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line"><span class="comment">// 替身Activity的包名, 也就是我们自己的"包名"</span></span><br><span class="line">String stubPackage = MyApplication.getContext().getPackageName();</span><br><span class="line"><span class="comment">// 这里我们把启动的Activity临时替换为 ZhanKengActivitiy</span></span><br><span class="line">ComponentName componentName = <span class="keyword">new</span> ComponentName(stubPackage, ZhanKengActivitiy.class.getName());</span><br><span class="line">newIntent.setComponent(componentName);</span><br><span class="line"><span class="comment">// 把我们原始要启动的TargetActivity先存起来</span></span><br><span class="line">newIntent.putExtra(AMSHookHelper.EXTRA_TARGET_INTENT, raw);</span><br><span class="line"><span class="comment">// 替换掉Intent, 达到欺骗AMS的目的</span></span><br><span class="line">args[index] = newIntent;</span><br><span class="line">Log.e(<span class="string">"Main"</span>,<span class="string">"startActivity方法 hook 成功"</span>);</span><br><span class="line">Log.e(<span class="string">"Main"</span>,<span class="string">"args[index] hook = "</span> + args[index]);</span><br><span class="line"><span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在检查完之后，还需要在ActivityThread中的H中替换需要启动的Activity，也就是Hook点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">先获取到当前的ActivityThread对象</span><br><span class="line">Class&lt;?&gt; activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line"><span class="comment">//他有一个方法返回了自己</span></span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">currentActivityThreadMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//执行方法得到ActivityThread对象</span></span><br><span class="line">Object currentActivityThread = currentActivityThreadMethod.invoke(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 由于ActivityThread一个进程只有一个,我们获取这个对象的mH字段，也就是H这个Handler</span></span><br><span class="line">Field mHField = activityThreadClass.getDeclaredField(<span class="string">"mH"</span>);</span><br><span class="line">mHField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//得到H这个Handler</span></span><br><span class="line">Handler mH = (Handler) mHField.get(currentActivityThread);</span><br><span class="line"><span class="comment">//创建一个我们的CallBack并赋值给mH</span></span><br><span class="line">Field mCallBackField = Handler.class.getDeclaredField(<span class="string">"mCallback"</span>);</span><br><span class="line">mCallBackField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//设置我们自己的CallBackField，具体替换信息代码请下载demo查看</span></span><br><span class="line">mCallBackField.set(mH, <span class="keyword">new</span> ActivityThreadHandlerCallback(mH));</span><br><span class="line">同样的，需要代理H类的mCallback对象，在startActivity时恢复插件的Activity：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThreadHandlerCallback</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">Handler mBase;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityThreadHandlerCallback</span><span class="params">(Handler base)</span> </span>&#123;</span><br><span class="line">mBase = base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">Log.e(<span class="string">"Main"</span>,<span class="string">"handleMessage what = "</span> + msg.what);</span><br><span class="line"><span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line"><span class="comment">// ActivityThread里面 "LAUNCH_ACTIVITY" 这个字段的值是100</span></span><br><span class="line"><span class="comment">// 本来使用反射的方式获取最好, 这里为了简便直接使用硬编码</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">handleLaunchActivity(msg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mBase.handleMessage(msg);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里简单起见,直接取出TargetActivity;</span></span><br><span class="line">Log.e(<span class="string">"Main"</span>,<span class="string">"handleLaunchActivity方法 拦截"</span>);</span><br><span class="line">Object obj = msg.obj;</span><br><span class="line"><span class="comment">// 根据源码:</span></span><br><span class="line"><span class="comment">// 这个对象是 ActivityClientRecord 类型</span></span><br><span class="line"><span class="comment">// 我们修改它的intent字段为我们原来保存的即可.</span></span><br><span class="line"><span class="comment">// switch (msg.what) &#123;</span></span><br><span class="line"><span class="comment">// case LAUNCH_ACTIVITY: &#123;</span></span><br><span class="line"><span class="comment">// Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart");</span></span><br><span class="line"><span class="comment">// final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span></span><br><span class="line"><span class="comment">// r.packageInfo = getPackageInfoNoCheck(</span></span><br><span class="line"><span class="comment">// r.activityInfo.applicationInfo, r.compatInfo);</span></span><br><span class="line"><span class="comment">// handleLaunchActivity(r, null);</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 把替身恢复成真身</span></span><br><span class="line">Field intent = obj.getClass().getDeclaredField(<span class="string">"intent"</span>);</span><br><span class="line">intent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Intent raw = (Intent) intent.get(obj);</span><br><span class="line">Intent target = raw.getParcelableExtra(AMSHookHelper.EXTRA_TARGET_INTENT);</span><br><span class="line">raw.setComponent(target.getComponent());</span><br><span class="line">Log.e(<span class="string">"Main"</span>,<span class="string">"target = "</span> + target);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"hook launch activity failed"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="插件Activity为啥就有生命周期了呢？"><a href="#插件Activity为啥就有生命周期了呢？" class="headerlink" title="插件Activity为啥就有生命周期了呢？"></a>插件Activity为啥就有生命周期了呢？</h3><p>AMS与ActivityThread之间对于Activity的生命周期的交互，并没有直接使用Activity对象进行交互，而是使用一个token来标识，这个token是binder对象，因此可以方便地跨进程传递。Activity里面有一个成员变量mToken代表的就是它，token可以唯一地标识一个Activity对象，这里我们只不过替换了要启动Activity的信息，并没有替换这个token，所以系统并不知道运行的这个Activity并不是原来的那个。</p><h2 id="资源动态加载"><a href="#资源动态加载" class="headerlink" title="资源动态加载"></a>资源动态加载</h2><h3 id="系统资源加载分析"><a href="#系统资源加载分析" class="headerlink" title="系统资源加载分析"></a>系统资源加载分析</h3><p>宿主应用中正常情况下是无法访问插件资源，例如使用R或者getResource()的方式，因此如果如果宿主如果不存在资源ID，应用便会crash。LoadedApk对象表示了apk文件在内存中的表示，包括代码和资源，回顾LoadedApk的构建，其中需要ApplicationInfo作为参数，而这个ApplicationInfo是宿主的并不是插件的，而宿主的资源中并没有插件资源，因此插件apk无法使用插件的资源。<br>在代码中使用资源的形式一般都是R类或者getResources()这两种方式，其实R文件查找也是通过context.getResources()来查找ID来完成的，而context具体的实现类为ContextImpl：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> mResources;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到只是仅仅返回mResources成员变量，查找其如何创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里拿到了一个ResourcesManager,单例的，说明我们应用当中使用的都是同一套资源</span></span><br><span class="line"></span><br><span class="line">mResourcesManager = ResourcesManager.getInstance();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//LoadedApk对象中得到Resources对象</span></span><br><span class="line">Resources resources = packageInfo.getResources(mainThread);</span><br><span class="line">Resources resources = packageInfo.getResources(mainThread);</span><br><span class="line"><span class="keyword">if</span> (resources != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (activityToken != <span class="keyword">null</span></span><br><span class="line">|| displayId != Display.DEFAULT_DISPLAY</span><br><span class="line">|| overrideConfiguration != <span class="keyword">null</span></span><br><span class="line">|| (compatInfo != <span class="keyword">null</span> &amp;&amp; compatInfo.applicationScale</span><br><span class="line">!= resources.getCompatibilityInfo().applicationScale)) &#123;</span><br><span class="line"><span class="comment">//给resource赋值</span></span><br><span class="line">resources = mResourcesManager.getTopLevelResources(packageInfo.getResDir(),</span><br><span class="line">packageInfo.getSplitResDirs(), packageInfo.getOverlayDirs(),</span><br><span class="line">packageInfo.getApplicationInfo().sharedLibraryFiles, displayId,</span><br><span class="line">overrideConfiguration, compatInfo, activityToken);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给mResources赋值</span></span><br><span class="line">mResources = resources;</span><br></pre></td></tr></table></figure></p><p><code>ResourcesManager.getInstance()</code>是单例的这样保证了我们每个Context获取的都是同样的资源，resources通过getTopLevelResources方法赋值，而getTopLevelResources方法真正的获取资源的步骤，但主要分三步来创建Resources：</p><ol><li>创建AssetManager对象；</li><li>通过隐藏的addAssetPath方法将资源路径添加给AssetManager；</li><li>拿到AssetManager对象后，便可以创建真正的Resources对象；</li></ol><h3 id="插件如何拿到创建好的Resources资源呢-？"><a href="#插件如何拿到创建好的Resources资源呢-？" class="headerlink" title="插件如何拿到创建好的Resources资源呢 ？"></a>插件如何拿到创建好的Resources资源呢 ？</h3><ol><li><p>在使用前初始化好Resources资源 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建我们自己的Resource</span></span><br><span class="line">String apkPath = Environment.getExternalStorageDirectory().getAbsolutePath() + <span class="string">"/chajian_demo.apk"</span>;</span><br><span class="line"><span class="comment">//创建AssetManager</span></span><br><span class="line">assetManager = AssetManager.class.newInstance();</span><br><span class="line">Method addAssetPathMethod = assetManager.getClass().getDeclaredMethod(<span class="string">"addAssetPath"</span>, String.class);</span><br><span class="line">addAssetPathMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">addAssetPathMethod.invoke(assetManager, apkPath);</span><br><span class="line">Method ensureStringBlocks = AssetManager.class.getDeclaredMethod(<span class="string">"ensureStringBlocks"</span>);</span><br><span class="line">ensureStringBlocks.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ensureStringBlocks.invoke(assetManager);</span><br><span class="line">Resources supResource = getResources();</span><br><span class="line">Log.e(<span class="string">"Main"</span>, <span class="string">"supResource = "</span> + supResource);</span><br><span class="line">newResource = <span class="keyword">new</span> Resources(assetManager, supResource.getDisplayMetrics(), supResource.getConfiguration());</span><br><span class="line">mTheme = newResource.newTheme();</span><br><span class="line">mTheme.setTo(<span class="keyword">super</span>.getTheme())</span><br></pre></td></tr></table></figure></li><li><p>重写getResources和getAssets方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AssetManager <span class="title">getAssets</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> assetManager == <span class="keyword">null</span> ? <span class="keyword">super</span>.getAssets() : assetManager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> newResource == <span class="keyword">null</span> ? <span class="keyword">super</span>.getResources() : newResource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在插件Activity中记得重写getResources方法，毕竟默认使用宿主的Resource：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AssetManager <span class="title">getAssets</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(getApplication() != <span class="keyword">null</span> &amp;&amp; getApplication().getAssets() != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> getApplication().getAssets();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getAssets();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Resources.<span class="function">Theme <span class="title">getTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(getApplication() != <span class="keyword">null</span> &amp;&amp; getApplication().getTheme() != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> getApplication().getTheme();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getTheme();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="http://blog.csdn.net/yulong0809/article/category/6745120" target="_blank" rel="noopener">插件化系列基础</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代理模式（委托模式）&quot;&gt;&lt;a href=&quot;#代理模式（委托模式）&quot; class=&quot;headerlink&quot; title=&quot;代理模式（委托模式）&quot;&gt;&lt;/a&gt;代理模式（委托模式）&lt;/h2&gt;&lt;p&gt;限制对象的直接访问，保护内部对象；&lt;/p&gt;
&lt;h3 id=&quot;静态代理&quot;&gt;&lt;a href=&quot;#静态代理&quot; class=&quot;headerlink&quot; title=&quot;静态代理&quot;&gt;&lt;/a&gt;静态代理&lt;/h3&gt;&lt;p&gt;AIDL中&lt;code&gt;asInterface&lt;/code&gt;方法中有应用到静态代理，如果不在同一进程就会返回Proxy对象，而且几乎所有系统服务采用代理模式。&lt;/p&gt;
&lt;h3 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h3&gt;&lt;p&gt;运行时指定代理类，实现&lt;code&gt;InvocationHandler&lt;/code&gt;接口，重写invoke方法，通过&lt;code&gt;Proxy.newInstance&lt;/code&gt;返回代理对象。分为jdk动态代理和cglib动态代理；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jdk动态代理：基于类的反射机制，而且目标类基于同一的接口，Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理；&lt;/li&gt;
&lt;li&gt;cglib动态代理：借助asm实现，没有jdk动态代理的限制；&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="MultiProcess" scheme="https://hjw541988478.github.io/tags/MultiProcess/"/>
    
      <category term="AIDL" scheme="https://hjw541988478.github.io/tags/AIDL/"/>
    
      <category term="插件化" scheme="https://hjw541988478.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>AIDL基本使用理解</title>
    <link href="https://hjw541988478.github.io/2017/04/AIDL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%90%86%E8%A7%A3/"/>
    <id>https://hjw541988478.github.io/2017/04/AIDL基本使用理解/</id>
    <published>2017-04-24T12:39:00.000Z</published>
    <updated>2018-08-18T15:39:18.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AIDL基本使用"><a href="#AIDL基本使用" class="headerlink" title="AIDL基本使用"></a>AIDL基本使用</h2><p>主要用于IPC，首先建立aidl文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aidl;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getTestStr</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，sync一下便可以看到生成的java文件，保持这样的结构，可以分析下具体用到的接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IBinder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span><span class="params">(String descriptor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IBinder</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Interface</span> </span>&#123;</span><br><span class="line">    <span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动生成的接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyInterface</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTestStr</span><span class="params">(String s)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IMyInterface</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IMyInterface <span class="title">asInterface</span><span class="params">(IBinder binder)</span> </span>&#123;</span><br><span class="line">                &#125; </span><br><span class="line">         </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTransact</span><span class="params">(..)</span> </span>&#123;</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="keyword">implements</span> <span class="title">IMyInterface</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transact</span><span class="params">()</span></span>&#123;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>接着创建文明需要的<code>Service</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG = <span class="string">"MyService"</span>;</span><br><span class="line">        <span class="keyword">private</span> IBinder binder = <span class="keyword">new</span> IMyInterface.Stub() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getTestStr</span><span class="params">(String s)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">                Log.i(TAG, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"我是 Service 返回的字符串"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="meta">@Overrid</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate();</span><br><span class="line">            Log.i(TAG, <span class="string">"onCreat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> binder;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对IMyInterface.Stub进行实例化转形成<code>IBinder</code>，然后在<code>onBinder</code>中返回，其中对我们定义的getTestStr进行了实现，由于我们需要实现的是IPC，因此也需要在AndroidManifest文件中配置成新的进程：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".server.MyService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">"com.mathiasluo.remote"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>注意process属性，默认进程就为包名，如果需要新的名字，则需要完整的包名来配置；<br>Service配置好后，回到Activity中去绑定和启动：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line">                <span class="keyword">private</span> IMyInterface myInterface;</span><br><span class="line">                <span class="keyword">private</span> ServiceConnection serviceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">                        myInterface = IMyInterface.Stub.asInterface(service);</span><br><span class="line">                        Log.i(TAG, <span class="string">"连接Service 成功"</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            String s = myInterface.getTestStr(<span class="string">"我是Activity传来的字符串"</span>);</span><br><span class="line">                            Log.i(TAG, <span class="string">"从Service得到的字符串："</span> + s);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">                        Log.e(TAG, <span class="string">"连接Service失败"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">                    setContentView(R.layout.activity_main);</span><br><span class="line">                    startAndBindService();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAndBindService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Intent service = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, MyService.class);</span><br><span class="line">                    <span class="comment">//startService(service);</span></span><br><span class="line">                    bindService(service, serviceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键点在于<code>ServiceConnection</code>，当服务启动成功后，从<code>onServiceConnected</code>回调方法中拿到服务接口，<code>IMyInterface.stub.asInterface(binder)</code>拿到本地的代理对象，便可以远程调用相关方法。</p><h2 id="AIDL剖析"><a href="#AIDL剖析" class="headerlink" title="AIDL剖析"></a>AIDL剖析</h2><h3 id="Service中实例化的IBinder"><a href="#Service中实例化的IBinder" class="headerlink" title="Service中实例化的IBinder"></a>Service中实例化的IBinder</h3><p>可以看到，<code>IMyInterface.Stub</code>类是静态抽象类，继承了<code>Binder</code>，并且实现了IMyInterface接口，可以解释为啥实例化时为啥需要重新实现接口中的方法，以及可以向上转型成IBinder。</p><h3 id="Activity中的IMyInterface"><a href="#Activity中的IMyInterface" class="headerlink" title="Activity中的IMyInterface"></a>Activity中的IMyInterface</h3><p>在服务连接并成功回调<code>onServiceConnected</code>后，通过<code>IMyInterface.Stub.asInterface(service)</code>转换成<code>IMyInterface</code>，核心在于<code>asInterface</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">aidl</span>.<span class="title">IMyInterface</span> </span>&#123;</span><br><span class="line">        ..........</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> aidl.<span class="function">IMyInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//检查Binder是不是在当前进程</span></span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> aidl.IMyInterface))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((aidl.IMyInterface) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> aidl.IMyInterface.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果<code>Binder</code>在当前进程，则直接返回<code>IMyInterface</code>，否则返回<code>Proxy</code>，其中<code>Proxy</code>构造时需要把在<code>Service</code>中实例化的<code>IBinder</code>带过去，作为服务的代理。<br>当客户端调用服务的接口时，最后会进入<code>mRemote.transact()</code>方法，把数据传输给服务端，然后我们的实例化的<code>Stub</code>类回调<code>onTransact()</code>，再把得到的数据写入返回值发送给客户端，客户端读取值后就返回了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AIDL基本使用&quot;&gt;&lt;a href=&quot;#AIDL基本使用&quot; class=&quot;headerlink&quot; title=&quot;AIDL基本使用&quot;&gt;&lt;/a&gt;AIDL基本使用&lt;/h2&gt;&lt;p&gt;主要用于IPC，首先建立aidl文件：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; aidl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IMyInterface&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;getTestStr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String s)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后，sync一下便可以看到生成的java文件，保持这样的结构，可以分析下具体用到的接口：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;android&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;os&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;IBinder&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; IInterface &lt;span class=&quot;title&quot;&gt;queryLocalInterface&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String descriptor)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;android&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;os&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Binder&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;android&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;os&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;IBinder&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;android&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;os&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Interface&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;IBinder &lt;span class=&quot;title&quot;&gt;asBinder&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 自动生成的接口类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IMyInterface&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;android&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;os&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;IInterface&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getTestStr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String s)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Stub&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;android&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;os&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Binder&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IMyInterface&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; IMyInterface &lt;span class=&quot;title&quot;&gt;asInterface&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(IBinder binder)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onTransact&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(..)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IMyInterface&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;transact&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="MultiProcess" scheme="https://hjw541988478.github.io/tags/MultiProcess/"/>
    
      <category term="AIDL" scheme="https://hjw541988478.github.io/tags/AIDL/"/>
    
  </entry>
  
  <entry>
    <title>LeakCanary源码浅析</title>
    <link href="https://hjw541988478.github.io/2017/03/LeakCanary%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>https://hjw541988478.github.io/2017/03/LeakCanary源码浅析/</id>
    <published>2017-03-02T12:22:00.000Z</published>
    <updated>2018-08-18T15:40:02.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两步使用"><a href="#两步使用" class="headerlink" title="两步使用"></a>两步使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5.1&apos;</span><br><span class="line">  releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&apos;</span><br><span class="line">  testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="keyword">if</span> (LeakCanary.isInAnalyzerProcess(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="comment">// This process is dedicated to LeakCanary for heap analysis.</span></span><br><span class="line">        <span class="comment">// You should not init your app in this process.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      LeakCanary.install(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="LeakCanary-install-this"><a href="#LeakCanary-install-this" class="headerlink" title="LeakCanary.install(this) ?"></a>LeakCanary.install(this) ?</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);</span><br><span class="line">ActivityRefWatcher.installOnIcsPlus(application, refWatcher);</span><br></pre></td></tr></table></figure><p>显然可以看到，<code>RefWatcher</code>用来监控引用的工具，而installOnIcsPlus只是创建了ActivityRefWatcher以及向application注册了一个<code>ActivityLifecycleCallbacks</code>回调函数，最后只在<code>onDestroy</code>处理。</p><ul><li>引用队列：<br>我们常用一个<code>WeakReference&lt;Activity&gt; reference = new WeakReference(activity);</code>，这里我们创建了一个reference来弱引用到某个activity，当这个activity被垃圾回收器回收后，这个reference会被放入内部的<code>ReferenceQueue</code>中。也就是说，从队列ReferenceQueue取出来的所有reference，它们指向的真实对象都已经成功被回收了。</li></ul><h2 id="RefWatcher监控Activity是否被回收"><a href="#RefWatcher监控Activity是否被回收" class="headerlink" title="RefWatcher监控Activity是否被回收 ?"></a>RefWatcher监控Activity是否被回收 ?</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RefWatcher <span class="title">androidWatcher</span><span class="params">(Context context, HeapDump.Listener heapDumpListener, ExcludedRefs excludedRefs)</span> </span>&#123;</span><br><span class="line">    AndroidHeapDumper heapDumper = <span class="keyword">new</span> AndroidHeapDumper(context, leakDirectoryProvider);</span><br><span class="line">    heapDumper.cleanup();</span><br><span class="line">    <span class="keyword">int</span> watchDelayMillis = <span class="number">5000</span>;</span><br><span class="line">    AndroidWatchExecutor executor = <span class="keyword">new</span> AndroidWatchExecutor(watchDelayMillis);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,heapDumpListener, excludedRefs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其中AndroidHeapDumper用来dump堆内存状态，AndoidWatchExecutor用来watch一个引用的监听器。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; retainedKeys;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(Object activity, String referenceName)</span> </span>&#123;</span><br><span class="line">    String key = UUID.randomUUID().toString();</span><br><span class="line">    retainedKeys.add(key);</span><br><span class="line">    <span class="keyword">final</span> KeyedWeakReference reference =<span class="keyword">new</span> KeyedWeakReference(activity, key, referenceName, queue);</span><br><span class="line">    watchExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          ensureGone(reference, watchStartNanoTime);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyedWeakReference</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将activity包装成<code>KeyedWeakReference</code>，然后watchExecutor会去执行<code>ensureGone</code>函数。</p><ol><li>ensureGone首先会调用<code>removeWeaklyReachableReferences</code>把已回收的key从retainedKeys移除，剩下的key都是未被回收的对象；</li><li><code>if(gone(reference))</code>判断key是否存在，若不在则表示已经回收;</li><li><code>gcTrigger.runFc()</code>手动gc，立即回收所有的weakReference；</li><li>再次清理<code>retianedKeys</code>，如果还存在则使用heapDumper收集文件</li><li>确认发生泄漏，调用<code>displayLeakService</code>发生通知；</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>利用<code>application.registerActivityLifecycleCallbacks(lifecycleCallbacks)</code>来监听整个生命周期内的<code>Activity onDestoryed</code>事件;</li><li>当某个<code>Activity</code>被<code>destory</code>后，将它传给<code>RefWatcher</code>去做观测，确保其后续会被正常回收；</li><li><code>RefWatcher</code>首先把<code>Activity</code>使用<code>KeyedWeakReference</code>引用起来，并使用一个<code>ReferenceQueue</code>来记录该<code>KeyedWeakReference</code>指向的对象是否已被回收；</li><li><code>AndroidWatchExecutor</code>会在 5s 后，开始检查这个弱引用内的 Activity 是否被正常回收。判断条件是：若 Activity 被正常回收，那么引用它的<code>KeyedWeakReference</code>会被自动放入<code>ReferenceQueue</code>中。</li><li>判断方式是：先看 Activity 对应的<code>KeyedWeakReference</code>是否已经放入<code>ReferenceQueue</code>中；如果没有，则手动GC:<code>gcTrigger.runGc();</code>，然后再一次判断<code>ReferenceQueue</code>是否已经含有对应的<code>KeyedWeakReference</code>。若还未被回收，则认为可能发生内存泄漏。</li><li>利用<code>HeapAnalyzer</code>对dump的内存情况进行分析并进一步确认，若确定发生泄漏，则利用<code>DisplayLeakService</code>发送通知。</li></ol><h2 id="onDestroy后多久检查"><a href="#onDestroy后多久检查" class="headerlink" title="onDestroy后多久检查?"></a>onDestroy后多久检查?</h2><p>首先向主线程的<code>MessageQueue</code>添加一个<code>IdleHandler</code>，该Handler的作用就是当<code>Looper</code>没有消息处理的时候，才回处理该优先级低的<code>Message</code>；<br>低优先级的任务从<code>backgroundHandler.postDelayed</code>来，等到主线程空闲了，5s后工作现场检查activity是否被回收了；</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li><p>如何创建低优先级的主线程任务，只会在空闲时执行？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> IdleHandler() &#123;..);</span><br></pre></td></tr></table></figure></li><li><p>创建Handler？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandlerThread + Handler / <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br></pre></td></tr></table></figure></li><li><p>是否运行在主线程?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper().getThread() == Thread.currentThread();</span><br></pre></td></tr></table></figure></li><li><p>System.gc是否立马gc?<br>只是建议回收，无法保证真的回收，参考ASOP源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().gc();</span><br><span class="line">enqueueReferences();</span><br><span class="line">System.runFinalization();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enqueueReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Hack. We don't have a programmatic way to wait for the reference queue</span></span><br><span class="line"><span class="comment">    * daemon to move references to the appropriate queues.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="优化LeakCanary"><a href="#优化LeakCanary" class="headerlink" title="优化LeakCanary"></a>优化LeakCanary</h2><ol><li>忽略已知类或Activity<br>通过<code>ExcludedRefs</code>主动添加需要忽略的类，对于Activity，只需要在<code>onActivityDestroyed</code>去排除；</li><li>将内存数据上传至server<br>提供了<code>AbstractAnalysisResultServcice</code>这个<code>IntentService</code>，继承实现该类上传即可；</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="http://blog.csdn.net/cloud_huan/article/details/53081120" target="_blank" rel="noopener">LeakCanary核心原理源码浅析</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;两步使用&quot;&gt;&lt;a href=&quot;#两步使用&quot; class=&quot;headerlink&quot; title=&quot;两步使用&quot;&gt;&lt;/a&gt;两步使用&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  debugCompile &amp;apos;com.squareup.leakcanary:leakcanary-android:1.5.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  releaseCompile &amp;apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  testCompile &amp;apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ExampleApplication&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Application&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onCreate();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (LeakCanary.isInAnalyzerProcess(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// This process is dedicated to LeakCanary for heap analysis.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// You should not init your app in this process.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      LeakCanary.install(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="LeanCanary" scheme="https://hjw541988478.github.io/tags/LeanCanary/"/>
    
      <category term="MemeoryLeak" scheme="https://hjw541988478.github.io/tags/MemeoryLeak/"/>
    
  </entry>
  
  <entry>
    <title>Java线程常用场景</title>
    <link href="https://hjw541988478.github.io/2016/11/Java%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://hjw541988478.github.io/2016/11/Java线程常用场景/</id>
    <published>2016-11-07T12:04:00.000Z</published>
    <updated>2018-08-18T15:44:10.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何让两个线程依次执行？"><a href="#如何让两个线程依次执行？" class="headerlink" title="如何让两个线程依次执行？"></a>如何让两个线程依次执行？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         printNumber(<span class="string">"A"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"B 开始等待 A"</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">             A.join();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          printNumber(<span class="string">"B"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  B.start();</span><br><span class="line">  A.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>threadA.join()</code>，让线程B等待线程A执行完后，再执行自己；<br><a id="more"></a></p><h2 id="如何让两个线程交叉有序执行？"><a href="#如何让两个线程交叉有序执行？" class="headerlink" title="如何让两个线程交叉有序执行？"></a>如何让两个线程交叉有序执行？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line">* 输出A <span class="number">1</span>, B <span class="number">1</span>, B <span class="number">2</span>, B <span class="number">3</span>, A <span class="number">2</span>, A <span class="number">3</span></span><br><span class="line">*/</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A 1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"A 2"</span>);</span><br><span class="line">                System.out.println(<span class="string">"A 3"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"B 1"</span>);</span><br><span class="line">                System.out.println(<span class="string">"B 2"</span>);</span><br><span class="line">                System.out.println(<span class="string">"B 3"</span>);</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    A.start();</span><br><span class="line">    B.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用共享锁object以及<code>synchronized</code>关键字，A拿到锁后打印依次然后wait，B从等待变成运行打印结束最后notify，唤醒A，A继续执行结束；</p><h2 id="四个线程-A-B-C-D，其中-D-要等到-A-B-C-全执行完毕后才执行，而且-A-B-C-是同步运行的？"><a href="#四个线程-A-B-C-D，其中-D-要等到-A-B-C-全执行完毕后才执行，而且-A-B-C-是同步运行的？" class="headerlink" title="四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的？"></a>四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runDAfterABC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> worker = <span class="number">3</span>;</span><br><span class="line">  CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(worker);</span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"D is waiting for other three threads"</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">             System.out.println(<span class="string">"All done, D starts working"</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> threadName=<span class="string">'A'</span>; threadName &lt;= <span class="string">'C'</span>; threadName++) &#123;</span><br><span class="line">      <span class="keyword">final</span> String tN = String.valueOf(threadName);</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              System.out.println(tN + <span class="string">"is working"</span>);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">              System.out.println(tN + <span class="string">"finished"</span>);</span><br><span class="line">              countDownLatch.countDown();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>CountDownLatch</code>共享倒计时器，初始为3，等待线程调用await等待到0时继续执行，其他线程调用countDown减一，直到为0；</p><h2 id="三个运动员各自准备，等到三个人都准备好后，再一起跑"><a href="#三个运动员各自准备，等到三个人都准备好后，再一起跑" class="headerlink" title="三个运动员各自准备，等到三个人都准备好后，再一起跑"></a>三个运动员各自准备，等到三个人都准备好后，再一起跑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runABCWhenAllReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> runner = <span class="number">3</span>;</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(runner);</span><br><span class="line">    <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> runnerName=<span class="string">'A'</span>; runnerName &lt;= <span class="string">'C'</span>; runnerName++) &#123;</span><br><span class="line">        <span class="keyword">final</span> String rN = String.valueOf(runnerName);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> prepareTime = random.nextInt(<span class="number">10000</span>) + <span class="number">100</span>;</span><br><span class="line">                System.out.println(rN + <span class="string">"is preparing for time:"</span> + prepareTime);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(prepareTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(rN + <span class="string">"is prepared, waiting for others"</span>);</span><br><span class="line">                    cyclicBarrier.await(); <span class="comment">// 当前运动员准备完毕，等待别人准备好</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(rN + <span class="string">"starts running"</span>);</span><br><span class="line">                <span class="comment">// 所有运动员都准备好了，一起开始跑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现线程互相等待的需求，利用<code>CyclicBarrier</code>，初始化时设置同时等待的线程数，当线程准备好后调用await操作，直到所有的线程都准备好了，才开始统一执行；</p><h2 id="子线程完成某件任务后，把得到的结果回传给主线程"><a href="#子线程完成某件任务后，把得到的结果回传给主线程" class="headerlink" title="子线程完成某件任务后，把得到的结果回传给主线程"></a>子线程完成某件任务后，把得到的结果回传给主线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doTaskWithResultInWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Callable&lt;Integer&gt; callable = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Task starts"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">            result += i;</span><br><span class="line">      &#125;</span><br><span class="line">        System.out.println(<span class="string">"Task finished and return result"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">  <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"Before futureTask.get()"</span>);</span><br><span class="line">      System.out.println(<span class="string">"Result:"</span> + futureTask.get());</span><br><span class="line">      System.out.println(<span class="string">"After futureTask.get()"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用<code>Callable</code>配合<code>FutureTask</code>以及其get方法获取返回结果，当然get会阻塞主线程；<br>如果不希望阻塞主线程可以考虑使用<code>ExecutorService</code>，把<code>FutureTask</code>放入线程池去管理执行；</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzIyMjQ0MTU0NA==&amp;mid=2247484081&amp;idx=1&amp;sn=8f4f2d6094a991264f1441df82e82d8a&amp;chksm=e82c3b96df5bb280ca6f08e0263d6ed1ea6554ff2dcd6b22510cf7da397e03018c860a156fac&amp;scene=0#rd" target="_blank" rel="noopener">Java 里如何实现线程间通信</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何让两个线程依次执行？&quot;&gt;&lt;a href=&quot;#如何让两个线程依次执行？&quot; class=&quot;headerlink&quot; title=&quot;如何让两个线程依次执行？&quot;&gt;&lt;/a&gt;如何让两个线程依次执行？&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;demo2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Thread A = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         printNumber(&lt;span class=&quot;string&quot;&gt;&quot;A&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Thread B = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;B 开始等待 A&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             A.join();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          printNumber(&lt;span class=&quot;string&quot;&gt;&quot;B&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  B.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  A.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用&lt;code&gt;threadA.join()&lt;/code&gt;，让线程B等待线程A执行完后，再执行自己；&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hjw541988478.github.io/categories/Java/"/>
    
    
      <category term="MultiThread" scheme="https://hjw541988478.github.io/tags/MultiThread/"/>
    
  </entry>
  
  <entry>
    <title>游戏2048原理探索与实现</title>
    <link href="https://hjw541988478.github.io/2016/09/%E6%B8%B8%E6%88%8F2048%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://hjw541988478.github.io/2016/09/游戏2048原理探索与实现/</id>
    <published>2016-09-22T13:22:00.000Z</published>
    <updated>2018-08-18T15:43:07.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>2048有着简单的游戏规则有趣的游戏过程，在早年的时候着实火了一把，以致在后来也出现了很多不同的版本。但主要的规则都是相似的，4*4的格子，数字随机出现2或者4，手指进行上下左右的滑动，所有数字向滑动方向靠拢，相同的相邻数字相加合并，合并成功或者移动后在剩下的空格中随机出现新的数字，直到合并出现2048，则挑战成功。<br><a id="more"></a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="游戏布局"><a href="#游戏布局" class="headerlink" title="游戏布局"></a>游戏布局</h3><p>游戏主布局为一个4*4的面板，想要实现该布局的方式有很多种，比如继承View手动计算每个格子的坐标，但是会比较复杂，鉴于<code>GridLayout</code>在4.0的引入，比较适用于本游戏的布局，然后只需要监控上下左右不同的手势方向执行不同的逻辑运算便可以达到效果。接下来的重点是每个格子的实现，它是根据不同的数值表现出来的不同的背景色值，其尺寸大小是根据不同的分辨率下动态设置的。</p><h3 id="游戏算法"><a href="#游戏算法" class="headerlink" title="游戏算法"></a>游戏算法</h3><p>主要是小格子的产生、合并算法要求高点，如果过于麻烦效率太低势必会造成游戏卡顿，影响体验，于是这里采用的是思路比较传统的做法：<br>在进行上下左右滑动时，遍历每一行(列)，如果没有数字用0来代替空格，如某一行的数字为4 4 0 2，则相同的合并后加入List中，否则直接加入，操作后的顺序即8 2，并从滑动的方向重新放置List中的数字，直到遍历所有行(列)。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="小格子设计"><a href="#小格子设计" class="headerlink" title="小格子设计"></a>小格子设计</h3><p>让GameBoxView继承<code>FrameLayout</code>，并根据设置的数字改变相应的颜色，对外提供setBoxNum()方法，并加入一个TextView设置数字背景颜色边距和数字值，整个实现起来较为简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.text.TextPaint;</span><br><span class="line"><span class="keyword">import</span> android.view.Gravity;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.FrameLayout;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> com.example.game2048.GameApp;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameBoxView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gBoxNumVal;</span><br><span class="line">    <span class="keyword">private</span> TextView gBoxView;</span><br><span class="line">    <span class="keyword">private</span> FrameLayout.LayoutParams gBoxParams;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小格子的初始化数字值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GameBoxView</span><span class="params">(Context context, <span class="keyword">int</span> gBoxNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        <span class="keyword">this</span>.gBoxNumVal = gBoxNum;</span><br><span class="line">        initGameBoxView();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initGameBoxView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setBackgroundColor(Color.GRAY);</span><br><span class="line">        gBoxView = <span class="keyword">new</span> TextView(getContext());</span><br><span class="line">        setBoxNumber(gBoxNumVal);</span><br><span class="line">        <span class="keyword">int</span> gameLines = GameApp.mSp.getInt(GameApp.KEY_GAME_LINES, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 根据不同的宫格设置不同的字体大小</span></span><br><span class="line">        <span class="keyword">if</span> (gameLines == <span class="number">4</span>) &#123;</span><br><span class="line">            gBoxView.setTextSize(<span class="number">35</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gameLines == <span class="number">5</span>) &#123;</span><br><span class="line">            gBoxView.setTextSize(<span class="number">25</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            gBoxView.setTextSize(<span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        TextPaint tp = gBoxView.getPaint();</span><br><span class="line">        tp.setFakeBoldText(<span class="keyword">true</span>);</span><br><span class="line">        gBoxView.setGravity(Gravity.CENTER);</span><br><span class="line">        gBoxParams = <span class="keyword">new</span> FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT,</span><br><span class="line">                LayoutParams.MATCH_PARENT);</span><br><span class="line">        gBoxParams.setMargins(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">        addView(gBoxView, gBoxParams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getBoxItemView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gBoxView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBoxNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gBoxNumVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBoxNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gBoxNumVal = num;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            gBoxView.setText(<span class="string">""</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            gBoxView.setText(<span class="string">""</span> + num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (num) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                gBoxView.setBackgroundColor(<span class="number">0x00000000</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                gBoxView.setBackgroundColor(<span class="number">0xffeee5db</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                gBoxView.setBackgroundColor(<span class="number">0xffeee0ca</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                gBoxView.setBackgroundColor(<span class="number">0xfff2c17a</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">                gBoxView.setBackgroundColor(<span class="number">0xfff59667</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">                gBoxView.setBackgroundColor(<span class="number">0xfff68c6f</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">                gBoxView.setBackgroundColor(<span class="number">0xfff66e3c</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">128</span>:</span><br><span class="line">                gBoxView.setBackgroundColor(<span class="number">0xffedcf74</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">256</span>:</span><br><span class="line">                gBoxView.setBackgroundColor(<span class="number">0xffedcc64</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">512</span>:</span><br><span class="line">                gBoxView.setBackgroundColor(<span class="number">0xffedc854</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1024</span>:</span><br><span class="line">                gBoxView.setBackgroundColor(<span class="number">0xffedc54f</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2048</span>:</span><br><span class="line">                gBoxView.setBackgroundColor(<span class="number">0xffedc32e</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                gBoxView.setBackgroundColor(<span class="number">0xff3c4a34</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先在构造时确定显示的数字，从而确定小格子的背景颜色，默认都是灰色，然后设置小格子的边距，整个的实现效果如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016/09/游戏2048原理探索与实现/game2048_box.png" alt="小格子效果图" title="">                </div>                <div class="image-caption">小格子效果图</div>            </figure><br>可以看到的是对于不同的数字对比效果还是很明显的，也达到了我们的目的。</p><h3 id="游戏面板设计"><a href="#游戏面板设计" class="headerlink" title="游戏面板设计"></a>游戏面板设计</h3><p>在初始化游戏矩阵时，首先需要移除之前的游戏布局，并获取最高成绩，并随机添加2个小格子作为初始格子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化游戏矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initGameMatrix</span><span class="params">()</span></span>&#123;</span><br><span class="line">    removeAllViews();</span><br><span class="line">    mHistoryScore = <span class="number">0</span>;</span><br><span class="line">    GameApp.CURRENT_SCORE = <span class="number">0</span>;</span><br><span class="line">    GameApp.mGameLines = GameApp.mSp.getInt(GameApp.KEY_GAME_LINES,<span class="number">4</span>);</span><br><span class="line">    mGameLines = GameApp.mGameLines;</span><br><span class="line">    mGameMatrixViews = <span class="keyword">new</span> GameBoxView[mGameLines][mGameLines];</span><br><span class="line">    mGameMatrixHistory = <span class="keyword">new</span> <span class="keyword">int</span>[mGameLines][mGameLines];</span><br><span class="line">    mTmpBoxNumList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    mBlankGameBoxes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    mHighestScore = GameApp.mSp.getInt(GameApp.KEY_HIGH_SCORE , <span class="number">0</span>);</span><br><span class="line">    setColumnCount(mGameLines);</span><br><span class="line">    setRowCount(mGameLines);</span><br><span class="line">    <span class="comment">// 设置触摸事件监听用于处理滑动事件</span></span><br><span class="line">    setOnTouchListener(<span class="keyword">this</span>);</span><br><span class="line">    DisplayMetrics metrics = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">    WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    Display display = wm.getDefaultDisplay();</span><br><span class="line">    display.getMetrics(metrics);</span><br><span class="line">    GameApp.mGameBoxWidth = metrics.widthPixels / GameApp.mGameLines;</span><br><span class="line">    <span class="comment">//根据小格子宽度初始化格子</span></span><br><span class="line">    initGameView(GameApp.mGameBoxWidth);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initGameView</span><span class="params">(<span class="keyword">int</span> cardSize)</span></span>&#123;</span><br><span class="line">    removeAllViews();</span><br><span class="line">    GameBoxView gameBoxView;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mGameLines; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; mGameLines ; j++)&#123;</span><br><span class="line">            gameBoxView = <span class="keyword">new</span> GameBoxView(getContext(),<span class="number">0</span>);</span><br><span class="line">            addView(gameBoxView,cardSize,cardSize);</span><br><span class="line">            mGameMatrixViews[i][j] = gameBoxView;</span><br><span class="line">            mBlankGameBoxes.add(<span class="keyword">new</span> Point(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化随机2个数字</span></span><br><span class="line">    addRandomNum();</span><br><span class="line">    addRandomNum();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据剩余的格子位置坐标初始化小格子</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addRandomNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    getBlankGameBoxes();</span><br><span class="line">    <span class="keyword">if</span> (mBlankGameBoxes.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> randomNumPos = (<span class="keyword">int</span>) Math.random() * mBlankGameBoxes.size();</span><br><span class="line">        Point randomPoint = mBlankGameBoxes.get(randomNumPos);</span><br><span class="line">        mGameMatrixViews[randomPoint.x][randomPoint.y]</span><br><span class="line">        <span class="comment">// 只会出现2或者4</span></span><br><span class="line">                .setBoxNumber(Math.random() &gt; <span class="number">0.2</span>d ? <span class="number">2</span>: <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 增加缩放动画过渡自然些</span></span><br><span class="line">        animCreate(mGameMatrixViews[randomPoint.x][randomPoint.y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="滑动事件处理"><a href="#滑动事件处理" class="headerlink" title="滑动事件处理"></a>滑动事件处理</h3><p>游戏中只存在着上下左右四个方向的滑动，整个处理流程大致如下：滑动事件产生-&gt;滑动事件结束-&gt;判断滑动方向-&gt;游戏布局重新处理-&gt;添加新的随机数字-&gt;游戏是否结束。<br>下面是对移动方向的处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction())&#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                saveHistoryMatrix();</span><br><span class="line">                mStartX = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">                mStartY = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                mEndX = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">                mEndY = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">                judgeDirection(mEndX - mStartX , mEndY - mStartY);</span><br><span class="line">                <span class="keyword">if</span> (isMoved()) &#123;</span><br><span class="line">                    addRandomNum();</span><br><span class="line">                    GameActivity.getGameActivity().setScore(GameApp.CURRENT_SCORE, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                checkCompleted();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在<code>onTouch</code>方法中捕获<code>ACTION_DOWN</code>事件，预先保存目前状态的游戏数据，记录起点坐标，在手指抬起后，捕获<code>ACTION_UP</code>事件，记录终点坐标随之判断滑动的方向，合并游戏数据，添加一个新的随机数字并检查游戏是否符合达到结束的条件。<br>下面是向上滑动后进行的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swipeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; mGameLines ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; mGameLines ; j ++) &#123;</span><br><span class="line">                <span class="keyword">int</span> currentNum = mGameMatrixViews[j][i].getBoxNumber();</span><br><span class="line">                <span class="keyword">if</span> (currentNum != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mLastBoxNum == -<span class="number">1</span>) &#123;</span><br><span class="line">                        mLastBoxNum = currentNum;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mLastBoxNum == currentNum)&#123;</span><br><span class="line">                            mTmpBoxNumList.add(mLastBoxNum * <span class="number">2</span>);</span><br><span class="line">                            GameApp.CURRENT_SCORE += mLastBoxNum * <span class="number">2</span>;</span><br><span class="line">                            mLastBoxNum = -<span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mTmpBoxNumList.add(mLastBoxNum);</span><br><span class="line">                            mLastBoxNum = currentNum;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mLastBoxNum != -<span class="number">1</span>)&#123;</span><br><span class="line">                mTmpBoxNumList.add(mLastBoxNum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mTmpBoxNumList.size() ; j ++)&#123;</span><br><span class="line">                mGameMatrixViews[j][i].setBoxNumber(mTmpBoxNumList.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = mTmpBoxNumList.size(); m &lt; mGameLines; m ++)&#123;</span><br><span class="line">                mGameMatrixViews[m][i].setBoxNumber(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mLastBoxNum = -<span class="number">1</span>;</span><br><span class="line">            mTmpBoxNumList.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>通过外层循环遍历每一列，再通过内层循环遍历每一行，对相同的数字进行合并，并通过 mLastBoxNum 标识区分是否已经进行了合并，对于已经合并后的数字并不会与下个数字再次进行合并，最后将处理后的数字重新设置到游戏面板，从而完成了整个滑动过程。</p><h3 id="判断游戏结束"><a href="#判断游戏结束" class="headerlink" title="判断游戏结束"></a>判断游戏结束</h3><p>游戏结束意味着达到了设定的目标分数值，或者失败表示着所有的方块无法再次移动。对于游戏数据来说，成功即意味着游戏矩阵含有了设定分数值的方块，而失败意味着每个小方块四个方向都不存在与其相同的小方块。<br>主要操作如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCompleted</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = checkNums();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (GameApp.CURRENT_SCORE &gt; mHighestScore)&#123;</span><br><span class="line">                SharedPreferences.Editor editor = GameApp.mSp.edit();</span><br><span class="line">                editor.putInt(GameApp.KEY_HIGH_SCORE, GameApp.CURRENT_SCORE);</span><br><span class="line">                editor.apply();</span><br><span class="line">                GameActivity.getGameActivity().setScore(GameApp.CURRENT_SCORE, <span class="number">1</span>);</span><br><span class="line">                GameApp.CURRENT_SCORE = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(getContext());</span><br><span class="line">            builder.setTitle(<span class="string">"GameOver"</span>)</span><br><span class="line">                    .setPositiveButton(<span class="string">"Again"</span>,</span><br><span class="line">                            <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                                    startGame();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;).create().show();</span><br><span class="line">            GameApp.CURRENT_SCORE = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">2</span>) &#123;</span><br><span class="line">            AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(getContext());</span><br><span class="line">            builder.setTitle(<span class="string">"Mission Accomplished"</span>)</span><br><span class="line">                    .setPositiveButton(<span class="string">"Again"</span>,</span><br><span class="line">                            <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                                    startGame();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">                    .setNegativeButton(<span class="string">"Continue"</span>,</span><br><span class="line">                            <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                                    SharedPreferences.Editor editor = GameApp.mSp.edit();</span><br><span class="line">                                    <span class="keyword">if</span> (mTargetScore == <span class="number">1024</span>)&#123;</span><br><span class="line">                                        editor.putInt(GameApp.KEY_GAME_GOAL,<span class="number">2048</span>);</span><br><span class="line">                                        mTargetScore = <span class="number">2048</span>;</span><br><span class="line">                                        GameActivity.getGameActivity().setGoal(<span class="number">2048</span>);</span><br><span class="line">                                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mTargetScore == <span class="number">2048</span>)&#123;</span><br><span class="line">                                        editor.putInt(GameApp.KEY_GAME_GOAL,<span class="number">4096</span>);</span><br><span class="line">                                        mTargetScore = <span class="number">4096</span>;</span><br><span class="line">                                        GameActivity.getGameActivity().setGoal(<span class="number">4096</span>);</span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        editor.putInt(GameApp.KEY_GAME_GOAL,<span class="number">4096</span>);</span><br><span class="line">                                        mTargetScore = <span class="number">4096</span>;</span><br><span class="line">                                        GameActivity.getGameActivity().setGoal(<span class="number">4096</span>);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    editor.apply();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;).create().show();</span><br><span class="line">                GameApp.CURRENT_SCORE = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最终游戏实现效果图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016/09/游戏2048原理探索与实现/game2048.jpg" alt="最终效果图" title="">                </div>                <div class="image-caption">最终效果图</div>            </figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一步步分析来看，2048游戏的核心就是随机数字的生成，合并同行/同列数字，重新布局，检查游戏是否结束，关键还是对于游戏玩法转化成代码的理解能力，需要加强对日常业务的思考，对于问题转化成解决问题的模型的能力。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="http://blog.csdn.net/eclipsexys/article/details/47405045" target="_blank" rel="noopener">Android 群英传</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;2048有着简单的游戏规则有趣的游戏过程，在早年的时候着实火了一把，以致在后来也出现了很多不同的版本。但主要的规则都是相似的，4*4的格子，数字随机出现2或者4，手指进行上下左右的滑动，所有数字向滑动方向靠拢，相同的相邻数字相加合并，合并成功或者移动后在剩下的空格中随机出现新的数字，直到合并出现2048，则挑战成功。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="CustomView" scheme="https://hjw541988478.github.io/tags/CustomView/"/>
    
      <category term="RandomNumber" scheme="https://hjw541988478.github.io/tags/RandomNumber/"/>
    
  </entry>
  
  <entry>
    <title>MultiDex65535探索</title>
    <link href="https://hjw541988478.github.io/2016/07/MultiDex65535%E6%8E%A2%E7%B4%A2/"/>
    <id>https://hjw541988478.github.io/2016/07/MultiDex65535探索/</id>
    <published>2016-07-03T11:22:00.000Z</published>
    <updated>2018-08-18T15:41:37.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><blockquote><p>UNEXPECTED TOP-LEVEL EXCEPTION: java.lang.IllegalArgumentException: method ID not in [0, 0xffff]: 65536<br>Dex文件中保存所有classes的方法个数的变量范围值在<code>0~65535</code>之间，但随着业务一直在增长，引入到的库以及业务代码越来越多，超过这个限制只是时间问题。<br>一般来说 APK 安装的流程大多是这样构成的，首先复制apk文件到<code>data/app</code>目录下，然后解压扫描安装包将dex文件安装到<code>data/dalvik-cache</code>目录下，同时在<code>data/data</code>目录下创建以APK包名的应用数据目录。由于5.0及以上版本ART模式的存在，app第一次安装之后会进行一次预编译，如果这时候发现了<code>classes(..N).dex</code>文件的存在就会将他们最终合成为一个<code>.oat</code>的文件。<br><a id="more"></a></p></blockquote><h2 id="官方方案"><a href="#官方方案" class="headerlink" title="官方方案"></a>官方方案</h2><ol><li>在gradle脚本里写上:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 21</span><br><span class="line">    buildToolsVersion &quot;21.1.0&quot;</span><br><span class="line"> </span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        minSdkVersion 14</span><br><span class="line">        targetSdkVersion 21</span><br><span class="line">        ...</span><br><span class="line"> </span><br><span class="line">        // Enabling multidex support.</span><br><span class="line">        multiDexEnabled true</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">dependencies &#123;</span><br><span class="line">compile &apos;com.android.support:multidex:1.0.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>buildTools 版本在 21 之上 ，同时打开 multidex ，由此产生多 dex。</p><ol start="2"><li>Application中重写 attachBaseContext :<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">    MultiDex.install(<span class="keyword">this</span>);     </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>此时大功告成，但经过不同机型测试后发现了如下的问题：</p><ul><li>第二个dex文件太大导致打开时发生ANR</li></ul><h2 id="解决ANR"><a href="#解决ANR" class="headerlink" title="解决ANR"></a>解决ANR</h2><p>ANR 产生的原因一般是操作在 5s 内无法完成。思考下 apk 的加载流程，首先是首次安装完点击图标，由于此时 apk 的进程尚未启动，于是从该apk抽取<code>classes.dex(主dex)</code>进行加载，同时触发一次 dexopt。此时 App 的laucherActivity准备启动 ，同时触发Application启动，之后Application的<code>attachBaseContext()</code>方法调用，这时候<code>MultiDex.install()</code>调用，classes2.dex(第2个dex) 被install，再次触发dexopt，然后Applicaition的<code>onCreate()</code>执行，然后launcherActivity开始执行。<br>在第二个 dex 较大的情况下必然会阻塞线程造成 ANR。那有什么好的方案呢？</p><p>我们先看看源码，从<code>MultiDex.install()</code>进去看看:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Patches the application context class loader by appending extra dex files </span></span><br><span class="line"><span class="comment"> * loaded from the application apk. This method should be called in the </span></span><br><span class="line"><span class="comment"> * attachBaseContext of your &#123;<span class="doctag">@link</span> Application&#125;, see </span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> MultiDexApplication&#125; for more explanation and an example. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context application context. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RuntimeException if an error occurred preventing the classloader </span></span><br><span class="line"><span class="comment"> *         extension. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context)</span> </span>&#123;  </span><br><span class="line">    Log.i(TAG, <span class="string">"install"</span>);  </span><br><span class="line">  </span><br><span class="line">    ......  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        ApplicationInfo applicationInfo = getApplicationInfo(context);  </span><br><span class="line">        <span class="keyword">if</span> (applicationInfo == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// Looks like running on a test Context, so just return without patching.  </span></span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">synchronized</span> (installedApk) &#123;  </span><br><span class="line">            String apkPath = applicationInfo.sourceDir;  </span><br><span class="line">            <span class="comment">// installedApk的类型是：Set&lt;String&gt;。  </span></span><br><span class="line">            <span class="comment">// 如果这个apk已经安装，则不重复安装。  </span></span><br><span class="line">            <span class="keyword">if</span> (installedApk.contains(apkPath)) &#123;  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            installedApk.add(apkPath);  </span><br><span class="line">  </span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 类加载器应该直接或间接继承于BaseDexClassLoader。  </span></span><br><span class="line">            <span class="comment">// 修改BaseDexClassLoader类中的DexPathList pathList字段，追加额外的DEX文件项。  </span></span><br><span class="line">            <span class="comment">/* The patched class loader is expected to be a descendant of </span></span><br><span class="line"><span class="comment">             * dalvik.system.BaseDexClassLoader. We modify its </span></span><br><span class="line"><span class="comment">             * dalvik.system.DexPathList pathList field to append additional DEX </span></span><br><span class="line"><span class="comment">             * file entries. </span></span><br><span class="line"><span class="comment">             */</span>  </span><br><span class="line">            ClassLoader loader;  </span><br><span class="line">  </span><br><span class="line">            ......  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// dex将会输出到SECONDARY_FOLDER_NAME目录。  </span></span><br><span class="line">            File dexDir = <span class="keyword">new</span> File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);  </span><br><span class="line">            List&lt;File&gt; files = MultiDexExtractor.load(context, applicationInfo, dexDir, <span class="keyword">false</span>);  </span><br><span class="line">            <span class="comment">// 校验这些zip文件是否合法。  </span></span><br><span class="line">            <span class="keyword">if</span> (checkValidZipFiles(files)) &#123;  </span><br><span class="line">                <span class="comment">// 安装提取出来的zip文件。  </span></span><br><span class="line">                installSecondaryDexes(loader, dexDir, files);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                Log.w(TAG, <span class="string">"Files were not valid zip files.  Forcing a reload."</span>);  </span><br><span class="line">                <span class="comment">// 最后一个参数是true，代表强制加载。  </span></span><br><span class="line">                <span class="comment">// Try again, but this time force a reload of the zip file.  </span></span><br><span class="line">                files = MultiDexExtractor.load(context, applicationInfo, dexDir, <span class="keyword">true</span>);  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">// 校验这些zip文件是否合法。  </span></span><br><span class="line">                <span class="keyword">if</span> (checkValidZipFiles(files)) &#123;  </span><br><span class="line">                    <span class="comment">// 安装提取出来的zip文件。  </span></span><br><span class="line">                    installSecondaryDexes(loader, dexDir, files);  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    <span class="comment">// Second time didn't work, give up  </span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Zip files were not valid."</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        Log.e(TAG, <span class="string">"Multidex installation failure"</span>, e);  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Multi dex installation failed ("</span> + e.getMessage() + <span class="string">")."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    Log.i(TAG, <span class="string">"install done"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经过层层的分析可以了解到多 dex 加载的时序图大概如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016/07/MultiDex65535探索/multidex_sequence_diagram.png" alt="时序图" title="">                </div>                <div class="image-caption">时序图</div>            </figure><br>这样看来<code>MultiDex.install()</code>始终在主线程中进行加载，确实是这样子，由于第二个 dex 太大导致 ANR。这么说有没更好的方案既能同步加载第二个 dex 又不卡住 UI 线程呢？</p><h2 id="异步加载-dex"><a href="#异步加载-dex" class="headerlink" title="异步加载 dex"></a>异步加载 dex</h2><p>线程异步 or 进程异步？如果是线程异步的话，无法预知 install 加载完成的时间，这时候进程需要第二个 dex 的信息的话岂不是会发生异常，显然这是行不通的。因此最终的解决方案就是需要放在进程异步加载上。在阅读了相关的博客后，得到了一个很重要的结论：在安装完启动后是第二个 dex 进行 dexopt 花费了更多的时间。结合之前对源码的理解，可以把问题的关注点转化为，在不ANR的前提下完成dexopt，这样以后也不会需要再次dexopt，由此便可以直接在 UI 线程install dex。<br>对于整个思路的流程图如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016/07/MultiDex65535探索/asyn_dex_load.png" alt="进程异步加载 dex图" title="">                </div>                <div class="image-caption">进程异步加载 dex图</div>            </figure></p><ol><li><p>首先是需要在 Application 中修改的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">    Log.d(<span class="string">"loadDex"</span>, <span class="string">"App attachBaseContext "</span>);</span><br><span class="line">    <span class="keyword">if</span> (!isDexLoadProcessRunning()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123;<span class="comment">//&gt;=5.0的系统默认对dex进行oat优化</span></span><br><span class="line">            <span class="keyword">if</span> (has2ndDexOptUndone(base))&#123;</span><br><span class="line">                waitForDexopt(base);</span><br><span class="line">            &#125;</span><br><span class="line">            MultiDex.install (<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"><span class="number">2</span>. 相关方法:</span><br><span class="line">```java</span><br><span class="line"><span class="comment">//neead wait for dexopt</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">has2ndDexOptUndone</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">String flag = get2ndDexSHA1(context);</span><br><span class="line">Log.d(“loadDex”, “dex2-sha1 “ + flag);</span><br><span class="line">SharedPreferences sp = context.getSharedPreferences(</span><br><span class="line">PackageUtils.getPackageInfo(context). versionName, MODE_MULTI_PROCESS);</span><br><span class="line">String saveValue = sp.getString(KEY_DEX2_SHA1, “”);</span><br><span class="line"><span class="keyword">return</span> flag != <span class="keyword">null</span> &amp;&amp; !flag.equals(saveValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitForDexopt</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">ComponentName componentName = <span class="keyword">new</span></span><br><span class="line">ComponentName(getPackageName(), DexLoadActivity.class.getName());</span><br><span class="line">intent.setComponent(componentName);</span><br><span class="line">intent.putExtra(“IS_DO_2NDDEX_OPT”,<span class="keyword">true</span>);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">base.startActivity(intent);</span><br><span class="line"><span class="keyword">long</span> startWait = System.currentTimeMillis ();</span><br><span class="line"><span class="keyword">long</span> waitTime = <span class="number">10</span> * <span class="number">1000</span> ;</span><br><span class="line"><span class="keyword">while</span> (has2ndDexOptUndone(base)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">long</span> nowWait = System.currentTimeMillis() - startWait;</span><br><span class="line">Log.d(“loadDex” , “wait ms :” + nowWait);</span><br><span class="line"><span class="keyword">if</span> (nowWait &gt;= waitTime) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">200</span> );</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>加载 dex 进程的 Activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安装完成之后第一次启动时,classes2.dex的dexopt花费了更多的时间</span></span><br><span class="line"><span class="comment"> * 在不阻塞UI线程的前提下，完成dexopt，以后都不需要再次dexopt在UI线程install dex 了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexLoadActivity</span> <span class="keyword">extends</span> <span class="title">FinishActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_load_dex);</span><br><span class="line">        <span class="keyword">new</span> LoadDexTask().execute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LoadDexTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">doInBackground</span><span class="params">(Object[] params)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MultiDex.install(getApplication());</span><br><span class="line">                Log.d(<span class="string">"loadDex"</span> , <span class="string">"install finish"</span> );</span><br><span class="line">                ((GameAsstApplication) getApplication()).installFinish(getApplication());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.e(<span class="string">"loadDex"</span> , e.getLocalizedMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            Log.d( <span class="string">"loadDex"</span>, <span class="string">"get install finish"</span>);</span><br><span class="line">            finish();</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cannot backpress</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其配置描述：</span></span><br><span class="line">&lt;activity</span><br><span class="line">        android:name=<span class="string">".client.DexLoadActivity"</span></span><br><span class="line">        android:launchMode= <span class="string">"singleTask"</span></span><br><span class="line">        android:process= <span class="string">":mini"</span></span><br><span class="line">        android:exported = <span class="string">"false"</span></span><br><span class="line">        android:theme=<span class="string">"@android:style/Theme.Translucent.NoTitleBar.Fullscreen"</span></span><br><span class="line">        android:alwaysRetainTaskState= <span class="string">"false"</span></span><br><span class="line">        android:excludeFromRecents= <span class="string">"true"</span></span><br><span class="line">        android:screenOrientation= <span class="string">"portrait"</span>/&gt;</span><br></pre></td></tr></table></figure></li></ol><p>在<code>Application</code>启动的时候会检测dexopt是否已经完成过，（检测方式是查看sp文件是否有dex文件的SHA1-Digest记录，这里要两个进程读取该sp,读取模式是MODE_MULTI_PROCESS）。如果没有就启动DexLoadActivity(属于：mini进程) ,否则就直接install dex。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207151651&amp;idx=1&amp;sn=9eab282711f4eb2b4daf2fbae5a5ca9a&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd" target="_blank" rel="noopener">Android拆分与加载Dex的多种方案对比</a></li><li><a href="http://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank" rel="noopener">美团Android DEX自动拆包及动态加载简介</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;UNEXPECTED TOP-LEVEL EXCEPTION: java.lang.IllegalArgumentException: method ID not in [0, 0xffff]: 65536&lt;br&gt;Dex文件中保存所有classes的方法个数的变量范围值在&lt;code&gt;0~65535&lt;/code&gt;之间，但随着业务一直在增长，引入到的库以及业务代码越来越多，超过这个限制只是时间问题。&lt;br&gt;一般来说 APK 安装的流程大多是这样构成的，首先复制apk文件到&lt;code&gt;data/app&lt;/code&gt;目录下，然后解压扫描安装包将dex文件安装到&lt;code&gt;data/dalvik-cache&lt;/code&gt;目录下，同时在&lt;code&gt;data/data&lt;/code&gt;目录下创建以APK包名的应用数据目录。由于5.0及以上版本ART模式的存在，app第一次安装之后会进行一次预编译，如果这时候发现了&lt;code&gt;classes(..N).dex&lt;/code&gt;文件的存在就会将他们最终合成为一个&lt;code&gt;.oat&lt;/code&gt;的文件。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="HotFix" scheme="https://hjw541988478.github.io/tags/HotFix/"/>
    
      <category term="MultiDex" scheme="https://hjw541988478.github.io/tags/MultiDex/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之排序算法</title>
    <link href="https://hjw541988478.github.io/2016/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://hjw541988478.github.io/2016/04/数据结构之排序算法/</id>
    <published>2016-04-09T10:32:00.000Z</published>
    <updated>2018-08-18T12:22:33.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>概念<br>假设含有n个记录的序列为{r1..rn}，其对应关键字{k1..kn}，确定1…n的一种排列p1..pn,使得其关键字按照kp1..kpn呈非递增或者非递减关系，这样操作称为排序。</li><li>稳定性<br>假设ki=kj且排序前的序列中ri领先于rj，如12果排序后ri仍领先于rj，则称排序方法稳定。</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>主要分为内排序和外排序。<br>影响到性能的因素：1.时间 2.辅助空间 3.算法复杂性；<br>内排序主要分为：插入、交换、选择和归并排序；<br><a id="more"></a></p><h2 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h2><h3 id="冒泡排序（交换排序）"><a href="#冒泡排序（交换排序）" class="headerlink" title="冒泡排序（交换排序）"></a>冒泡排序（交换排序）</h3><p>两两比较相邻记录关键字，如果反序则交换，直到没有反序的记录为止。<br>时间复杂度：O(n^2)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] ary)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; ary.length - <span class="number">1</span>&amp;&amp; flag; i++)&#123;</span><br><span class="line">     flag = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">for</span>(j = ary.length - <span class="number">2</span>; j&gt;= i; j --)&#123;</span><br><span class="line">         <span class="keyword">if</span>(ary[j] &gt; ary[j + <span class="number">1</span>])&#123;</span><br><span class="line">              swap(ary,j,j); </span><br><span class="line">              flag = <span class="keyword">true</span>;</span><br><span class="line">         &#125; </span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="选择排序（选择排序，记录下标最终交换）"><a href="#选择排序（选择排序，记录下标最终交换）" class="headerlink" title="选择排序（选择排序，记录下标最终交换）"></a>选择排序（选择排序，记录下标最终交换）</h3><p>通过n-1次关键字比较，从n-i+1个记录中选出最小记录，并和第i个记录交换；<br>时间复杂度：O(n^2)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] ary)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,min;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; i &lt; ary.length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ary[min] &gt; ary[j])&#125;</span><br><span class="line">                 min = j;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i != min)&#123;</span><br><span class="line">            swap(ary, i, min); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="直接插入排序（插入排序）"><a href="#直接插入排序（插入排序）" class="headerlink" title="直接插入排序（插入排序）"></a>直接插入排序（插入排序）</h3><p>将一个记录插入到已排序好的表中，从而得到新的记录数+1的有序表；<br>时间复杂度：O(n^2)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] ary)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; ary.length; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ary[i] &lt; ary[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = ary[i];</span><br><span class="line">            <span class="keyword">for</span>(j = i -<span class="number">1</span>;j &gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j --)&#123;</span><br><span class="line">               arr[j + <span class="number">1</span>]  = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="进阶排序"><a href="#进阶排序" class="headerlink" title="进阶排序"></a>进阶排序</h2><h3 id="希尔排序（插入排序）"><a href="#希尔排序（插入排序）" class="headerlink" title="希尔排序（插入排序）"></a>希尔排序（插入排序）</h3><p>将待排序的数组分割成N个基本有序的子数组，比如大的基本在后面，小的在前面，不大不小的在中间，所以需要采取增量跳跃组成子序列，才能保证子序列进行直接插入排序后，得到的结果是基本有序。<br>时间复杂度：O(n^3/2)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] ary)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> increment = ary.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">       increment = increment / <span class="number">3</span> + <span class="number">1</span>;<span class="comment">//增量序列</span></span><br><span class="line">       <span class="keyword">for</span>( i = increment + <span class="number">1</span>; i &lt; ary.length; i ++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(ary[i] &lt; ary[i - increment]) &#123;</span><br><span class="line">              <span class="keyword">int</span> temp = ary[i];</span><br><span class="line">              <span class="keyword">for</span>( j = i - increment; j &gt;=<span class="number">0</span> &amp;&amp; temp &lt; ary[j]; j -= increment) &#123;</span><br><span class="line">     ary[j + increment] = ary[j];</span><br><span class="line">&#125;</span><br><span class="line">     ary[j + increment] = temp;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(increment &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>增量序列最后一个值必须等于1，属于不稳定的排序；</p><h3 id="堆排序（选择排序）"><a href="#堆排序（选择排序）" class="headerlink" title="堆排序（选择排序）"></a>堆排序（选择排序）</h3><p>将待排序的序列构造成一个大顶堆，此时最大值就是根结点，然后移走根结点，将剩余的n-1个序列重新构造成一个堆，这样持续得到最小值，由此构成一个有序序列；<br>关键点：<br>如何构造堆？ 输出根结点后，如何调整为新的堆？<br>时间复杂度：O（nlogn），跳跃式进行但不稳定，不适合个数较少的情况。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] ary])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=ary.length/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        heapAdjust(ary, i, ary.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=ary.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i --) &#123;</span><br><span class="line">        swap(ary,<span class="number">0</span>,i);</span><br><span class="line">        heapAdjust(ary,<span class="number">0</span>,i-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] ary, <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp, j;</span><br><span class="line">    temp = ary[s];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>*s; j&lt;=m ;j*=<span class="number">2</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(j&lt;m &amp;&amp; ary[j] &lt; ary[j + <span class="number">1</span>]) &#123;</span><br><span class="line">              ++ j;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(temp &gt;= ary[j])&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ary[s] = ary[j];</span><br><span class="line">       s = j;</span><br><span class="line">    &#125;</span><br><span class="line">    ary[s] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>假设初始n个记录，看成每个子序列长度为1的有序子序列，然后两两归并，一直重复直到得到一个长度为n的有序序列为止，也称为2路归并排序；<br>时间复杂度：O（nlogn）,稳定但占用内存，不过效率高<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] ary)</span></span>&#123;</span><br><span class="line">    mSort(ary, res_ary, <span class="number">0</span> , ary.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将sr[s..t]归并排序成tr1[s..t];</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mSort</span><span class="params">(<span class="keyword">int</span> sr[], <span class="keyword">int</span> tr1[], <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> tr2[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(s == t) &#123;</span><br><span class="line">        tr1[s] = sr[s];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m = (s + t)/<span class="number">2</span>;</span><br><span class="line">        mSort(sr, tr2, s, m);</span><br><span class="line">        mSort(sr, tr2, m + <span class="number">1</span>, t);</span><br><span class="line">        mMerge(tr2, tr1, s, m, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mMerge</span><span class="params">(<span class="keyword">int</span> sr[], <span class="keyword">int</span> tr[], <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,k,l;</span><br><span class="line">    <span class="keyword">for</span>(j = m + <span class="number">1</span>, k =i;i&lt;=m &amp;&amp; j &lt;=n; k ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>( sr[i] &lt; sr[j] )&#123;</span><br><span class="line">            tr[k] = sr[i ++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tr[k] = sr[j ++];</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(l = <span class="number">0</span>;l &lt;= m - i; l ++ )&#123;</span><br><span class="line">            tr[k+l] = sr[i+l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &lt;=n ) &#123;</span><br><span class="line">        <span class="keyword">for</span>(l = <span class="number">0</span>; l &lt;= n- j; l ++ ) &#123;</span><br><span class="line">            tr[k+l] = sr[j+l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="快速排序（交换排序）"><a href="#快速排序（交换排序）" class="headerlink" title="快速排序（交换排序）"></a>快速排序（交换排序）</h3><p>通过一趟排序将待排记录分割成2部分，其中一部分记录关键字比另一部分小，则可分别对这两部分记录继续排序，以达到有序目的。<br>时间复杂度：O（nlogn），跳跃进行不稳定，可以进行的优化操作：</p><ul><li>优化选取枢轴：<br>三数取中，即取三个关键字进行排序，将中间数作为枢轴，一般取左、右和中三个数。</li><li>优化不必要的交换：<br>将枢轴值保存在临时变量上，采用替换而非交换的方式进行比较，最后再将枢轴值还原。</li><li>优化小数组时的排序方案：<br>当数组长度较小时直接采用插入排序；</li><li>优化递归操作：<br>缩减栈深度，提高性能；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] ary)</span> </span>&#123;</span><br><span class="line">    qSort(ary, <span class="number">0</span>, ary.length- <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span>[] ary, <span class="keyword">int</span> low , <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">       pivot = partition(ary, low, high);</span><br><span class="line">       qSort(ary, low , pivot - <span class="number">1</span>);</span><br><span class="line">       qSort(ary, pivot + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] ary, <span class="keyword">int</span> low , <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotKey;</span><br><span class="line">    pivotKey = ary[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; ary[high] &gt;= pivotKey) &#123;</span><br><span class="line">            high --;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(ary, low , high);</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; ary[low] &lt;= pivotKey) &#123;</span><br><span class="line">            low ++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(ary, low , high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>排序分为内排序和外排序，外排序要在内外存之间多次交换才能进行，主要是总结内排序；<br>按操作划分为四类：插入、交换、选择和归并：</p><ul><li>插入类：<br>直接插入、希尔排序；</li><li>选择类：<br>简单选择、堆排序；</li><li>交换类：<br>冒泡、快排；</li><li>归并类：<br>归并排序；<br>除了归并和简单的三种排序外，其他都是不稳定的排序算法；<br>除了简单排序外，其他复杂度都是O(nlogn)；</li><li>按使用情况划分：<br>若基本有序，采用基本排序比改进排序更搞笑；否则，采用堆排序和归并排序强于其他高级排序；</li><li>从时间复杂度看，堆排序和归并排序比快排稳定，也就是无论数据好坏都可以高效完成，而快排需要根据数据的特点才可能高效完成；</li><li>从空间复杂度看，堆排序只需要O（1）便可完成，因此对内存敏感的话，应采用堆排序；</li><li>从稳定性看，无疑归并最好；</li><li>从记录个数来看，无疑个数越小越适宜于简单排序，否则，使用改进排序；<br>综合来看，经过优化后的快排是最好的选择；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;概念&lt;br&gt;假设含有n个记录的序列为{r1..rn}，其对应关键字{k1..kn}，确定1…n的一种排列p1..pn,使得其关键字按照kp1..kpn呈非递增或者非递减关系，这样操作称为排序。&lt;/li&gt;
&lt;li&gt;稳定性&lt;br&gt;假设ki=kj且排序前的序列中ri领先于rj，如12果排序后ri仍领先于rj，则称排序方法稳定。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;p&gt;主要分为内排序和外排序。&lt;br&gt;影响到性能的因素：1.时间 2.辅助空间 3.算法复杂性；&lt;br&gt;内排序主要分为：插入、交换、选择和归并排序；&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DataStructure" scheme="https://hjw541988478.github.io/categories/DataStructure/"/>
    
    
      <category term="Sort" scheme="https://hjw541988478.github.io/tags/Sort/"/>
    
      <category term="DataStructure" scheme="https://hjw541988478.github.io/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>IPC通信机制理解实践</title>
    <link href="https://hjw541988478.github.io/2015/11/IPC%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://hjw541988478.github.io/2015/11/IPC通信机制理解实践/</id>
    <published>2015-11-19T11:12:00.000Z</published>
    <updated>2018-08-18T12:28:48.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>IPC含义为进程间通信或者跨进程通信，指的是两个进程之间进行数据交换的过程。线程是CPU调度的最小单元，也是一种有限的系统资源，而进程是指一个执行单元。在Android系统中，一个进程一般指一个应用。</p><h2 id="多进程模式"><a href="#多进程模式" class="headerlink" title="多进程模式"></a>多进程模式</h2><h3 id="开启多进程模式"><a href="#开启多进程模式" class="headerlink" title="开启多进程模式"></a>开启多进程模式</h3><p>在Android中使用多进程只有一种方法，那就是在AndroidManifest.xml中指定<code>android:process</code>属性，除此之外并无其他办法。如下面的例子所示:<br><a id="more"></a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"me.huangjiawen.ipcaty1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":remote"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"me.huangjiawen.ipcaty2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">"me.huangjiawen.remote"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>通过<code>:remote</code>指定的进程，表示当前进程名为当前包名附上:remote，即me.huangjiawen:remote，且属于当前应用的私有进程，其他应用的组件不能和它跑在同一个进程中。</li><li>通过<code>me.huangjiawen.remote</code>完整的名字指定的进程，它不会附上包名信息，且属于全局进程，其他应用可以通过ShareUID的方式和它跑在同一个进程中。</li></ul><h3 id="多进程模式运行机制"><a href="#多进程模式运行机制" class="headerlink" title="多进程模式运行机制"></a>多进程模式运行机制</h3><p>通常情况下，在应用中我们很多时候会使用静态类型的变量来共享数据，保证共享数据的唯一性。如下情况:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInfo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> TOTAL_NUM = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在单进程的应用中，在不同的地方访问TOTAL_NUM数据都是唯一的，但在多进程模式下的运行机制中，当我们在一个进程中修改其值，然后在另一个进程中获取其值，会发现获取到的值并不是修改后的值，而是初始值。<br>发生这种情况的原因是因为多进程被分配了不同的虚拟机，也就是说在内存地址上分配着不同的空间，彼此相互是独立的，在某进程中修改后的静态变量值只会影响到当前进程，对其他进程并不会造成影响。因此四大组件通过内存共享数据的方式是不可取的，而大多数需要使用多进程的情况都需要数据共享，此时需要其他方式来解决这个问题。<br>在多进程共享数据主要会造成下面几个方面的影响：</p><ul><li>静态成员和单例模式失效</li><li>线程同步机制失效</li><li>SharedPreference可靠性下降</li><li>Application多次创建</li></ul><h2 id="IPC基础"><a href="#IPC基础" class="headerlink" title="IPC基础"></a>IPC基础</h2><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p><code>Serializable</code>是Java提供的一个序列化空接口，只需要声明便可以使用，同时默认产生一个serialVersionUID常量。我们常见的序列化和反序列化的使用场景是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"Sunny"</span>,<span class="number">20</span>);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">    <span class="keyword">new</span> FileOutputStream(<span class="string">"cache.txt"</span>);</span><br><span class="line">oos.writeObject(user);</span><br><span class="line">oos.close;</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">    <span class="keyword">new</span> FileInputStream(<span class="string">"cache.txt"</span>);</span><br><span class="line">User newUser = (User) ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure></p><p>这里，serialVersionUID起到了重要的作用，序列化的时候把当前类的serialVersionUID写入到中介，当反序列化的时候检测中介的serialVersionUID，如果与当前版本的一致，说明是相同的，则可以序列化成功，否则序列化失败。</p><h3 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h3><p><code>Parcelable</code>也是一个接口，实现了这个接口后，便可以用来在<code>Intent</code>和<code>Binder</code>传递。下面实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的代码可以看出，<code>Parcel</code>内部包装了可序列化的数据，其中通过<code>writeToParcel</code>方法完成序列化功能，而反序列化由CREATOR来完成，其内部标明了如何创建对象和数组，而内容描述功能在几乎所有情况都应该返回0，除非存在文件描述符，则返回0。</p><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>Binder是Android中的一个类，它继承了<code>IBinder</code>接口。在Andriod应用层中，主要用在Service中，包括<code>Messenger</code>和<code>AIDL</code>，其中涉及到IPC通信的主要是AIDL。通过指定Book.aidl、IBookManager.aidl进行rebuild后自动生成的IBookManager.java，它继承于IInterface接口，同时内部类Stub和内部代理类Proxy很好地实现了同进程和跨进程间的通信过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.huangjiawen.ipcexercise;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过内部声明的2个ID标识IBookManager所声明的方法，这样可以清晰的认识到在transact过程中客户端请求的到底是哪个方法，接着声明一个内部类Stub，这个Stub是一个内部类，也就是一个Binder类，当客户端与服务端在同一个进程中的时候，方法调用不会走transact过程，而在不同进程中的时候，逻辑由Stub内部代理类Proxy完成。其中，关键方法或属性含义如下：</p><ul><li>DESCRIPTER：<br>Binder的唯一标识，一般用于Binder的类名表示；</li><li>asInterface(android.os.IBinder obj) :<br>用于将服务端的Binder对象转换成客户端所需要的AIDL接口类型对象，这种转换是区分进程的，如果在同一进程，则返回服务端本身，否则返回的是封装后的Stub.Proxy对象；</li><li>asBinder :<br>用于返回当前Binder对象；</li><li>onTransact :<br>该方法运行在服务端的Binder线程中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理，其参数，code对应着请求的方法是什么，data取出目标方法所需要的参数，当方法执行完毕后，向reply中写入返回值。如果返回失败，则表示调用失败，可以利用此特性做权限验证。</li><li>Proxy.getBookList<br>该方法运行在客户端中，当客户端进行远程调用的时候，首先创建输入型的Parcel对象_data、输出型的Parcel对象_reply和返回值对象List，然后把方法所需要的参数写入到_data中，接着进行RPC请求，直到返回结果数据继续执行，并从_reply中取结果数据返回给客户端。</li><li>Proxy.addBook<br>该方法也运行在客户端中，与上一个方法不一样的地方在于没有返回值。<br>通过对上面关键方法的分析可以看到整个工作机制，但也有需要注意的地方，第一个是如果远程请求的方法很耗时，那么在UI线程中直接执行可能会造成ANR，第二个是由于服务端Binder方法运行在Binder线程池中，所以Binder方法无论怎样都应该以同步的方式去实现，因为它已经运行在一个线程中了。对于Binder工作机制的理解如下图所示：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/11/IPC通信机制理解实践/binder_working_mechanism.png" alt="Binder工作机制图" title="">                </div>                <div class="image-caption">Binder工作机制图</div>            </figure>当然，我们也可以无需借助aidl自动生成，使用手写实现的步骤如下：</li></ul><ol><li>声明一个AIDL性质的接口，只需要继承IInterface接口即可；</li><li>实现Stub类和Stub类中的Proxy代理类；<br>只是在结构上面看着更为清晰，将接口和IBinder进行分离，实质上并无改变。</li></ol><h2 id="IPC方式"><a href="#IPC方式" class="headerlink" title="IPC方式"></a>IPC方式</h2><h3 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h3><p>由于Bundle实现了Parcelable接口，这也意味着它能够作为进程间传输的载体，但由于<code>Bundle</code>支持的数据类型有限，使得一些特殊对象不被支持，在<code>Activity、Service和Recevier</code>中使用情景很常见，作为使用情景最多的方式，特点是方便易用。</p><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>两个进程可以通过共享同一文件达到目的，但由于Android系统是基于Linux，这使得读写文件可以同时执行，因此为了保证数据的完整性和最新性，需要使用同步加锁，但这无疑降低了读写效率。因此文件共享适用于数据同步要求不高的进程间通信。</p><h3 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h3><p>Messenger可以在不同进程之间传递Message对象，可以轻松实现跨进程通信，底层实现依赖的是AIDL，由于具有一次只处理一个请求的特性，这意味着不需要考虑线程同步的问题。</p><ol><li><p>服务端进程<br>服务端只需要创建一个<code>Service</code>来处理客户端请求，同时使用<code>Handler</code>并通过它来创建一个Message对象，然后在onBind方法中返回这个底层对象<code>Binder</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="comment">// 收到客户端发过来的消息</span></span><br><span class="line">                    Log.d(TAG,msg.getData().getString(<span class="string">"msg"</span>));</span><br><span class="line">                    <span class="comment">// 回复客户端</span></span><br><span class="line">                    Messenger client = msg.replyTo;</span><br><span class="line">                    Message replyMsg = Message.obtain(<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line">                    Bundle bundle = <span class="keyword">new</span> Bundler();</span><br><span class="line">                    bundle.putString(<span class="string">"msg"</span>,<span class="string">"hello,client"</span>);</span><br><span class="line">                    replyMsg.setData(bundle);</span><br><span class="line">                    client.send(replyMsg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messenger mMessengerHandler = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMessengerHandler.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.huangjiawen.ipcexercise;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Messenger mService;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            mService = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            Message msg = Message.obtain(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">            Bundle data = <span class="keyword">new</span> Bundle();</span><br><span class="line">            data.putString(<span class="string">"msg"</span>, <span class="string">"this is client."</span>);</span><br><span class="line">            msg.setData(data);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"client has sended msg."</span>);</span><br><span class="line">                mService.send(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class);</span><br><span class="line">        bindService(intent, mConnection, BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unbindService(mConnection);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可以看到客户端与服务端的交互流程中，数据总是以<code>Message</code>做为载体，<code>Messenger</code>作为传输信使进行消息的发送。其工作原理可以如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/11/IPC通信机制理解实践/messenger_working_mechanism.png" alt="Messenger工作原理" title="">                </div>                <div class="image-caption">Messenger工作原理</div>            </figure></p><h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>Messenger的底层实现是基于AIDL来的，但Messenger是以串行的方式来处理消息的，对于大量的消息请求，显然Messenger变得不怎么合适了，那么AIDL方式的可以解决这个问题。</p><ol><li>AIDL文件的创建<br>AIDL文件是以.aidl为后缀声明了接口和方法的文件，主要支持的数据类型：</li></ol><ul><li>基本数据类型(int、long、char等)</li><li>String和CharSequence</li><li>List:只支持ArrayList</li><li>Map:只支持HashMap</li><li>Parceable:所有实现了Parceable接口的对象</li><li>AIDL:所有AIDL接口本身也可以被使用<br>除了基本类型数据外，其他数据类型的参数必须标上方向：<code>in、out或者inout</code>，in表示输入型参数，out表示输出型参数，inout表示输入输出型参数。如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.huangjiawen.ipcexercise;</span><br><span class="line"><span class="keyword">import</span> me.huangjiawen.ipcexercise.Book;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>远程服务端Service的实现<br>在创建好AIDL接口后，接下来我们就需要实现接口：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BMS"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mBookList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mBookList.add(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">1</span>,<span class="string">"android"</span>));</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">2</span>,<span class="string">"ios"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>使用<code>CopyOnWriteArrayList</code>来支持并发的读写，由于AIDL的方法是在线程池中执行的，如果有多个客户端同时连接，也存在着多个线程同时访问的情况，而我们这里直接使用<code>CopyOnWriteArrayList</code>便可以达到自动线程同步的目的。与此类似的集合还有<code>ConcurrentHashMap</code>，它们都会按照规范去访问数据最后生成<code>ArrayList</code>或者<code>HashMap</code>。最后记得在Manifest文件去配置Service。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".aidl.BookManagerService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":remote"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><ol start="3"><li><p>客户端的实现<br>客户端需要做的是，绑定远程服务，拿到Binder对象转换成AIDL接口，最后通过AIDL接口进行远程方法调用就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_book_manager);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, BookManagerService.class);</span><br><span class="line">        bindService(intent, mConnection, BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unbindService(mConnection);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            IBookManager bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;Book&gt; list = bookManager.getBookList();</span><br><span class="line">                Log.d(<span class="string">"BMA"</span>, <span class="string">"query book list , and type :"</span> + list.getClass().getCanonicalName());</span><br><span class="line">                Log.d(<span class="string">"BMA"</span>, <span class="string">"query book list:"</span> + list.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回调接口管理<br>当然有些时候我们需要回调接口去接收到服务端的传过来的信息，这意味着包含着3个过程，注册服务，运行服务，反注册服务，一般情况下我们在拿到服务端的Binder后直接使用来进行注册与反注册，但此时通过日志可以发现，实际上是反注册失败的。<br>仔细分析不难发现，在多进程中，Binder会把从客户端传过来的对象转化成一个新的对象，由于对象不能跨进程传输，对象的跨进程输出本质是反序列化的过程，所以能够见到的跨进程传输的对象都是实现了Parcelable接口的。但还好的是系统给我们提供了<code>RemoteCallbackList</code>专用于删除跨进程listener的接口，可以看到其真正的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayMap&lt;IBinder,Callback&gt; mCallbacks = <span class="keyword">new</span> ArrayMap&lt;IBinder,Callback&gt;();</span><br></pre></td></tr></table></figure></li></ol><p>使用IBinder类型作为key，回调接口callback作为value。也就是说利用了底层Binder对象都是同一个的特性，并且自动实现了线程同步的功能，也就是这样达到的目的。</p><ol start="5"><li>Binder异常处理<br>如果Binder意外死亡，某些情况下需要我们进行重新连接。进行这种操作的方法有两种，第一种是给<code>DeathRecipient</code>设置监听，第二种是在<code>onServiceDisconnected</code>中进行处理。这两种处理方法的不同点在于前一种是在Binder线程池中的一个线程中操作的，而后一种是在UI线程中处理的，根据具体需求可以选择是去处理。</li><li>AIDL权限验证<br>默认情况下，我们所有的远程服务任何人都能连接，但大多数情况下，是需要加入权限认证的。解决的方式有两种。第一种是在onBind中进行自定义权限的验证，验证不通过返回null。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;permission android:name=&quot;me.huangjiawen.permission.ACCESS_BOOK_SERVICE&quot;</span><br><span class="line">    android:protectionLevel=&quot;normal&quot;/&gt;</span><br><span class="line">int check = checkCallingOrSelfPermission(&quot;me.huangjiawen.permission.ACCESS_BOOK_SERVICE&quot;);</span><br><span class="line">if (check == PackageManager.PERMISSION_DENIED)</span><br><span class="line">    return null;</span><br></pre></td></tr></table></figure></li></ol><p>第二种是在服务端中的<code>onTransact</code>方法中进行权限验证，如果验证失败返回false，验证方式可以采用permission验证，也可以使用Uid和Pid验证，通过<code>getCallingUid</code>和<code>getCallingPid</code>可以拿到客户端所属应用的Uid和Pid。比如既验证包名又验证permission。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> check = checkCallingOrSelfPermission(<span class="string">"me.huangjiawen.permission.ACCESS_BOOK_SERVICE"</span>);</span><br><span class="line"><span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">String packageName = <span class="keyword">null</span>;</span><br><span class="line">String[] packages = getPackageManager.getPackageForUid(getCallingUid());</span><br><span class="line"><span class="keyword">if</span> ( packages != <span class="keyword">null</span> &amp;&amp; packages.length &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">    packageName = packages[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!packageName.startsWith(<span class="string">"me.huangjiawen"</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></p><h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p>ContentProvider是Android提供的专门用于不同应用间进行数据共享的方式，和Messenger一样，底层实现也是Binder。下面来进行自定义的ContentProvider来进行研究：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BookProvider"</span>;</span><br><span class="line">    <span class="comment">// 在Manifest声明配置的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"me.huangjiawen.book.provider"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri BOOK_CONTENT_URI = Uri.parse(<span class="string">"content://"</span> + AUTHORITY + <span class="string">"/book"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_URI_CODE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher sUriMathcher = <span class="keyword">new</span> UriMatcher(</span><br><span class="line">            UriMatcher.NO_MATCH);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        sUriMathcher.addURI(AUTHORITY, <span class="string">"book"</span>, BOOK_URI_CODE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase mDb;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mContext = getContext();</span><br><span class="line">        mDb = <span class="keyword">new</span> BookDbHelper(mContext).getWritableDatabase();</span><br><span class="line">        mDb.execSQL(<span class="string">"insert into tb_book values(3,'Android');"</span>);</span><br><span class="line">        mDb.execSQL(<span class="string">"insert into tb_book values(4,'IOS');"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        String tableName = BookDbHelper.TB_BOOK;</span><br><span class="line">        <span class="keyword">switch</span> (sUriMathcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_URI_CODE:</span><br><span class="line">                tableName = BookDbHelper.TB_BOOK;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDb.query(getTableName(uri), projection, selection, selectionArgs, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">        mDb.insert(getTableName(uri), <span class="keyword">null</span>, values);</span><br><span class="line">        mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = mDb.delete(getTableName(uri), selection, selectionArgs);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = mDb.update(getTableName(uri), values, selection, selectionArgs);</span><br><span class="line">        <span class="keyword">if</span> (rows &gt; <span class="number">0</span>)</span><br><span class="line">            mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面已经实现了TB_BOOK表的CRUD并且提供了Provider，如果存在着多个数据库而由于存在多线程并发访问，因此要做好线程同步操作。还有值得注意的是，如果对数据库产生了更新的影响，有必要去使用<code>ContentResolver</code>的<code>notifyChange</code>去通知外部数据源已经改变。<br>在AndroidManifest文件中的配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"me.huangjiawen.ipcexercise.BookProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"me.huangjiawen.book.provider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"me.huangjiawen.PROVIDER"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":provider"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>使用示例如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Uri uri = BookProvider.BOOK_CONTENT_URI;</span><br><span class="line">        ContentValues cvs = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        cvs.put(<span class="string">"_id"</span>, <span class="number">6</span>);</span><br><span class="line">        cvs.put(<span class="string">"name"</span>, <span class="string">"javascript"</span>);</span><br><span class="line">        getContentResolver().insert(uri, cvs);</span><br><span class="line">        Cursor bookCursor = getContentResolver().query(uri, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>, <span class="string">"name"</span>&#125;,</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (bookCursor.moveToNext()) &#123;</span><br><span class="line">            Book book = <span class="keyword">new</span> Book(bookCursor.getInt(<span class="number">0</span>),bookCursor.getString(<span class="number">1</span>));</span><br><span class="line">            Log.d(<span class="string">"ProviderActivity"</span>,book.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        bookCursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>ContentProvider</code>对外提供的URI对TB_BOOK表添加了2条记录，然后使用<code>getContentResolver()</code>进行遍历查找输出。由于Provider和Activity运行在两个不同的进程中，也很好的展示了进程间的通信。</p><h2 id="Binder连接池"><a href="#Binder连接池" class="headerlink" title="Binder连接池"></a>Binder连接池</h2><p>一般情况下，当我们创建一个AIDL接口的时候，也意味着也要创建一个新的Service，而随着AIDL接口越来越多的时候，Service也会变得越多，因此我们需要将所有的AIDL放在一个Service中去管理。Binder连接池的目的就是将每个业务模块Binder请求统一转发给Service去执行，从而避免了重复创建Service的过程。示例如下：</p><ol><li><p>业务接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ISecurityCenter</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">encrypt</span><span class="params">(String content)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">decrypt</span><span class="params">(String password)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ICompute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务接口实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityCenterImpl</span> <span class="keyword">extends</span> <span class="title">ISecurityCenter</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encrypt</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decrypt</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputeImpl</span> <span class="keyword">extends</span> <span class="title">ICompute</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Binder连接池的AIDL接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBinderPool</span> </span>&#123;</span><br><span class="line">    <span class="function">IBinder <span class="title">queryBinder</span><span class="params">(<span class="keyword">int</span> binderCode)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现连接池queryBinder方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">queryBinder</span><span class="params">(<span class="keyword">int</span> binderCode)</span> </span>&#123;</span><br><span class="line">    IBinder binder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (binderCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> IBINDER_SECURITY_CENTER:</span><br><span class="line">            binder = <span class="keyword">new</span> SeccurityCenterImpl();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>  IBINDER_COMPUTE:</span><br><span class="line">            binder = <span class="keyword">new</span> ComputeImpl();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现BinderPoolService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPoolService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Binder mBinderPool = <span class="keyword">new</span> BinderPool.BinderPoolImpl();</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinderPool;</span><br><span class="line">    &#125;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BinderPool连接池实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BINDER_NOE = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BINDER_COMPUTE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BINDER_SECURITY_CENTER = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="keyword">private</span> IBinderPool mBinderPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> BinderPool sInstance;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch mConnectBinderPoolCountDownLatch;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BinderPool</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context.getApplicationContext();</span><br><span class="line">        connectBinderPoolService();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinderPool <span class="title">getInstance</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connectBinderPoolService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mConnectBinderPoolCountDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        Intent service = <span class="keyword">new</span> Intent(mContext, BinderPoolService.class);</span><br><span class="line">        mContgxt.bindService(service,mBinderPoolConnection,</span><br><span class="line">            Context.BIND_AUTO_CREATE);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            mConnectBinderPoolCountDownLatch.await();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">queryBinder</span><span class="params">(<span class="keyword">int</span> binderCode)</span></span>&#123;</span><br><span class="line">        IBinder binder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mBinderPool != <span class="keyword">null</span> )</span><br><span class="line">                binder = mBinderPool.queryBinder(binderCode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mBinderPoolConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span></span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConencted</span><span class="params">(ComponentName name,IBinder service)</span></span>&#123;</span><br><span class="line">            mBinderPool = IBinderPool.Stub.asInterface(service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mBinderPool.asBinder().linkToDeath(mBinderPoolDeathRecipient,<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            mConnectBinderPoolCountDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> IBinder.DeathRecipient mBinderPoolDeathRecipient = <span class="keyword">new</span> IBinder.DeathRecipient()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span></span>&#123;</span><br><span class="line">            mBinderPool.asBinder().unlinkToDeath(mBinderPoolDeathRecipient,<span class="number">0</span>);</span><br><span class="line">            mBinderPool = <span class="keyword">null</span>;</span><br><span class="line">            connectBinderPoolService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderPoolImpl</span> <span class="keyword">extends</span> <span class="title">IBinderPool</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BinderPoolImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IBinder <span class="title">queryBinder</span><span class="params">(<span class="keyword">int</span> binderCode)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            IBinder binder = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (binderCode) &#123;</span><br><span class="line">                <span class="keyword">case</span> BINDER_SECURITY_CENTER: &#123;</span><br><span class="line">                    binder = <span class="keyword">new</span> SecurityCenterImpl();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> BINDER_COMPUTE:</span><br><span class="line">                    binder = <span class="keyword">new</span> ComputeImpl();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> binder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BinderPool使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BinderPool binderPool = BinderPool.getInstance(BinderPoolActivity.<span class="keyword">this</span>);</span><br><span class="line">    IBinder computeBinder = binderPool.queryPool(BinderPool.BINDER_COMPUTE);</span><br><span class="line">    ICompute mCompute = ComputeImpl.asInterface(computeBinder);</span><br><span class="line">    <span class="comment">//使用</span></span><br><span class="line">    mCompute.add(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在Binder线程池实现过程中，使用到了<code>CountDownLatch</code>讲<code>bindService</code>操作由异步变成同步操作，因此操作需要放在新的线程中执行，同时包含了断线重连机制，也意味着，一旦产生了断线重连的情况，记得手动获取新的Binder对象。</p><h2 id="IPC总结"><a href="#IPC总结" class="headerlink" title="IPC总结"></a>IPC总结</h2><p>在众多的IPC方式中，简单易用的有Bundle和文件共享机制，不过它们都不适合高并发且实时通信，只适合简单数据的交换工作，而AIDL支持高并发通信，但是要处理线程同步问题，使用起来稍微麻烦一些，因此有了上层封装好的Messenger和ContentProvider通信，Messenger使用Message使用数据交换，而ContentProvider更适合于一对多的数据共享，最后是Socket通信，它支持实时通信，通过网络传输字节流，实现起来也稍微麻烦一些。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="http://blog.csdn.net/luoshengyang/article/details/6642463" target="_blank" rel="noopener">Android系统进程间通信Binder机制在应用程序框架层的Java接口源代码分析</a></li><li><a href="http://blog.csdn.net/chaihuasong/article/details/10071903" target="_blank" rel="noopener">深入理解android之IPC机制与Binder框架</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h2&gt;&lt;p&gt;IPC含义为进程间通信或者跨进程通信，指的是两个进程之间进行数据交换的过程。线程是CPU调度的最小单元，也是一种有限的系统资源，而进程是指一个执行单元。在Android系统中，一个进程一般指一个应用。&lt;/p&gt;
&lt;h2 id=&quot;多进程模式&quot;&gt;&lt;a href=&quot;#多进程模式&quot; class=&quot;headerlink&quot; title=&quot;多进程模式&quot;&gt;&lt;/a&gt;多进程模式&lt;/h2&gt;&lt;h3 id=&quot;开启多进程模式&quot;&gt;&lt;a href=&quot;#开启多进程模式&quot; class=&quot;headerlink&quot; title=&quot;开启多进程模式&quot;&gt;&lt;/a&gt;开启多进程模式&lt;/h3&gt;&lt;p&gt;在Android中使用多进程只有一种方法，那就是在AndroidManifest.xml中指定&lt;code&gt;android:process&lt;/code&gt;属性，除此之外并无其他办法。如下面的例子所示:&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="MultiProcess" scheme="https://hjw541988478.github.io/tags/MultiProcess/"/>
    
      <category term="IPC" scheme="https://hjw541988478.github.io/tags/IPC/"/>
    
      <category term="Binder" scheme="https://hjw541988478.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>顶层悬浮球分析与实现</title>
    <link href="https://hjw541988478.github.io/2015/11/%E9%A1%B6%E5%B1%82%E6%82%AC%E6%B5%AE%E7%90%83%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://hjw541988478.github.io/2015/11/顶层悬浮球分析与实现/</id>
    <published>2015-11-19T11:12:00.000Z</published>
    <updated>2018-08-18T15:52:03.169Z</updated>
    
    <content type="html"><![CDATA[<p>悬浮球功能作为顶层视图，在用户关闭了 APP 后也能方便快捷操作，而这类应用主要是系统级别的安全应用，比如一键清理内存。在后续的 Android 版本中，Google 和很多厂商对于此类权限做了更为敏感的控制，需要用户手动设置才能看到悬浮球。下面手动实现了一个悬浮球来分析整个过程，其核心部分就是<code>WindowManager</code>类对Window的管理。</p><h2 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h2><p>对于<code>WindowManager</code>的工作过程，可以通过手动添加一个<code>Window</code>为例去分析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TextView mFloatingText = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</span><br><span class="line">mFloatingText.setText(<span class="string">"FloatingText"</span>);</span><br><span class="line">WindowManager.LayoutParams params = <span class="keyword">new</span> WindowManager.LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT,<span class="number">0</span>,<span class="number">0</span>,PixelFormat.TRANSPARENT);</span><br><span class="line">params.flags = LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_SHOW_WHEN_LOCKED;</span><br><span class="line">params.gravity = Gravity.LEFT | Gravity.TOP;</span><br><span class="line">params.x = <span class="number">300</span>;</span><br><span class="line">params.y = <span class="number">100</span>;</span><br><span class="line">mWindowManager.addView(mFloatingText,params);</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>上述代码将一个<code>TextView</code>添加到屏幕坐标为(300,100)的位置上。其中对于flags和type参数比较重要，flags表示Window显示属性，有主要的值：</p><ul><li>FLAG_NOT_FOCUSABLE<br>表示 Window 不需要获取焦点，最终的触摸事件会直接传递到下层具有焦点的 Window；</li><li>FLAG_NOT_TOUCH_MODAL<br>表示当前 Window 区域的点击事件自己处理，其他区域交给底层 Window 去处理；</li><li>FLAG_SHOW_WHEN_LOCKED<br>表示可以显示在锁屏界面上。<br>type参数表示 Window 的类型，Window有三种类型，分别是应用 Window，子 Window和系统 Window，层级越大表示越顶层：</li><li>应用 Window<br>对应着一个 Activity，1~99层；</li><li>子 Window<br>不能单独存在，必须附属于父 Window之上，比如 Dialog，1000-1999层；</li><li>系统 Window<br>声明权限才能创建，比如 Toast 和系统状态栏，2000-2999层。<br>首先加上权限，<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SYSTEM_ALERT_WINDOW"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>然后设置 type 属性，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mParams.type = LayoutParams.TYPE_SYSTEM_ERROR;</span><br></pre></td></tr></table></figure></p><p>对于仅有的<code>addView、updateViewLayout和removeView</code>方法，已经可以满足添加视图、更新视图和删除视图了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先是主布局，提供一个Button，通过单击该按钮来打开浮窗，主要涉及到的是一个主入口Activity和主布局文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        findViewById(R.id.start_float_window).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                startService(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,FloatWindowService.class));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到的是，实际上是启动了一个<code>Service</code>，也就是说对于悬浮球的操作都是在FloatWindowService类中完成的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.ActivityManager;</span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.ResolveInfo;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloatWindowService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于在线程中创建或移除悬浮窗。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时器，定时进行检测当前应该创建还是移除悬浮窗。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Timer timer;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开启定时器，每隔0.5秒刷新一次</span></span><br><span class="line">        <span class="keyword">if</span> (timer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            timer = <span class="keyword">new</span> Timer();</span><br><span class="line">            timer.scheduleAtFixedRate(<span class="keyword">new</span> RefreshTask(), <span class="number">0</span>, <span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// Service被终止的同时也停止定时器继续运行</span></span><br><span class="line">        timer.cancel();</span><br><span class="line">        timer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RefreshTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 当前界面是桌面，且没有悬浮窗显示，则创建悬浮窗。</span></span><br><span class="line">            <span class="keyword">if</span> (isHome() &amp;&amp; !MyWindowManager.isWindowShowing()) &#123;</span><br><span class="line">                handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        MyWindowManager.createSmallWindow(getApplicationContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前界面不是桌面，且有悬浮窗显示，则移除悬浮窗。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!isHome() &amp;&amp; MyWindowManager.isWindowShowing()) &#123;</span><br><span class="line">                handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        MyWindowManager.removeSmallWindow(getApplicationContext());</span><br><span class="line">                        MyWindowManager.removeBigWindow(getApplicationContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前界面是桌面，且有悬浮窗显示，则更新内存数据。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isHome() &amp;&amp; MyWindowManager.isWindowShowing()) &#123;</span><br><span class="line">                handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        MyWindowManager.updateUsedPercent(getApplicationContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前界面是否是桌面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isHome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityManager mActivityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        List&lt;ActivityManager.RunningTaskInfo&gt; rti = mActivityManager.getRunningTasks(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> getHomes().contains(rti.get(<span class="number">0</span>).topActivity.getPackageName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得属于桌面的应用的应用包名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回包含所有包名的字符串列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getHomes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        PackageManager packageManager = <span class="keyword">this</span>.getPackageManager();</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_MAIN);</span><br><span class="line">        intent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">        List&lt;ResolveInfo&gt; resolveInfo = packageManager.queryIntentActivities(intent,</span><br><span class="line">                PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line">        <span class="keyword">for</span> (ResolveInfo ri : resolveInfo) &#123;</span><br><span class="line">            names.add(ri.activityInfo.packageName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见FloatWindowService在<code>onStartCommand</code>方法中开启了一个定时器，每隔500毫秒就会执行RefreshTask任务。任务主要执行的操作是，当前界面是桌面的话则显示悬浮球并刷新内存使用率，否则隐藏悬浮球。且当服务停止时，将定时器销毁，防止内存泄露。<br>从上面的代码我们也可以看出，创建和移除悬浮窗，以及更新悬浮窗的内容，都是由MyWindowManager这个类来管理的，比起直接写在<code>Service</code>中，能够更好的分离代码。既然悬浮窗能够显示了，接下来就是悬浮窗视图 View 的实现了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.WindowManager;</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloatWindowSmallView</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录小悬浮窗的宽度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> viewWidth;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录小悬浮窗的高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> viewHeight;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录系统状态栏的高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> statusBarHeight;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于更新小悬浮窗的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> WindowManager windowManager;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 小悬浮窗的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> WindowManager.LayoutParams mParams;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录当前手指位置在屏幕上的横坐标值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> xInScreen;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录当前手指位置在屏幕上的纵坐标值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> yInScreen;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录手指按下时在屏幕上的横坐标的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> xDownInScreen;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录手指按下时在屏幕上的纵坐标的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> yDownInScreen;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录手指按下时在小悬浮窗的View上的横坐标的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> xInView;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录手指按下时在小悬浮窗的View上的纵坐标的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> yInView;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FloatWindowSmallView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.float_window_small, <span class="keyword">this</span>);</span><br><span class="line">        View view = findViewById(R.id.small_window_layout);</span><br><span class="line">        viewWidth = view.getLayoutParams().width;</span><br><span class="line">        viewHeight = view.getLayoutParams().height;</span><br><span class="line">        TextView percentView = (TextView) findViewById(R.id.percent);</span><br><span class="line">        percentView.setText(MyWindowManager.getUsedPercentValue(context));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="comment">// 手指按下时记录必要数据,纵坐标的值都需要减去状态栏高度</span></span><br><span class="line">                xInView = event.getX();</span><br><span class="line">                yInView = event.getY();</span><br><span class="line">                xDownInScreen = event.getRawX();</span><br><span class="line">                yDownInScreen = event.getRawY() - getStatusBarHeight();</span><br><span class="line">                xInScreen = event.getRawX();</span><br><span class="line">                yInScreen = event.getRawY() - getStatusBarHeight();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                xInScreen = event.getRawX();</span><br><span class="line">                yInScreen = event.getRawY() - getStatusBarHeight();</span><br><span class="line">                <span class="comment">// 手指移动的时候更新小悬浮窗的位置</span></span><br><span class="line">                updateViewPosition();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="comment">// 如果手指离开屏幕时，xDownInScreen和xInScreen相等，且yDownInScreen和yInScreen相等，则视为触发了单击事件。</span></span><br><span class="line">                <span class="keyword">if</span> (xDownInScreen == xInScreen &amp;&amp; yDownInScreen == yInScreen) &#123;</span><br><span class="line">                    openBigWindow();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将小悬浮窗的参数传入，用于更新小悬浮窗的位置。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params 小悬浮窗的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParams</span><span class="params">(WindowManager.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        mParams = params;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新小悬浮窗在屏幕中的位置。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateViewPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mParams.x = (<span class="keyword">int</span>) (xInScreen - xInView);</span><br><span class="line">        mParams.y = (<span class="keyword">int</span>) (yInScreen - yInView);</span><br><span class="line">        windowManager.updateViewLayout(<span class="keyword">this</span>, mParams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开大悬浮窗，同时关闭小悬浮窗。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openBigWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyWindowManager.createBigWindow(getContext());</span><br><span class="line">        MyWindowManager.removeSmallWindow(getContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于获取状态栏的高度。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回状态栏高度的像素值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getStatusBarHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (statusBarHeight == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class&lt;?&gt; c = Class.forName(<span class="string">"com.android.internal.R$dimen"</span>);</span><br><span class="line">                Object o = c.newInstance();</span><br><span class="line">                Field field = c.getField(<span class="string">"status_bar_height"</span>);</span><br><span class="line">                <span class="keyword">int</span> x = (Integer) field.get(o);</span><br><span class="line">                statusBarHeight = getResources().getDimensionPixelSize(x);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> statusBarHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了实现悬浮球随手指移动而移动的效果，于是对<code>onTouchEvent</code>事件进行了重写。在用户按下瞬间触发ACTION_DOWN事件，按下的点在屏幕中的坐标，以及相对于视图的位置，然后随着手指的移动会触发ACTION_MOVE事件，此时获取新的屏幕坐标，更新悬浮球在屏幕中位置，最后手指抬起来，则触发ACTION_UP事件，如果此时的坐标和ACTION_DOWN中坐标是一致的，则表示单击了悬浮窗。记得处理屏幕状态栏的高度，在处理坐标的时候应该减掉这一部分值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.ActivityManager;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.PixelFormat;</span><br><span class="line"><span class="keyword">import</span> android.view.Gravity;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.view.WindowManager;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWindowManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 小悬浮窗View的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FloatWindowSmallView smallWindow;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大悬浮窗View的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FloatWindowBigView bigWindow;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 小悬浮窗View的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> WindowManager.LayoutParams smallWindowParams;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大悬浮窗View的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> WindowManager.LayoutParams bigWindowParams;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于控制在屏幕上添加或移除悬浮窗</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> WindowManager mWindowManager;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于获取手机可用内存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ActivityManager mActivityManager;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个小悬浮窗。初始位置为屏幕的右部中间位置。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     *            必须为应用程序的Context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createSmallWindow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        WindowManager windowManager = getWindowManager(context);</span><br><span class="line">        <span class="keyword">int</span> screenWidth = windowManager.getDefaultDisplay().getWidth();</span><br><span class="line">        <span class="keyword">int</span> screenHeight = windowManager.getDefaultDisplay().getHeight();</span><br><span class="line">        <span class="keyword">if</span> (smallWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">            smallWindow = <span class="keyword">new</span> FloatWindowSmallView(context);</span><br><span class="line">            <span class="keyword">if</span> (smallWindowParams == <span class="keyword">null</span>) &#123;</span><br><span class="line">                smallWindowParams = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">                smallWindowParams.type = WindowManager.LayoutParams.TYPE_PHONE;</span><br><span class="line">                smallWindowParams.format = PixelFormat.RGBA_8888;</span><br><span class="line">                smallWindowParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL</span><br><span class="line">                        | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;</span><br><span class="line">                smallWindowParams.gravity = Gravity.LEFT | Gravity.TOP;</span><br><span class="line">                smallWindowParams.width = FloatWindowSmallView.viewWidth;</span><br><span class="line">                smallWindowParams.height = FloatWindowSmallView.viewHeight;</span><br><span class="line">                smallWindowParams.x = screenWidth;</span><br><span class="line">                smallWindowParams.y = screenHeight / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            smallWindow.setParams(smallWindowParams);</span><br><span class="line">            windowManager.addView(smallWindow, smallWindowParams);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将小悬浮窗从屏幕上移除。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     *            必须为应用程序的Context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeSmallWindow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (smallWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WindowManager windowManager = getWindowManager(context);</span><br><span class="line">            windowManager.removeView(smallWindow);</span><br><span class="line">            smallWindow = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个大悬浮窗。位置为屏幕正中间。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     *            必须为应用程序的Context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createBigWindow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        WindowManager windowManager = getWindowManager(context);</span><br><span class="line">        <span class="keyword">int</span> screenWidth = windowManager.getDefaultDisplay().getWidth();</span><br><span class="line">        <span class="keyword">int</span> screenHeight = windowManager.getDefaultDisplay().getHeight();</span><br><span class="line">        <span class="keyword">if</span> (bigWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bigWindow = <span class="keyword">new</span> FloatWindowBigView(context);</span><br><span class="line">            <span class="keyword">if</span> (bigWindowParams == <span class="keyword">null</span>) &#123;</span><br><span class="line">                bigWindowParams = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">                bigWindowParams.x = screenWidth / <span class="number">2</span> - FloatWindowBigView.viewWidth / <span class="number">2</span>;</span><br><span class="line">                bigWindowParams.y = screenHeight / <span class="number">2</span> - FloatWindowBigView.viewHeight / <span class="number">2</span>;</span><br><span class="line">                bigWindowParams.type = WindowManager.LayoutParams.TYPE_PHONE;</span><br><span class="line">                bigWindowParams.format = PixelFormat.RGBA_8888;</span><br><span class="line">                bigWindowParams.gravity = Gravity.LEFT | Gravity.TOP;</span><br><span class="line">                bigWindowParams.width = FloatWindowBigView.viewWidth;</span><br><span class="line">                bigWindowParams.height = FloatWindowBigView.viewHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            windowManager.addView(bigWindow, bigWindowParams);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将大悬浮窗从屏幕上移除。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     *            必须为应用程序的Context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeBigWindow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bigWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WindowManager windowManager = getWindowManager(context);</span><br><span class="line">            windowManager.removeView(bigWindow);</span><br><span class="line">            bigWindow = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新小悬浮窗的TextView上的数据，显示内存使用的百分比。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     *            可传入应用程序上下文。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateUsedPercent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (smallWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TextView percentView = (TextView) smallWindow.findViewById(R.id.percent);</span><br><span class="line">            percentView.setText(getUsedPercentValue(context));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有悬浮窗(包括小悬浮窗和大悬浮窗)显示在屏幕上。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 有悬浮窗显示在桌面上返回true，没有的话返回false。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isWindowShowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> smallWindow != <span class="keyword">null</span> || bigWindow != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果WindowManager还未创建，则创建一个新的WindowManager返回。否则返回当前已创建的WindowManager。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     *            必须为应用程序的Context.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> WindowManager的实例，用于控制在屏幕上添加或移除悬浮窗。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> WindowManager <span class="title">getWindowManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mWindowManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mWindowManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果ActivityManager还未创建，则创建一个新的ActivityManager返回。否则返回当前已创建的ActivityManager。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     *            可传入应用程序上下文。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ActivityManager的实例，用于获取手机可用内存。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ActivityManager <span class="title">getActivityManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mActivityManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mActivityManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算已使用内存的百分比，并返回。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     *            可传入应用程序上下文。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 已使用内存的百分比，以字符串形式返回。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUsedPercentValue</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        String dir = <span class="string">"/proc/meminfo"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileReader fr = <span class="keyword">new</span> FileReader(dir);</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(fr, <span class="number">2048</span>);</span><br><span class="line">            String memoryLine = br.readLine();</span><br><span class="line">            String subMemoryLine = memoryLine.substring(memoryLine.indexOf(<span class="string">"MemTotal:"</span>));</span><br><span class="line">            br.close();</span><br><span class="line">            <span class="keyword">long</span> totalMemorySize = Integer.parseInt(subMemoryLine.replaceAll(<span class="string">"\\D+"</span>, <span class="string">""</span>));</span><br><span class="line">            <span class="keyword">long</span> availableSize = getAvailableMemory(context) / <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">int</span> percent = (<span class="keyword">int</span>) ((totalMemorySize - availableSize) / (<span class="keyword">float</span>) totalMemorySize * <span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> percent + <span class="string">"%"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"悬浮窗"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前可用内存，返回数据以字节为单位。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     *            可传入应用程序上下文。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前可用内存。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getAvailableMemory</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        ActivityManager.MemoryInfo mi = <span class="keyword">new</span> ActivityManager.MemoryInfo();</span><br><span class="line">        getActivityManager(context).getMemoryInfo(mi);</span><br><span class="line">        <span class="keyword">return</span> mi.availMem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MyWindowManager主要负责了控制悬浮窗的创建和移除，以及悬浮窗在桌面上显示时系统内存使用率计算操作。其中<code>WindowManager.LayoutParams</code>布局参数在一开始就进行了说明，在设置好了后进行<code>addView</code>悬浮窗便可以显示了，而在需要移除的时候，获取到悬浮窗 View 的引用直接进行<code>removeView</code>操作便好。<br>最后记得在<code>AndroidManifest.xml</code>文件中配置好Service和相关权限：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SYSTEM_ALERT_WINDOW"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.SYSTEM_OVERLAY_WINDOW"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.GET_TASKS"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:allowBackup</span>=<span class="string">"true"</span> <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span> <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".FloatWindowService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/11/顶层悬浮球分析与实现/alert_window.jpg" alt="59%内存使用率效果图" title="">                </div>                <div class="image-caption">59%内存使用率效果图</div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，悬浮窗简单的控制还是容易实现的，但对于业务功能稍微复杂来说，合理的内存控制以及交互效果实现是需要花时间研究的地方。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="http://blog.csdn.net/dawanganban/article/details/9751305" target="_blank" rel="noopener">Android桌面悬浮窗效果实现，仿360手机卫士悬浮窗效果</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;悬浮球功能作为顶层视图，在用户关闭了 APP 后也能方便快捷操作，而这类应用主要是系统级别的安全应用，比如一键清理内存。在后续的 Android 版本中，Google 和很多厂商对于此类权限做了更为敏感的控制，需要用户手动设置才能看到悬浮球。下面手动实现了一个悬浮球来分析整个过程，其核心部分就是&lt;code&gt;WindowManager&lt;/code&gt;类对Window的管理。&lt;/p&gt;
&lt;h2 id=&quot;WindowManager&quot;&gt;&lt;a href=&quot;#WindowManager&quot; class=&quot;headerlink&quot; title=&quot;WindowManager&quot;&gt;&lt;/a&gt;WindowManager&lt;/h2&gt;&lt;p&gt;对于&lt;code&gt;WindowManager&lt;/code&gt;的工作过程，可以通过手动添加一个&lt;code&gt;Window&lt;/code&gt;为例去分析：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;TextView mFloatingText = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TextView(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mFloatingText.setText(&lt;span class=&quot;string&quot;&gt;&quot;FloatingText&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WindowManager.LayoutParams params = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; WindowManager.LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,PixelFormat.TRANSPARENT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;params.flags = LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_NOT_FOCUSABLE | LayoutParams.FLAG_SHOW_WHEN_LOCKED;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;params.gravity = Gravity.LEFT | Gravity.TOP;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;params.x = &lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;params.y = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mWindowManager.addView(mFloatingText,params);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="Service" scheme="https://hjw541988478.github.io/tags/Service/"/>
    
      <category term="FloatWindow" scheme="https://hjw541988478.github.io/tags/FloatWindow/"/>
    
      <category term="WindowManager" scheme="https://hjw541988478.github.io/tags/WindowManager/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp探索使用</title>
    <link href="https://hjw541988478.github.io/2015/09/OkHttp%E6%8E%A2%E7%B4%A2%E4%BD%BF%E7%94%A8/"/>
    <id>https://hjw541988478.github.io/2015/09/OkHttp探索使用/</id>
    <published>2015-09-16T12:12:00.000Z</published>
    <updated>2018-08-18T12:25:09.957Z</updated>
    
    <content type="html"><![CDATA[<p>为Android和Java应用设计并且支持SPDY和HTTP请求的客户端。</p><h2 id="Calls"><a href="#Calls" class="headerlink" title="Calls"></a>Calls</h2><h3 id="Requests-请求"><a href="#Requests-请求" class="headerlink" title="Requests(请求)"></a><a href="http://square.github.io/okhttp/javadoc/com/squareup/okhttp/Request.html" target="_blank" rel="noopener">Requests(请求)</a></h3><p>每个HTTP请求包含了URL、METHOD和一系列头部信息。当然，头部也可以包含指定类型的数据流。</p><h3 id="Responses-响应"><a href="#Responses-响应" class="headerlink" title="Responses(响应)"></a><a href="http://square.github.io/okhttp/javadoc/com/squareup/okhttp/Response.html" target="_blank" rel="noopener">Responses(响应)</a></h3><p>带有状态码，Header和一些可选信息的对请求的响应。</p><h3 id="Calls-调用"><a href="#Calls-调用" class="headerlink" title="Calls(调用)"></a><a href="http://square.github.io/okhttp/javadoc/com/squareup/okhttp/Call.html" target="_blank" rel="noopener">Calls(调用)</a></h3><p>调用能够以Synchronous(同步)或者Asynchronous(异步)的形式被执行:</p><ul><li>Synchronous：请求线程直到响应能够可读时才会释放阻塞；</li><li>Asynchronous：请求线程能够将请求进行入队操作，直到响应发生时以回调接口的形式返回。</li></ul><h2 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h2><h3 id="URLS-统一资源定位符"><a href="#URLS-统一资源定位符" class="headerlink" title="URLS(统一资源定位符)"></a><a href="http://developer.android.com/reference/java/net/URL.html" target="_blank" rel="noopener">URLS(统一资源定位符)</a></h3><p>URLs对于HTTP和互联网世界来说是至关重要的，除了成为通用的、web世界里唯一命名的解决方案，它们同时也描述了如何获取web资源。</p><h3 id="Addresses-地址"><a href="#Addresses-地址" class="headerlink" title="Addresses(地址)"></a><a href="http://square.github.io/okhttp/javadoc/com/squareup/okhttp/Address.html" target="_blank" rel="noopener">Addresses(地址)</a></h3><p>地址描述了一个web服务器和一切对于连接到服务器必要的静态配置信息，比如端口号，HTTPS设置等。共享同一地址的URL同样也共享同一的TCP连接，这样做的好处是：更低的延迟、更高的吞吐量和低消耗电量。OkHttp使用自动重用HTTP/1.x协议的连接和多路复用HTTP/2和SPDY的连接的ConnectionPool（连接池）。</p><h3 id="Routes-路由"><a href="#Routes-路由" class="headerlink" title="Routes(路由)"></a><a href="http://square.github.io/okhttp/javadoc/com/squareup/okhttp/Route.html" target="_blank" rel="noopener">Routes(路由)</a></h3><p>路由提供连接到web服务器的必要的动态信息。对于一个地址来说可能存在着多条路由选择。</p><h3 id="Connections-连接"><a href="#Connections-连接" class="headerlink" title="Connections(连接)"></a><a href="http://square.github.io/okhttp/javadoc/com/squareup/okhttp/Connection.html" target="_blank" rel="noopener">Connections(连接)</a></h3><p>如果使用OkHttp进行请求的话，它会这么做：<br><a id="more"></a></p><ol><li>使用给出的URL和配置好的OkHttpClient产生一个Address，这个Address描述了我们如何连接到web服务器；</li><li>试图从ConnectionPool(连接池)重新获得一个连接；</li><li>如果在连接池找不到连接，它将尝试选择一条路由信息。这也意味着会产生一个DNS请求以便获取真实的服务器IP地址，然后选择TLS版本以及必要时代理服务器的相关信息；</li><li>如果是新的路由，它将会通过Socket进行直接连接或者TLS隧道，必要时会进行握手，进行连接；</li><li>发送HTTP请求并获得响应信息。<br>一旦响应成功接收到后，连接会被加入到连接池中以便后续的复用，但如果长时间的不使用的后，连接也会从连接池中丢弃。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="SynchronousGet"><a href="#SynchronousGet" class="headerlink" title="SynchronousGet"></a><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java" target="_blank" rel="noopener">SynchronousGet</a></h3><p>同步Get请求，响应中的<code>string()</code>方法很方便地让响应以String的形式返回，但数据量大于1M的时候，优先使用Stream。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line">  Headers responseHeaders = response.headers();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; responseHeaders.size(); i++) &#123;</span><br><span class="line">    System.out.println(responseHeaders.name(i) + <span class="string">": "</span> + responseHeaders.value(i));</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(response.body().string());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Asynchronous-Get"><a href="#Asynchronous-Get" class="headerlink" title="Asynchronous Get"></a><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java" target="_blank" rel="noopener">Asynchronous Get</a></h3><p>在工作线程上下载文件，当响应可读的时候获取回调接口。回调接口是在响应的头部信息准备好时便准备完毕了，此时直接读取响应的信息可能会导致阻塞。目前的OkHttp版本暂未提供异步的APi去解析接收Response。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Request request, Throwable throwable)</span> </span>&#123;</span><br><span class="line">      throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line">      Headers responseHeaders = response.headers();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; responseHeaders.size(); i++) &#123;</span><br><span class="line">        System.out.println(responseHeaders.name(i) + <span class="string">": "</span> + responseHeaders.value(i));</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(response.body().string());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Accessing-Headers"><a href="#Accessing-Headers" class="headerlink" title="Accessing Headers"></a><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java" target="_blank" rel="noopener">Accessing Headers</a></h3><p>显而易见地，HTTP的头部信息与Map这种数据结构是很相似的，每一个key对应着一个value，但有些头部允许着多个value，比如Guava的Multimap,对于这些情况，OkHttp同时都支持的。<br>当写入请求头部信息的时候，使用header(name,value)来设置唯一的键值。如果有存在着对应的值，在新的值设置好之前旧的值会被移除掉。可以考虑使用addHeaeder(name,value)来使得一个key对应着多个值。<br>当读取响应体的头部信息时，可以使用header(name)来获取最后一个设置的值。通常来说这也是唯一的引用，但是如果没有对应的值的话，会返回null。在读取多值对应一键的情况下时，使用headerss(name)来以List的形式来获取其值。<br>如果想获取所有的头部，可以考虑使用Headers类通过索引来获取每一个头。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"https://api.github.com/repos/square/okhttp/issues"</span>)</span><br><span class="line">      .header(<span class="string">"User-Agent"</span>, <span class="string">"OkHttp Headers.java"</span>)</span><br><span class="line">      .addHeader(<span class="string">"Accept"</span>, <span class="string">"application/json; q=0.5"</span>)</span><br><span class="line">      .addHeader(<span class="string">"Accept"</span>, <span class="string">"application/vnd.github.v3+json"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line">  System.out.println(<span class="string">"Server: "</span> + response.header(<span class="string">"Server"</span>));</span><br><span class="line">  System.out.println(<span class="string">"Date: "</span> + response.header(<span class="string">"Date"</span>));</span><br><span class="line">  System.out.println(<span class="string">"Vary: "</span> + response.headers(<span class="string">"Vary"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Post-String"><a href="#Post-String" class="headerlink" title="Post String"></a><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java" target="_blank" rel="noopener">Post String</a></h3><p>当POST请求的字符串数据小于1MB的时候，推荐使用这种方式请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</span><br><span class="line">      = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String postBody = <span class="string">""</span></span><br><span class="line">        + <span class="string">"Releases\n"</span></span><br><span class="line">        + <span class="string">"--------\n"</span></span><br><span class="line">        + <span class="string">"\n"</span></span><br><span class="line">        + <span class="string">" * _1.0_ May 6, 2013\n"</span></span><br><span class="line">        + <span class="string">" * _1.1_ June 15, 2013\n"</span></span><br><span class="line">        + <span class="string">" * _1.2_ August 11, 2013\n"</span>;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</span><br><span class="line">        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))</span><br><span class="line">        .build();</span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="Post-Streaming"><a href="#Post-Streaming" class="headerlink" title="Post Streaming"></a><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java" target="_blank" rel="noopener">Post Streaming</a></h3><p>当以流的形式进行POST请求时，请求体的内容已经生成了就如同被写入了一样。下面的例子中使用了Okio的缓冲池。但一般情况下我们会使用OutputStream，我们可以使用BufferedSink.outputStream()来获取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</span><br><span class="line">     = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   RequestBody requestBody = <span class="keyword">new</span> RequestBody() &#123;</span><br><span class="line">     <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> MediaType <span class="title">contentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> MEDIA_TYPE_MARKDOWN;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(BufferedSink sink)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       sink.writeUtf8(<span class="string">"Numbers\n"</span>);</span><br><span class="line">       sink.writeUtf8(<span class="string">"-------\n"</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">997</span>; i++) &#123;</span><br><span class="line">         sink.writeUtf8(String.format(<span class="string">" * %s = %s\n"</span>, i, factor(i)));</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> String <span class="title">factor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">         <span class="keyword">int</span> x = n / i;</span><br><span class="line">         <span class="keyword">if</span> (x * i == n) <span class="keyword">return</span> factor(x) + <span class="string">" × "</span> + i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Integer.toString(n);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">       .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</span><br><span class="line">       .post(requestBody)</span><br><span class="line">       .build();</span><br><span class="line">   Response response = client.newCall(request).execute();</span><br><span class="line">   <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line">   System.out.println(response.body().string());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="Post-File"><a href="#Post-File" class="headerlink" title="Post File"></a><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java" target="_blank" rel="noopener">Post File</a></h3><p>使用文件作为请求体是很容易的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</span><br><span class="line">      = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"README.md"</span>);</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</span><br><span class="line">        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))</span><br><span class="line">        .build();</span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line">    System.out.println(response.body().string());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="Posting-form-parameters"><a href="#Posting-form-parameters" class="headerlink" title="Posting form parameters"></a><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java" target="_blank" rel="noopener">Posting form parameters</a></h3><p>使用FormEncodingBuilder来构造一个可以像HTML中<form>标签的请求体。键值对会与HTML相适应地特性从URL中进行编码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   RequestBody formBody = <span class="keyword">new</span> FormEncodingBuilder()</span><br><span class="line">       .add(<span class="string">"search"</span>, <span class="string">"Jurassic Park"</span>)</span><br><span class="line">       .build();</span><br><span class="line">   Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">       .url(<span class="string">"https://en.wikipedia.org/w/index.php"</span>)</span><br><span class="line">       .post(formBody)</span><br><span class="line">       .build();</span><br><span class="line">   Response response = client.newCall(request).execute();</span><br><span class="line">   <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line">   System.out.println(response.body().string());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></form></p><h3 id="Posting-a-multipart-request"><a href="#Posting-a-multipart-request" class="headerlink" title="Posting a multipart request"></a><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java" target="_blank" rel="noopener">Posting a multipart request</a></h3><p><code>MultipartBuilder</code>可以用来构造复杂的请求体，每一部分都是一个请求体，并且可以自定义头部信息。如果存在的话，请求体的头部信息应该描述请求的内容，比如Content-Disposition。当然如果Content-Length与Content-Type存在的话，会自动加入到请求的头部当中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IMGUR_CLIENT_ID = <span class="string">"..."</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_PNG = MediaType.parse(<span class="string">"image/png"</span>);</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image</span></span><br><span class="line">   RequestBody requestBody = <span class="keyword">new</span> MultipartBuilder()</span><br><span class="line">       .type(MultipartBuilder.FORM)</span><br><span class="line">       .addPart(</span><br><span class="line">           Headers.of(<span class="string">"Content-Disposition"</span>, <span class="string">"form-data; name=\"title\""</span>),</span><br><span class="line">           RequestBody.create(<span class="keyword">null</span>, <span class="string">"Square Logo"</span>))</span><br><span class="line">       .addPart(</span><br><span class="line">           Headers.of(<span class="string">"Content-Disposition"</span>, <span class="string">"form-data; name=\"image\""</span>),</span><br><span class="line">           RequestBody.create(MEDIA_TYPE_PNG, <span class="keyword">new</span> File(<span class="string">"website/static/logo-square.png"</span>)))</span><br><span class="line">       .build();</span><br><span class="line">   Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">       .header(<span class="string">"Authorization"</span>, <span class="string">"Client-ID "</span> + IMGUR_CLIENT_ID)</span><br><span class="line">       .url(<span class="string">"https://api.imgur.com/3/image"</span>)</span><br><span class="line">       .post(requestBody)</span><br><span class="line">       .build();</span><br><span class="line">   Response response = client.newCall(request).execute();</span><br><span class="line">   <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line">   System.out.println(response.body().string());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="Parse-a-JSON-Response-With-Gson"><a href="#Parse-a-JSON-Response-With-Gson" class="headerlink" title="Parse a JSON Response With Gson"></a><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java" target="_blank" rel="noopener">Parse a JSON Response With Gson</a></h3><p>GSON是一个很方便的API用来转换JSON和Java对象，需要的注意的是ResponseBody.charStream方法默认使用UTF-8编码进行解码，如果有必要的话请设置Content-Type。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"https://api.github.com/gists/c2a7c39532239ff261be"</span>)</span><br><span class="line">        .build();</span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line">    Gist gist = gson.fromJson(response.body().charStream(), Gist.class);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123;</span><br><span class="line">      System.out.println(entry.getKey());</span><br><span class="line">      System.out.println(entry.getValue().content);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Gist</span> </span>&#123;</span><br><span class="line">    Map&lt;String, GistFile&gt; files;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GistFile</span> </span>&#123;</span><br><span class="line">    String content;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="Response-Caching"><a href="#Response-Caching" class="headerlink" title="Response Caching"></a><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java" target="_blank" rel="noopener">Response Caching</a></h3><p>但需要缓存的时候，应该指定用来进行缓存的目录，缓存目录一般只是用来给自己进行读写的，而非让任意应用进行缓存。多个缓存访问同一个缓存目录是一种错误的做法，如果需要多个缓存应该使用多个<code>OkHttpClient</code>实例去设置多个缓存目录，否则可能会造成应用崩溃。当然有一种更简洁的做法是直接在头部信息里面设置Cache-Control:max-age=9600来允许缓存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">CacheResponse</span><span class="params">(File cacheDirectory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> cacheSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 10 MiB</span></span><br><span class="line">   Cache cache = <span class="keyword">new</span> Cache(cacheDirectory, cacheSize);</span><br><span class="line">   client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">   client.setCache(cache);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">       .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">       .build();</span><br><span class="line">   Response response1 = client.newCall(request).execute();</span><br><span class="line">   <span class="keyword">if</span> (!response1.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response1);</span><br><span class="line">   String response1Body = response1.body().string();</span><br><span class="line">   System.out.println(<span class="string">"Response 1 response:          "</span> + response1);</span><br><span class="line">   System.out.println(<span class="string">"Response 1 cache response:    "</span> + response1.cacheResponse());</span><br><span class="line">   System.out.println(<span class="string">"Response 1 network response:  "</span> + response1.networkResponse());</span><br><span class="line">   Response response2 = client.newCall(request).execute();</span><br><span class="line">   <span class="keyword">if</span> (!response2.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response2);</span><br><span class="line">   String response2Body = response2.body().string();</span><br><span class="line">   System.out.println(<span class="string">"Response 2 response:          "</span> + response2);</span><br><span class="line">   System.out.println(<span class="string">"Response 2 cache response:    "</span> + response2.cacheResponse());</span><br><span class="line">   System.out.println(<span class="string">"Response 2 network response:  "</span> + response2.networkResponse());</span><br><span class="line">   System.out.println(<span class="string">"Response 2 equals Response 1? "</span> + response1Body.equals(response2Body));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>为了防止响应使用缓存，可以通过设置<code>CacheControl.FORCE_NETWORK</code>来强制使用网络，当然也可以设置<code>CacheControl.FORCE_CACHE</code>来强制使用缓存而不使用网络。但值得注意的地方就是，在强制使用缓存的时候，然而响应需要使用网络，此时会返回504 Unsatisfiable Request错误。</p><h3 id="Canceling-a-Call"><a href="#Canceling-a-Call" class="headerlink" title="Canceling a Call"></a><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java" target="_blank" rel="noopener">Canceling a Call</a></h3><p>使用<code>Call.cancell</code>来立即取消正在进行的请求。如果此时正在进行请求或者读取响应时，执行该操作会导致IOException。在不需要进行请求的时候才进行cancel的请求，比如已经离开了应用，此时所有异步和同步的请求都可以取消。<br>一种简便的方法是使用tag参数，构造请求的时候使用<code>RequestBuilder.tag(tag)</code>，在取消的时候使用<code>OkHttpClient.cancel(tag)</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"http://httpbin.org/delay/2"</span>) <span class="comment">// This URL is served with a 2 second delay.</span></span><br><span class="line">        .build();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNanos = System.nanoTime();</span><br><span class="line">    <span class="keyword">final</span> Call call = client.newCall(request);</span><br><span class="line">    <span class="comment">// Schedule a job to cancel the call in 1 second.</span></span><br><span class="line">    executor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"%.2f Canceling call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</span><br><span class="line">        call.cancel();</span><br><span class="line">        System.out.printf(<span class="string">"%.2f Canceled call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.printf(<span class="string">"%.2f Executing call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</span><br><span class="line">      Response response = call.execute();</span><br><span class="line">      System.out.printf(<span class="string">"%.2f Call was expected to fail, but completed: %s%n"</span>,</span><br><span class="line">          (System.nanoTime() - startNanos) / <span class="number">1e9f</span>, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      System.out.printf(<span class="string">"%.2f Call failed as expected: %s%n"</span>,</span><br><span class="line">          (System.nanoTime() - startNanos) / <span class="number">1e9f</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="Timeouts"><a href="#Timeouts" class="headerlink" title="Timeouts"></a><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java" target="_blank" rel="noopener">Timeouts</a></h3><p>超时的问题可以使用<code>OkHttpClient</code>来进行设置读取、连接的超时时间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ConfigureTimeouts</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">   client.setConnectTimeout(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">   client.setWriteTimeout(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">   client.setReadTimeout(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">       .url(<span class="string">"http://httpbin.org/delay/2"</span>) <span class="comment">// This URL is served with a 2 second delay.</span></span><br><span class="line">       .build();</span><br><span class="line">   Response response = client.newCall(request).execute();</span><br><span class="line">   System.out.println(<span class="string">"Response completed: "</span> + response);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="Per-call-Configuration"><a href="#Per-call-Configuration" class="headerlink" title="Per-call Configuration"></a><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java" target="_blank" rel="noopener">Per-call Configuration</a></h3><p>可以使用已经配置好的请求来克隆其配置，同时单独配置其他信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"http://httpbin.org/delay/1"</span>) <span class="comment">// This URL is served with a 1 second delay.</span></span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      OkHttpClient cloned = client.clone(); <span class="comment">// Clone to make a customized OkHttp for this request.</span></span><br><span class="line">      cloned.setReadTimeout(<span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">      Response response = cloned.newCall(request).execute();</span><br><span class="line">      System.out.println(<span class="string">"Response 1 succeeded: "</span> + response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Response 1 failed: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      OkHttpClient cloned = client.clone(); <span class="comment">// Clone to make a customized OkHttp for this request.</span></span><br><span class="line">      cloned.setReadTimeout(<span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">      Response response = cloned.newCall(request).execute();</span><br><span class="line">      System.out.println(<span class="string">"Response 2 succeeded: "</span> + response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Response 2 failed: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="Handling-authentication"><a href="#Handling-authentication" class="headerlink" title="Handling authentication"></a><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java" target="_blank" rel="noopener">Handling authentication</a></h3><p>OKHttp对于未认证的请求失败时会进行自动重试，当发生了401错误时，使用Authenticator来设置相关认证信息，在构造新的请求的时候应该去包括缺失的认证信息，如果不存在的时候设置null便好。<br>可以使用<code>Response.challenges()</code>来获取相关认证信息，但已经实现了一个基本的认证信息时，只需要使用Credentials.basic(username,password来加密请求头便好。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  client.setAuthenticator(<span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">authenticate</span><span class="params">(Proxy proxy, Response response)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Authenticating for response: "</span> + response);</span><br><span class="line">      System.out.println(<span class="string">"Challenges: "</span> + response.challenges());</span><br><span class="line">      String credential = Credentials.basic(<span class="string">"jesse"</span>, <span class="string">"password1"</span>);</span><br><span class="line">      <span class="keyword">return</span> response.request().newBuilder()</span><br><span class="line">          .header(<span class="string">"Authorization"</span>, credential)</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">authenticateProxy</span><span class="params">(Proxy proxy, Response response)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Null indicates no attempt to authenticate.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(<span class="string">"http://publicobject.com/secrets/hellosecret.txt"</span>)</span><br><span class="line">      .build();</span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line">  System.out.println(response.body().string());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了避免多次重试造成的认证无法正常工作的情况，可以选择返回nulll。当然也可以像下面一样的处理方式来处理认证失败的情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (credential.equals(response.request().header(<span class="string">"Authorization"</span>))) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// If we already failed with these credentials, don't retry.</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>同时也可以指定重试次数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (responseCount(response) &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// If we've failed 3 times, give up.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重试次数的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">responseCount</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ((response = response.priorResponse()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Interceptors-拦截器"><a href="#Interceptors-拦截器" class="headerlink" title="Interceptors(拦截器)"></a><a href="">Interceptors(拦截器)</a></h2><p>拦截器是一种用来进行监控，重写，重试和重新调用的强大机制。下面是一种简单的实现，只是用来简单的LOG输出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Sending request %s on %s%n%s"</span>,</span><br><span class="line">        request.url(), chain.connection(), request.headers()));</span><br><span class="line">    Response response = chain.proceed(request);</span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    logger.info(String.format(<span class="string">"Received response for %s in %.1fms%n%s"</span>,</span><br><span class="line">        response.request().url(), (t2 - t1) / <span class="number">1e6</span>d, response.headers()));</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>chain.proceed(request)</code>该调用方法是每个拦截器实现的关键部分，看起来简单的方法事实上完成了所有的HTTP调用与处理流程。<br>拦截器也是能够被链接起来的，假设同时拥有压缩的拦截器和校验的拦截器，这里需要确定何时进行校验，何时进行压缩。OkHttp会使用列表进行跟踪，确保拦截器的有序执行。拦截器的允许机制如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="okhttp_interceptors.png" alt="拦截器运行机制" title="">                </div>                <div class="image-caption">拦截器运行机制</div>            </figure><br>由图可以看到的是，拦截器存在着两种工作域，全局的拦截器和网络拦截器。</p><h3 id="Application-Interceptors"><a href="#Application-Interceptors" class="headerlink" title="Application Interceptors"></a>Application Interceptors</h3><p>下面使用LoginInterceptor来对上面两种拦截器进行区分。使用<code>OkHttpClient.interceptors()</code>获取拦截器列表，然后使用add方法进行新的拦截器的添加。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">client.interceptors().add(<span class="keyword">new</span> LoggingInterceptor());</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"http://www.publicobject.com/helloworld.txt"</span>)</span><br><span class="line">    .header(<span class="string">"User-Agent"</span>, <span class="string">"OkHttp Example"</span>)</span><br><span class="line">    .build();</span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line">response.body().close();</span><br></pre></td></tr></table></figure></p><p>假设存在着重定向的链接，Application级别的拦截器只会被调用一次，即请求时的Sending…和最后返回的</p><h3 id="Network-Interceptors"><a href="#Network-Interceptors" class="headerlink" title="Network Interceptors"></a>Network Interceptors</h3><p>使用网络层级别的拦截器与上面的很相似，只不过在获取系统拦截器列表的操作<code>interceptors()</code>换成了<code>networkInterceptors()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">client.networkInterceptors().add(<span class="keyword">new</span> LoggingInterceptor());</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(<span class="string">"http://www.publicobject.com/helloworld.txt"</span>)</span><br><span class="line">    .header(<span class="string">"User-Agent"</span>, <span class="string">"OkHttp Example"</span>)</span><br><span class="line">    .build();</span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line">response.body().close();</span><br></pre></td></tr></table></figure></p><p>对于已存在的重定向的链接，Network级别的拦截器会被调用多次，对应着多个Sending ..和Received..。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul><li>Application interceptors<ul><li>无需担心中间产生的响应；</li><li>尽管HTTP响应是从缓存中获得的，但是总是只会调用一次；</li><li>只关心应用原始的意图，对于OkHttp自动注入的头部信息并不关心；</li><li>允许短路而且无需调用Chain.proceed()；</li><li>允许重试而且通过Chain.proceed()来产生多次调用；</li></ul></li><li>Network interceptors<ul><li>能够处理中间产生的相应，比如重定向和重试；</li><li>对于网络短路而使用缓存的响应不会被调用；</li><li>只关心数据流动正像数据从整个网络传输一样；</li><li>能够访问带有请求的Connection对象</li></ul></li></ul><h3 id="重写请求头"><a href="#重写请求头" class="headerlink" title="重写请求头"></a>重写请求头</h3><p>拦截器可以任意地添加，移除或者替换，对于存在的头可以随意变换。比如，服务端能够支持压缩的请求流，此时可以在Application interceptor中去处理压缩过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This interceptor compresses the HTTP request body. Many webservers can't handle this! */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GzipRequestInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request originalRequest = chain.request();</span><br><span class="line">    <span class="keyword">if</span> (originalRequest.body() == <span class="keyword">null</span> || originalRequest.header(<span class="string">"Content-Encoding"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    Request compressedRequest = originalRequest.newBuilder()</span><br><span class="line">        .header(<span class="string">"Content-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">        .method(originalRequest.method(), gzip(originalRequest.body()))</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> chain.proceed(compressedRequest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> RequestBody <span class="title">gzip</span><span class="params">(<span class="keyword">final</span> RequestBody body)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBody() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> MediaType <span class="title">contentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> body.contentType();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// We don't know the compressed length in advance!</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(BufferedSink sink)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedSink gzipSink = Okio.buffer(<span class="keyword">new</span> GzipSink(sink));</span><br><span class="line">        body.writeTo(gzipSink);</span><br><span class="line">        gzipSink.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="重写响应"><a href="#重写响应" class="headerlink" title="重写响应"></a>重写响应</h3><p>既然能够重写请求，那么也可以重写响应。但对于大多数情况下都是不推荐的，因为这回影响返回结果的正确性。不过有时候可以修正某些预先配置错误的信息。比如Cache-Control。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Dangerous interceptor that rewrites the server's cache-control header. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = <span class="keyword">new</span> Interceptor() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Response originalResponse = chain.proceed(chain.request());</span><br><span class="line">    <span class="keyword">return</span> originalResponse.newBuilder()</span><br><span class="line">        .header(<span class="string">"Cache-Control"</span>, <span class="string">"max-age=60"</span>)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>OkHttp尝试平衡下面两个具有竞争性质的点：</p><ul><li>(Connectivity) 更多版本更全面的连接。</li><li>(Security) 更多版本的证书支持。<br>总的来说，尽可能使用新版本的OKHttp使得连接性和安全性都能得到保证。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>参考Wiki和其他博文，自己总结写了个轻量级的能够更快捷方便的OkHttpUtil，支持多种请求：<br>Github：<a href="https://github.com/hjw541988478/OkHttpTutorial" target="_blank" rel="noopener">https://github.com/hjw541988478/OkHttpTutorial</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp</a></li><li><a href="https://github.com/square/okhttp/wiki" target="_blank" rel="noopener">OkHttpWiki</a></li><li><a href="http://blog.csdn.net/lmj623565791/article/details/47911083" target="_blank" rel="noopener">Android OkHttp完全解析 是时候来了解OkHttp了</a></li><li><a href="http://blog.csdn.net/lmj623565791/article/details/48129405" target="_blank" rel="noopener">Android Https相关完全解析 当OkHttp遇到Https</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为Android和Java应用设计并且支持SPDY和HTTP请求的客户端。&lt;/p&gt;
&lt;h2 id=&quot;Calls&quot;&gt;&lt;a href=&quot;#Calls&quot; class=&quot;headerlink&quot; title=&quot;Calls&quot;&gt;&lt;/a&gt;Calls&lt;/h2&gt;&lt;h3 id=&quot;Requests-请求&quot;&gt;&lt;a href=&quot;#Requests-请求&quot; class=&quot;headerlink&quot; title=&quot;Requests(请求)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://square.github.io/okhttp/javadoc/com/squareup/okhttp/Request.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Requests(请求)&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;每个HTTP请求包含了URL、METHOD和一系列头部信息。当然，头部也可以包含指定类型的数据流。&lt;/p&gt;
&lt;h3 id=&quot;Responses-响应&quot;&gt;&lt;a href=&quot;#Responses-响应&quot; class=&quot;headerlink&quot; title=&quot;Responses(响应)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://square.github.io/okhttp/javadoc/com/squareup/okhttp/Response.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Responses(响应)&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;带有状态码，Header和一些可选信息的对请求的响应。&lt;/p&gt;
&lt;h3 id=&quot;Calls-调用&quot;&gt;&lt;a href=&quot;#Calls-调用&quot; class=&quot;headerlink&quot; title=&quot;Calls(调用)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://square.github.io/okhttp/javadoc/com/squareup/okhttp/Call.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Calls(调用)&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;调用能够以Synchronous(同步)或者Asynchronous(异步)的形式被执行:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Synchronous：请求线程直到响应能够可读时才会释放阻塞；&lt;/li&gt;
&lt;li&gt;Asynchronous：请求线程能够将请求进行入队操作，直到响应发生时以回调接口的形式返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Connections&quot;&gt;&lt;a href=&quot;#Connections&quot; class=&quot;headerlink&quot; title=&quot;Connections&quot;&gt;&lt;/a&gt;Connections&lt;/h2&gt;&lt;h3 id=&quot;URLS-统一资源定位符&quot;&gt;&lt;a href=&quot;#URLS-统一资源定位符&quot; class=&quot;headerlink&quot; title=&quot;URLS(统一资源定位符)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://developer.android.com/reference/java/net/URL.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;URLS(统一资源定位符)&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;URLs对于HTTP和互联网世界来说是至关重要的，除了成为通用的、web世界里唯一命名的解决方案，它们同时也描述了如何获取web资源。&lt;/p&gt;
&lt;h3 id=&quot;Addresses-地址&quot;&gt;&lt;a href=&quot;#Addresses-地址&quot; class=&quot;headerlink&quot; title=&quot;Addresses(地址)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://square.github.io/okhttp/javadoc/com/squareup/okhttp/Address.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Addresses(地址)&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;地址描述了一个web服务器和一切对于连接到服务器必要的静态配置信息，比如端口号，HTTPS设置等。共享同一地址的URL同样也共享同一的TCP连接，这样做的好处是：更低的延迟、更高的吞吐量和低消耗电量。OkHttp使用自动重用HTTP/1.x协议的连接和多路复用HTTP/2和SPDY的连接的ConnectionPool（连接池）。&lt;/p&gt;
&lt;h3 id=&quot;Routes-路由&quot;&gt;&lt;a href=&quot;#Routes-路由&quot; class=&quot;headerlink&quot; title=&quot;Routes(路由)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://square.github.io/okhttp/javadoc/com/squareup/okhttp/Route.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Routes(路由)&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;路由提供连接到web服务器的必要的动态信息。对于一个地址来说可能存在着多条路由选择。&lt;/p&gt;
&lt;h3 id=&quot;Connections-连接&quot;&gt;&lt;a href=&quot;#Connections-连接&quot; class=&quot;headerlink&quot; title=&quot;Connections(连接)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://square.github.io/okhttp/javadoc/com/squareup/okhttp/Connection.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Connections(连接)&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;如果使用OkHttp进行请求的话，它会这么做：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="Okhttp" scheme="https://hjw541988478.github.io/tags/Okhttp/"/>
    
  </entry>
  
  <entry>
    <title>MaterialDesign设计探索使用</title>
    <link href="https://hjw541988478.github.io/2015/09/MaterialDesign%E8%AE%BE%E8%AE%A1%E6%8E%A2%E7%B4%A2%E4%BD%BF%E7%94%A8/"/>
    <id>https://hjw541988478.github.io/2015/09/MaterialDesign设计探索使用/</id>
    <published>2015-09-09T11:24:14.000Z</published>
    <updated>2018-08-18T15:44:18.717Z</updated>
    
    <content type="html"><![CDATA[<p>在Android5.0之后，Google就开始推崇一门新的设计语言<code>MaterialDesign</code>，它更加新鲜和简洁，且能够非常有效的激发应用开发者的创作热情，也能够降低开发者自主开发设计UI的难度，对于MD风格的实现，Google后续完善了下面几个库，一步步的实现MD标准的交互效果。<br>需要在AndroidStudio引入的库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:design:23.0.0&apos;</span><br><span class="line">compile &apos;com.android.support:appcompat-v7:23.0.0&apos;</span><br><span class="line">compile &apos;com.android.support:recyclerview-v7:23.0.0&apos;</span><br><span class="line">compile &apos;com.android.support:cardview-v7:23.0.0&apos;</span><br></pre></td></tr></table></figure></p><h2 id="新的UI组件"><a href="#新的UI组件" class="headerlink" title="新的UI组件"></a>新的UI组件</h2><h3 id="CoordinatorLayout"><a href="#CoordinatorLayout" class="headerlink" title="CoordinatorLayout"></a>CoordinatorLayout</h3><p><code>CoordinatorLayout</code>在<code>android.support.deisgn</code>中，是一种增强型的<code>FrameLayout</code>，主要有以下两大基础性作用：</p><ul><li>作为顶级应用的装饰器；</li><li>作为给多个子View之间进行特定交互的协调器；<br>通过对子<code>View</code>的<code>Behavior</code>的指定，可以实现子<code>View</code>之间的通信，从而确定它们具体的交互行为。<a id="more"></a></li></ul><h4 id="Behavior"><a href="#Behavior" class="headerlink" title="Behavior"></a>Behavior</h4><ul><li>官方提供的Behavior<br><code>Behaivor</code>是<code>CoordinatorLayout</code>子View之间进行交互的插件，包括了一种或多种交互行为，如拖拉、滑动、下拉等各种手势。已知的子类有<code>AppBarLayout.Behavior，AppBarLayout.ScrollingViewBehavior， FloatingActionButton.Behavior和SwipeDismissBehavior&lt;V extends View&gt;</code>,这些可以直接使用<code>@string/**</code>的形式在<code>layout_behavior</code>属性中使用。</li><li>自定义Behavior<br>自定义的<code>Behavior</code>需要重新实现的回调方法有：</li></ul><ol><li><code>public boolean layoutDependsOn (CoordinatorLayout parent, View child, View dependency)</code><br>该方法确定是否有另一个指定的兄弟View作为依赖布局，并且作为对布局请求的响应，至少会调用一次。如果指定的child和dependency返回为true,父<code>ViewCoordinatorLayout</code>可能会做以下两件事：<br>不管子View的命令，始终在<code>dependencyView</code>后展示child；<br>当dependency视图布局或位置发生变化时，调用<code>onDepentViewChanged</code>方法；</li><li><code>public boolean onDependentViewChanged (CoordinatorLayout parent, View child, View dependency)</code><br>无论dependency尺寸或者布局改变，该方法都会被调用。<code>Behavior</code>可能会合适地使用该方法来更新视图以此作为回应。当<code>layoutDependsOn</code>被调用时或者child设置了以一个锚视图，dependency也会改变。如果<code>Behavior</code>改变了child的位置或者大小，则返回true。</li></ol><h3 id="NestingScrolling"><a href="#NestingScrolling" class="headerlink" title="NestingScrolling"></a>NestingScrolling</h3><h4 id="原始触摸事件分发"><a href="#原始触摸事件分发" class="headerlink" title="原始触摸事件分发"></a>原始触摸事件分发</h4><p>目前的触摸事件的分发机制都是从父View传递给子View，会经历<code>dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent</code>，但是如果触摸事件分发给子View的时候，而子View想根据实际情况将事件向上层传递给父View，而这个时候子View并没有办法通知父View，只能将事件抛弃。</p><h4 id="嵌套滑动处理流程"><a href="#嵌套滑动处理流程" class="headerlink" title="嵌套滑动处理流程"></a>嵌套滑动处理流程</h4><p>在行的嵌套滑动机制中，可以使用到supportv4包中<code>NestedScrollingChild</code>类，包括下面几个关键的方法：</p><ul><li><code>public boolean startNestedScroll(int axes)</code><br>子View寻找能够接受嵌套滑动事件的ParentView，然后通知父View，配合处理触摸事件；</li><li><code>public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow)</code><br>在子View中的<code>onInterceptTouch</code>或者<code>onTouch</code>事件中，通过调用该方法通知父View滑动的距离。其中第三个参数父View消费掉的滑动长度，第四个参数返回子View的窗体偏移量。由于窗体进行了移动，为了下一次触摸事件计算正确，还需要根据第四个参数来计算偏移量。整个方法返回的值是根据父View是否有接受子View滚动参数的消费来决定返回true或者false；</li><li><code>public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)</code><br>在子View进行了scroll后，如果父View接受到了它的滚动参数并进行了消费，则返回true，否则返回false；</li><li><code>public void stopNestedScroll()</code><br>整个嵌套处理流程结束。</li></ul><h3 id="AppBarLayout"><a href="#AppBarLayout" class="headerlink" title="AppBarLayout"></a>AppBarLayout</h3><p><code>AppBarLayout</code>是实现了众多MD设计概念特性的垂直方向的<code>LinearLayout</code>，其中一个很重要的概念就是滚动手势。子View可以通过方法<code>setScrollFlags(int)</code>或者XML属性<code>app:layout_scrollFlags</code>去提供期望的滚动行为。该布局应该直接放在<code>CoordinateLayout</code>节点下，同时也需要兄弟View去决定何时滚动，但必须是<code>AppBarLayout.ScrollingViewBehavior</code>的实例。</p><h4 id="layout-scrollFlags"><a href="#layout-scrollFlags" class="headerlink" title="layout_scrollFlags"></a>layout_scrollFlags</h4><p>作为触发特定交互事件的标志，主要有四种：</p><ul><li>SCROLL_FLAG_ENTER_ALWAYS<br>这个flag让任意向下的滚动使得View可见；</li><li>SCROLL_FLAG_ENTER_ALWAYS_COLLAPSED<br>当View既设置了minHeight属性又设置了此flag，只有滚动到顶部的时候才会时View可见；</li><li>SCROLL_FLAG_EXIT_UNTIL_COLLAPSED<br>当View离开屏幕时，保持折叠的状态；</li><li>SCROLL_FLAG_SCROLL<br>View会直接离开屏幕。</li></ul><h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><ul><li>layout_scrollFlags<br>设置滚动出发事件的标志</li><li>layout_scrollInterpolator<br>设置滚动发生时的插值器</li></ul><h3 id="CollapsingToolbarLayout"><a href="#CollapsingToolbarLayout" class="headerlink" title="CollapsingToolbarLayout"></a>CollapsingToolbarLayout</h3><p><code>CollapsingToolbarLayout</code>是实现了折叠的<code>ToolBar</code>的包装，它用来设计作为<code>AppBarLayout</code>的直接子View，可以用来设置众多属性，包括折叠状态的标题、位置等。</p><ul><li>collapsedTitleGravity<br>指定折叠状态的标题如何放置，可选值:top、bottom等</li><li>collapsedTitleTextAppearance<br>指定折叠状态标题文字的样貌</li><li>contentScrim<br>指定CollapsingToolbarLayout完全被滚出到屏幕外时的ColorDrawable</li><li>expandedTitleGravity<br>指定展开状态的标题如何放置</li><li>title<br>指定标题文本</li><li>titleEnabled<br>指定是否显示标题文本</li><li>toolbarId<br>指定与之关联的ToolBar，如果未指定则默认使用第一个被发现的ToolBar子View</li><li>layout_collapseMode<br><code>COLLAPSE_MODE_OFF</code>:View表现的像没有折叠行为一样；<br><code>COLLAPSE_MODE_PARALLAX</code>：View会以视差的样式滚动；<br><code>COLLAPSE_MODE_PIN</code>：View会直到达到CollapsingToolbarLayout底部的时候固定；</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>新的UI组件：<code>Toolbar、DrawerLayout、DrawerNavigationView、SwipeRefreshLayout、RecyclerView、TabLayout、CollapsingToolbarLayout、AppBarLayout、CoordinateLayout、FloatingActionButton、SnackBar、CardView</code>;</li><li>已实现效果</li></ol><ul><li>下拉刷新</li><li>抽屉菜单导航</li><li>Tab选项卡导航</li><li>视差折叠Toolbar</li></ul><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/09/MaterialDesign设计探索使用/md_home.gif" alt="抽屉菜单和Tab布局效果图" title="">                </div>                <div class="image-caption">抽屉菜单和Tab布局效果图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/09/MaterialDesign设计探索使用/md_detail.gif" alt="视差效果图" title="">                </div>                <div class="image-caption">视差效果图</div>            </figure><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h3><ul><li><p>布局</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.SwipeRefreshLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/id_refresh"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/id_list"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.SwipeRefreshLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视图初始化设置刷新监听和适配器</span></span><br><span class="line">RecyclerView recyclerView = (RecyclerView) root.findViewById(R.id.id_list);</span><br><span class="line">        <span class="keyword">final</span> SwipeRefreshLayout swipeRefresh = (SwipeRefreshLayout) root.findViewById(R.id.id_refresh);</span><br><span class="line">        swipeRefresh.setOnRefreshListener(<span class="keyword">new</span> SwipeRefreshLayout.OnRefreshListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                adapter.data.add(<span class="number">0</span>, <span class="string">"onRefresh"</span>);</span><br><span class="line">                adapter.notifyDataSetChanged();</span><br><span class="line">                swipeRefresh.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        recyclerView.setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(getActivity()));</span><br><span class="line">        recyclerView.setHasFixedSize(<span class="keyword">true</span>);</span><br><span class="line">        recyclerView.setAdapter(adapter);</span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerViewListAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">RecyclerViewListAdapter</span>.<span class="title">MyViewHolder</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RecyclerViewListAdapter</span><span class="params">(List&lt;String&gt; data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data.clear();</span><br><span class="line">            <span class="keyword">this</span>.data.addAll(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">            View itemView = LayoutInflater.from(parent.getContext())</span><br><span class="line">                    .inflate(R.layout.item_fragment_list, parent, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyViewHolder(itemView);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(MyViewHolder holder, <span class="keyword">final</span> <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            holder.itemText.setText(data.get(position));</span><br><span class="line">            holder.rootView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                    Intent intent = <span class="keyword">new</span> Intent(v.getContext(), DetailActivity.class);</span><br><span class="line">                    intent.putExtra(<span class="string">"title"</span>, data.get(position));</span><br><span class="line">                    v.getContext().startActivity(intent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">            <span class="meta">@Bind</span>(R.id.id_item_text)</span><br><span class="line">            TextView itemText;</span><br><span class="line">            View rootView;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">MyViewHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>(itemView);</span><br><span class="line">                rootView = itemView;</span><br><span class="line">                ButterKnife.bind(<span class="keyword">this</span>, itemView);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>关于下拉刷新部分的详细实现可参考上一篇博文：<a href="https://hjw541988478.github.io/RecyclerView%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%B0%81%E8%A3%85/">RecyclerView下拉刷新上拉加载的封装</a> 。</p><h3 id="抽屉菜单导航"><a href="#抽屉菜单导航" class="headerlink" title="抽屉菜单导航"></a>抽屉菜单导航</h3><ul><li>布局<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.DrawerLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/id_drawer_layout"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.NavigationView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/id_drawer_nav_view"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"start"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:headerLayout</span>=<span class="string">"@layout/nav_header"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:menu</span>=<span class="string">"@menu/menu_drawer"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>需要注意的是，对于抽屉菜单，分为头布局和菜单两部分，头布局是layout资源，而菜单是menu资源，极大地降低了使用的难度，降低了各自的耦合度。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/09/MaterialDesign设计探索使用/md_app_drawer.png" alt="抽屉菜单分解图" title="">                </div>                <div class="image-caption">抽屉菜单分解图</div>            </figure><br><code>nav_header.xml</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"200dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"?attr/colorPrimaryDark"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">"16dp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Hi, Doge!"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"@android:color/white"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"120dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"120dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scaleType</span>=<span class="string">"centerCrop"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@mipmap/doge_head"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>menu_drawer.xml</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">android:checkableBehavior</span>=<span class="string">"single"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_dashboard"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"Home"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_forum"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"Setting"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_event"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"Like"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_headset"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"Music"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>布局中<code>android:layout_gravity=&quot;start&quot;</code>属性代表着抽屉菜单放在左边，此时通过设置抽屉菜单视图选中的监听器，可以边缘右滑和左上角的菜单图标打开抽屉，点击空白区域或者选中菜单项便可以关闭菜单。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">navView.setNavigationItemSelectedListener(<span class="keyword">new</span> NavigationView.OnNavigationItemSelectedListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNavigationItemSelected</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</span><br><span class="line">                menuItem.setCheckable(<span class="keyword">true</span>);</span><br><span class="line">                navDrawer.closeDrawers();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = item.getItemId();</span><br><span class="line">    <span class="keyword">if</span> (id == android.R.id.home) &#123;</span><br><span class="line">        navDrawer.openDrawer(GravityCompat.START);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Tab选项卡导航"><a href="#Tab选项卡导航" class="headerlink" title="Tab选项卡导航"></a>Tab选项卡导航</h3><ul><li>布局<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.CoordinatorLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Dark.ActionBar"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/id_toolbar"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"?attr/colorPrimary"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|enterAlways"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popupTheme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Light"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.design.widget.TabLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/id_tabs"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/id_pager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.FloatingActionButton</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/id_fab"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"end|bottom"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_done"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_behavior</span>=<span class="string">".QuickReturnFooterBehavior"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>布局中使用到了<code>CoordinateLayout</code>作为根节点，辅以<code>ViewPager</code>作为事件行为触发器，再通过<code>AppBarLayout</code>的嵌套，便可以实现了向下滑动自动隐藏<code>Toolbar</code>，上滑恢复显示的功能，这里<code>FloatingActionButton</code>同时也用到了一个自定义的<code>Behavior</code>，可以实现自动隐藏与出现的功能，整个过程显得协调一致。<br><code>TabLayout</code>一般是与<code>ViewPager</code>一起使用的，在<code>iewPager</code>初始化并设置了适配器后，让<code>TabLayout</code>与之联动，最后达到一致的工作的效果。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/09/MaterialDesign设计探索使用/md_app_home.png" alt="TabLayout实现效果图" title="">                </div>                <div class="image-caption">TabLayout实现效果图</div>            </figure><br>这里只实现了3个Tab栏，按照实际情况需要可以通过对<code>ViewPager</code>适配器，来控制Tab栏的标题和个数。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pager.setAdapter(new ListPagerAdapter(getSupportFragmentManager(), initData()));</span><br><span class="line">tabs.setupWithViewPager(pager);</span><br></pre></td></tr></table></figure></p><p>此外<code>TabLayout</code>还有一些其他可在布局文件自定义的属性，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Tab被选中字体的颜色--&gt;</span><br><span class="line">app:tabSelectedTextColor=@android:color/holo_blue_bright</span><br><span class="line">&lt;!--Tab未被选中字体的颜色--&gt;</span><br><span class="line">app:tabTextColor=@android:color/black</span><br><span class="line">&lt;!--Tab指示器下标的颜色--&gt;</span><br><span class="line">app:tabIndicatorColor=@android:color/holo_blue_bright</span><br></pre></td></tr></table></figure></p><h3 id="视差折叠效果视图"><a href="#视差折叠效果视图" class="headerlink" title="视差折叠效果视图"></a>视差折叠效果视图</h3><ul><li>布局<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/collapsing_toolbar"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:contentScrim</span>=<span class="string">"?attr/colorPrimary"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:expandedTitleMarginEnd</span>=<span class="string">"64dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:expandedTitleMarginStart</span>=<span class="string">"48dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|exitUntilCollapsed"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:title</span>=<span class="string">"doge"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:scaleType</span>=<span class="string">"centerCrop"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@mipmap/doge"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_collapseMode</span>=<span class="string">"parallax"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_collapseMode</span>=<span class="string">"pin"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popupTheme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Light"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><code>CollapsingToolbarLayout</code>直面意思就是可折叠的<code>Toolbar</code>布局，通过向下滚动可以使图片逐渐变大，向下滚动使得逐渐以视差效果的形式逐渐变小，最后只剩下<code>Toolbar</code>，在5.0(v21)版本上，通过Style的设置，可以让状态栏也变得透明，让图片和状态栏融为一体。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"BaseAppTheme"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowDrawsSystemBarBackgrounds"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:statusBarColor"</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/09/MaterialDesign设计探索使用/md_app_uncollapsing.png" alt="展开状态" title="">                </div>                <div class="image-caption">展开状态</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/09/MaterialDesign设计探索使用/md_app_collapsed.png" alt="折叠状态" title="">                </div>                <div class="image-caption">折叠状态</div>            </figure><p>具体实现的关键点在于对<code>layout_collapseMode、layout_scrollFlags</code>和<code>layout_behavior</code>属性的设置，具体设置模式上面有说。</p><ul><li>综合使用范例<br>Google有给出的使用范例：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.CoordinatorLayout</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">android.support.v4.widget.NestedScrollView</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- Your scrolling content --&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">android.support.v4.widget.NestedScrollView</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">             <span class="attr">...</span></span></span><br><span class="line"><span class="tag">             <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|enterAlways"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">android.support.design.widget.TabLayout</span></span></span><br><span class="line"><span class="tag">             <span class="attr">...</span></span></span><br><span class="line"><span class="tag">             <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|enterAlways"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h3><h4 id="CardView"><a href="#CardView" class="headerlink" title="CardView"></a>CardView</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.CardView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_margin</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:cardElevation</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:contentPadding</span>=<span class="string">"16dp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"这只可爱的柴犬叫Kabosu（かぼす，一种类似于日本柚子的水果，果汁很酸却有种独特的芳香，经常被用作烤鱼或生鱼片的调料）"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v7.widget.CardView</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/09/MaterialDesign设计探索使用/md_app_home_hide.png" alt="item即为卡片视图" title="">                </div>                <div class="image-caption">item即为卡片视图</div>            </figure><p><code>CardView</code>继承于<code>Framelayout</code>，所以<code>Framelayout</code>的属性都有，同时也有其它可自定义的属性，<code>app:cardElevation</code>表示在Z轴上的阴影，<code>app:contentPadding</code>表示卡片内容的内边距，<code>app:cardCornerRadius</code>表示卡片四个角的圆角矩形的程度。</p><h4 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_collapseMode</span>=<span class="string">"pin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:popupTheme</span>=<span class="string">"@style/ThemeOverlay.AppCompat.Light"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>作为未来<code>ActionBar</code>的替代品，Google为了统一MD设计的风格和AppBar的设计规范，Toolbar是为了更灵活的ActionBar而生的。通过Style设置NoActionBar，然后再代码中使用<code>setSupportedActionBar</code>方法来使用<code>Toolbar</code>替代<code>ActionBar</code>,此外还可以对其他属性，如标题，背景，LOGO等进行自定义的设置，但请记得要取得ActionBar，请使用<code>getSupportedActionBar</code>方法。</p><h4 id="FloatingActionButton"><a href="#FloatingActionButton" class="headerlink" title="FloatingActionButton"></a>FloatingActionButton</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.FloatingActionButton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_margin</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:clickable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_heart_outline_white_24dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_anchor</span>=<span class="string">"@id/appbar"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_anchorGravity</span>=<span class="string">"bottom|right|end|center_vertical"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>上面的布局代码在设置完其基本属性后，同时还配置了<code>layout_anchor</code>和<code>layout_anchorGravity</code>属性，表示固定在某个视图上，同时也确定了在视图上的位置。</p><h4 id="SnackBar"><a href="#SnackBar" class="headerlink" title="SnackBar"></a>SnackBar</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Snackbar.make(fab, <span class="string">"hey , it's SnackBar"</span>, Snackbar.LENGTH_SHORT).setAction(<span class="string">"Dismiss"</span>, <span class="keyword">null</span>).show();</span><br></pre></td></tr></table></figure><p><code>SnackBar</code>的用法与<code>Toast</code>很类似，但是它可以构造一个动作，监听动作后接受回调，执行自定义的事件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前对于MaterialDesign设计的实现，Google官方已经提供了足够多的第三方库了，而且使用起来相对灵活的自由，可以根据需求，适时使用一些新的特性，对于开发来说也减少了设计成本，能够提高开发效率和统一风格。<br>已将代码上传至Github：<a href="https://github.com/hjw541988478/materialdeisgn_tutorial" target="_blank" rel="noopener">https://github.com/hjw541988478/materialdeisgn_tutorial</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="http://design.1sters.com/" target="_blank" rel="noopener">Material Design 中文版</a></li><li><a href="http://www.google.com/design/spec/material-design/" target="_blank" rel="noopener">Material Design 原版(需FQ)</a></li><li><a href="http://www.csdn.net/article/2014-11-21/2822753-material-design-libs" target="_blank" rel="noopener">直接拿来用!十大Material Design开源项目-CSDN.NET</a></li><li><a href="http://segmentfault.com/a/1190000002888109" target="_blank" rel="noopener">Android Support Design 中 CoordinatorLayout 与 Behaviors 初探</a></li><li><a href="http://www.tuicool.com/articles/7BJBZb" target="_blank" rel="noopener">android：ToolBar详解</a></li><li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/developer/2015/0531/2958.html?mType=Group" target="_blank" rel="noopener">Android的材料设计兼容库（Design Support Library）</a></li><li>Github库</li></ol><ul><li><a href="https://github.com/navasmdc/MaterialDesignLibrary" target="_blank" rel="noopener">MaterialDesignLibrary</a></li><li><a href="https://github.com/search?l=Java&amp;q=material&amp;type=Repositories&amp;utf8=%E2%9C%93" target="_blank" rel="noopener">MaterialDesign</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android5.0之后，Google就开始推崇一门新的设计语言&lt;code&gt;MaterialDesign&lt;/code&gt;，它更加新鲜和简洁，且能够非常有效的激发应用开发者的创作热情，也能够降低开发者自主开发设计UI的难度，对于MD风格的实现，Google后续完善了下面几个库，一步步的实现MD标准的交互效果。&lt;br&gt;需要在AndroidStudio引入的库：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile &amp;apos;com.android.support:design:23.0.0&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;compile &amp;apos;com.android.support:appcompat-v7:23.0.0&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;compile &amp;apos;com.android.support:recyclerview-v7:23.0.0&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;compile &amp;apos;com.android.support:cardview-v7:23.0.0&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;新的UI组件&quot;&gt;&lt;a href=&quot;#新的UI组件&quot; class=&quot;headerlink&quot; title=&quot;新的UI组件&quot;&gt;&lt;/a&gt;新的UI组件&lt;/h2&gt;&lt;h3 id=&quot;CoordinatorLayout&quot;&gt;&lt;a href=&quot;#CoordinatorLayout&quot; class=&quot;headerlink&quot; title=&quot;CoordinatorLayout&quot;&gt;&lt;/a&gt;CoordinatorLayout&lt;/h3&gt;&lt;p&gt;&lt;code&gt;CoordinatorLayout&lt;/code&gt;在&lt;code&gt;android.support.deisgn&lt;/code&gt;中，是一种增强型的&lt;code&gt;FrameLayout&lt;/code&gt;，主要有以下两大基础性作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为顶级应用的装饰器；&lt;/li&gt;
&lt;li&gt;作为给多个子View之间进行特定交互的协调器；&lt;br&gt;通过对子&lt;code&gt;View&lt;/code&gt;的&lt;code&gt;Behavior&lt;/code&gt;的指定，可以实现子&lt;code&gt;View&lt;/code&gt;之间的通信，从而确定它们具体的交互行为。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="MaterialDesign" scheme="https://hjw541988478.github.io/tags/MaterialDesign/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView下拉刷新上拉加载的封装</title>
    <link href="https://hjw541988478.github.io/2015/09/RecyclerView%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>https://hjw541988478.github.io/2015/09/RecyclerView下拉刷新上拉加载的封装/</id>
    <published>2015-09-02T11:04:23.000Z</published>
    <updated>2018-08-18T15:44:37.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识RecyclerView"><a href="#初识RecyclerView" class="headerlink" title="初识RecyclerView"></a>初识RecyclerView</h2><blockquote><p>A flexible view for providing a limited window into a large data set.</p></blockquote><p>根据Google提供的官方说明，意思是为了解决大量数据子在有限的屏幕中显示的情况，<code>RecyclerView</code>就是应对这种情况而产生的。<code>RecyclerView</code>是supportV7包中最新的组件，有着非常高的可定制性和灵活性。使用时需要在<code>build.gradle</code>文件中配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:recyclerview-v7:22.2.1&apos;</span><br></pre></td></tr></table></figure></p><p>与<code>ListView</code>不同的是，<code>RecyclerView</code>不再负责Item布局绘制等方面的工作，转而拆分成不同的类去管理。作为未来<code>ListView、GridView</code>等替代的组件，虽然没有它们那么易用，所有的功能都需要自己重新实现，但正是因为这种特性使得<code>RecyclerView</code>更加Flexible。为了满足各种各样的需求，可能会使用到下面与<code>RecyclerView</code>相关紧密的类：<br><a id="more"></a></p><h3 id="RecyclerView-Adapter"><a href="#RecyclerView-Adapter" class="headerlink" title="RecyclerView.Adapter"></a>RecyclerView.Adapter</h3><p><code>Adapter</code>与在此前用到过的<code>BaseAdapter</code>很相似，准确的说是做了缓存优化的<code>BaseAdapter</code>，它负责为Item创建合适的视图同时为这些视图通过<code>ViewHolder</code>去绑定数据，以下3个方法是必须重写的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent,<span class="keyword">int</span> viewType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder,<span class="keyword">int</span> position)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><h3 id="RecyclerView-ViewHolder"><a href="#RecyclerView-ViewHolder" class="headerlink" title="RecyclerView.ViewHolder"></a>RecyclerView.ViewHolder</h3><p><code>ViewHolder</code>早前在<code>ListView</code>的使用时就推荐用来做性能优化，只不过在<code>RecyclerView.Adapter</code>中变成了必须实现的一部分。它保存着Item中所需要使用到的视图ID，方便在绑定数据的时候使用，使用的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewHolder</span> <span class="keyword">extends</span> <span class="title">ViewHolder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewHolder</span><span class="params">(View itemView)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(itemView);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="RecyclerView-LayoutManager"><a href="#RecyclerView-LayoutManager" class="headerlink" title="RecyclerView.LayoutManager"></a>RecyclerView.LayoutManager</h3><p><code>LayoutManager</code>是用来确定<code>RecyclerView</code>的布局方式的，目前有三种可选，分别是：</p><ul><li><code>LinearLayoutManager</code><br>线性布局，提供横向和纵向布局，实现ListView的选择</li><li><code>GridLayoutManager</code><br>表格布局，初始化时需要提供列的数目，与GridView初始化时类似</li><li><code>StaggeredGridLayoutManager</code><br>实现瀑布流效果必备，错乱的网格布局，提供横向和纵向布局<br>对于实现上拉加载的时候，也需要使用到这个类，辅助性的获取一些数据，主要方法有：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findFirstVisibleItemPosition</span><span class="params">()</span> <span class="comment">// 返回第一个可见Item在Adapter中的位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findFirstCompletelyVisibleItemPosition</span><span class="params">()</span> <span class="comment">// 返回第一个完全可见Item在Adapter中的位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLastVisibleItemPosition</span><span class="params">()</span> <span class="comment">// 返回最后一个可见Item在Adapter中的位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLastCompletelyVisibleItemPosition</span><span class="params">()</span> <span class="comment">// 返回最后一个完全可见Item在Adapter中的位置</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="RecyclerView-ItemDecoration"><a href="#RecyclerView-ItemDecoration" class="headerlink" title="RecyclerView.ItemDecoration"></a>RecyclerView.ItemDecoration</h3><p><code>ItemDecoration</code>类似<code>ListtView</code>中的<code>Divider</code>，让Item可以分隔开，但并不是必备的，在MaterialDesign设计中，推荐<code>RecyclerView</code>与<code>CardView</code>结合在一起使用，但是实际项目开发中，可以根据需要绘制<code>ItemDecoration</code>，实现不同风格的间隔线。实现自定义的<code>ItemDecoration</code>需要实现的方法有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c,RecyclerView parent,RecyclerView.State state)</span> <span class="comment">// 绘制视图</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getItemOffset</span><span class="params">(Rect outRect,<span class="keyword">int</span> itemPosition,RecyclerView parent)</span> <span class="comment">// 在绘制视图时会调用此方法计算每一个Item的合适的尺寸</span></span></span><br></pre></td></tr></table></figure></p><h3 id="RecyclerView-ItemAnimator"><a href="#RecyclerView-ItemAnimator" class="headerlink" title="RecyclerView.ItemAnimator"></a>RecyclerView.ItemAnimator</h3><p>当Item的状态改变的时候，<code>ItemAnimator</code>会根据实际情况提供不同的动画效果，主要有 </p><ul><li>Item被删除时</li><li>Item被添加时</li><li>Item被移动时<br>在未给<code>RecyclerView</code>设置<code>ItemAnimator</code>的时候，会使用默认的<code>DefaultItemAnimator</code>，以前我们都是使用<code>notifyDataSetChanged</code>方法去更新视图，现在我们可以使用带有动画效果的<code>notifyItemInserted、notifyItemRemoved</code>方法去更新视图。主要使用到的有：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notifyItemInserted</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="comment">// 插入时的动画效果</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notifyItemRemoved</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="comment">// 移除时的动画效果</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="框架封装思路"><a href="#框架封装思路" class="headerlink" title="框架封装思路"></a>框架封装思路</h2><h3 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h3><p>下拉刷新采用supportv4包中原生的下拉组件<code>SwipeRefreshlayout</code>，直接在布局文件中作为容器包裹<code>RecyclerView</code>，然后在视图初始化的时候，对组件设置<code>onRefershListener</code>，在其回调方法<code>onRefresh</code>中拦截下拉刷新事件，使用自定义的刷新监听器，根据实际情况分发刷新事件。其中使下拉刷新事件控制的相关方法有<code>setEnabled</code>和<code>setRerefreshing</code>，分别的作用是是否允许下拉刷新以及下拉刷新UI是否运行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许下拉刷新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onRefreshListener 刷新回调接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableRefresh</span><span class="params">(<span class="keyword">final</span> OnRefreshListener onRefreshListener)</span> </span>&#123;</span><br><span class="line">    swipeRefreshLayout.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">    mOnRefreshListener = <span class="keyword">new</span> SwipeRefreshLayout.OnRefreshListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (onRefreshListener != <span class="keyword">null</span>)</span><br><span class="line">                onRefreshListener.onRefresh();</span><br><span class="line">            <span class="keyword">if</span> (swipeRefreshLayout.isRefreshing())</span><br><span class="line">                swipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    swipeRefreshLayout.setOnRefreshListener(mOnRefreshListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是对刷新事件的拦截和处理过程，若是允许下拉刷新并且下拉监听器不为空，则将事件向上级传递，执行业务代码，若是刷新事件执行完毕后，将刷新组件的状态自动设置为默认状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 禁止下拉刷新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disableRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    swipeRefreshLayout.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (manager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (adapter != <span class="keyword">null</span> &amp;&amp; adapter.getItemCount() != <span class="number">0</span>)</span><br><span class="line">            manager.scrollToPosition(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若是不允许下拉刷新，直接将组件<code>setEnabled</code>为false便可，同时数据不为空的时候，讲焦点移动到第一个Item的位置。</p><h3 id="上拉加载"><a href="#上拉加载" class="headerlink" title="上拉加载"></a>上拉加载</h3><p>上拉加载的实现依赖于<code>OnScrollListener</code>，当滑动到最后一个Item的时候并且<code>RecyclerView</code>处于<code>SCROLL_STATE_IDLE</code>状态，便可以得知视图已经拉到底部，此时便触发自定义的上拉加载监听器并执行回调，同时在上拉加载完成后，若视图处于刷新状态，则将视图切换到默认状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许上拉加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onLoadMoreListener</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableLoadMore</span><span class="params">(<span class="keyword">final</span> OnLoadMoreListener onLoadMoreListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOnLoadMoreListener != <span class="keyword">null</span>)</span><br><span class="line">        recyclerView.removeOnScrollListener(mOnLoadMoreListener);</span><br><span class="line">    <span class="keyword">if</span> (adapter != <span class="keyword">null</span>)</span><br><span class="line">        adapter.setIsNeedLoadMore(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">final</span> LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();</span><br><span class="line">    mOnLoadMoreListener = <span class="keyword">new</span> RecyclerView.OnScrollListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mLastVisibleItemPosition + <span class="number">1</span> == adapter.getItemCount()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (onLoadMoreListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    onLoadMoreListener.onLoadMore();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (swipeRefreshLayout.isRefreshing())</span><br><span class="line">                    swipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrolled</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onScrolled(recyclerView, dx, dy);</span><br><span class="line">            mLastVisibleItemPosition = layoutManager.findLastVisibleItemPosition();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    recyclerView.addOnScrollListener(mOnLoadMoreListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过调用<code>enableLoadMore</code>方法，便完成了上拉加载的设置。若是上次的监听器不为空，则移除上一个<code>OnScrollListener</code>，同时设置新的监听器并在<code>Adapter</code>中切换<code>LoadMoreView</code>的状态，这样可以让最后一个Item的视图变成Loading状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 禁止上拉加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disableLoadMore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        adapter.setIsNeedLoadMore(<span class="keyword">false</span>);</span><br><span class="line">        adapter.setFooterView(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mOnLoadMoreListener != <span class="keyword">null</span>)</span><br><span class="line">        recyclerView.removeOnScrollListener(mOnLoadMoreListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若是调用禁止上拉加载方法，则直接移除上拉加载监听器，同时将<code>Adapter</code>中的<code>FooterView</code>置空以及上拉加载的标志位置false。</p><h3 id="抽象适配器"><a href="#抽象适配器" class="headerlink" title="抽象适配器"></a>抽象适配器</h3><blockquote><p>对扩展开放，对修改关闭</p></blockquote><p>由于需要对<code>HeaderView</code>以及<code>FooterView</code>处理，根据开闭原则，显然不能交给使用者自己去实现，因此我们需要封装完善，讲<code>Adapter</code>抽象，然后交由使用者继承已封装好的<code>Adpter</code>，使用者只用关心业务Item，从而更加简便灵活的使用。尽管我们不允许外部改变<code>HeaderView</code>和<code>FooterView</code>的实现逻辑，但是保留接口让使用者决定是否持有或者修改<code>FooterView</code>和<code>HeaderView</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置底部视图</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadMoreView  加载中视图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endFooterView 加载完成视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFooterView</span><span class="params">(View loadMoreView, View endFooterView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadMoreView = loadMoreView;</span><br><span class="line">    <span class="keyword">this</span>.endFooterView = endFooterView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置头部视图</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> headerView 头部视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeaderView</span><span class="params">(View headerView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.headerView = headerView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 总视图个数 = 普通Item个数 + 头视图 + 尾视图</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getAdapterItemCount() + (hasHeaderView() ? <span class="number">1</span> : <span class="number">0</span>) + (isNeedLoadMore ? hasLoadMoreFooterView() ? <span class="number">1</span> : <span class="number">0</span> : hasEndFooterView() ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据不同的类型返回不同的ViewHolder</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> viewType</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> VH <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (viewType == TYPE_LOADMORE_FOOTER) &#123;</span><br><span class="line">        <span class="keyword">return</span> (VH) <span class="keyword">new</span> RecyclerView.ViewHolder(loadMoreView) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (viewType == TYPE_END_FOOTER) &#123;</span><br><span class="line">        <span class="keyword">return</span> (VH) <span class="keyword">new</span> RecyclerView.ViewHolder(endFooterView) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (viewType == TYPE_HEADER) &#123;</span><br><span class="line">        <span class="keyword">return</span> (VH) <span class="keyword">new</span> RecyclerView.ViewHolder(headerView) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> onCreateViewHolder(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于需要根据实际情况获得的数据，我们使用抽象的方法让子类去实现，Item的数量，类型视图也是由此决定的。需要子类实现的相关方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通Item的视图交由子类去处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> VH <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通Item的视图个数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getAdapterItemCount</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><h2 id="使用方法和效果图"><a href="#使用方法和效果图" class="headerlink" title="使用方法和效果图"></a>使用方法和效果图</h2><p>在使用本框架的时候，使用者只需要在初始化View后，设置后下拉刷新、上拉加载监听器和适配器后，然后使用相关接口决定是否刷新和加载，对于整个UI效果是无需关心的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    initViews();</span><br><span class="line">    <span class="comment">// 再进行网络请求的时候，可设置Loading视图</span></span><br><span class="line">    mRecyclerView.showLoading();</span><br><span class="line">    <span class="keyword">new</span> Handler().postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            bindData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mToolBar = (Toolbar) findViewById(R.id.id_toolbar);</span><br><span class="line">    <span class="keyword">if</span> (mToolBar != <span class="keyword">null</span>)</span><br><span class="line">        setSupportActionBar(mToolBar);</span><br><span class="line">    mRecyclerView = (HarvestRecyclerView) findViewById(R.id.id_harvest_recyclerview);</span><br><span class="line">    manager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">    mRecyclerView.setHasFixedSize(<span class="keyword">true</span>);</span><br><span class="line">    mRecyclerView.setLayoutManager(manager);</span><br><span class="line">    mRecyclerView.setEmptyView(getResources().getDrawable(R.drawable.ic_results_empty), <span class="string">"No data Here."</span>, <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            adapter.data.add(<span class="string">"onRefresh"</span> + refreshNum++);</span><br><span class="line">            adapter.notifyDataSetChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    onRefreshListener = <span class="keyword">new</span> HarvestRecyclerView.OnRefreshListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (refreshNum &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">                adapter.data.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                adapter.data.add(<span class="number">0</span>, <span class="string">"onRefresh"</span> + refreshNum++);</span><br><span class="line">            adapter.notifyDataSetChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    onLoadMoreListener = <span class="keyword">new</span> HarvestRecyclerView.OnLoadMoreListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadMore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (loadMoreNum &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">                mRecyclerView.setLoadMoreEnabled(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                adapter.data.add(<span class="string">"onLoadMore"</span> + loadMoreNum++);</span><br><span class="line">            adapter.notifyDataSetChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继承<code>HarvestRecyclerViewAdpter</code>，实现相关抽象的方法以及业务所需要的相关功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TestHarvHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent)</span> </span>&#123;</span><br><span class="line">    View root = LayoutInflater.from(parent.getContext())</span><br><span class="line">            .inflate(R.layout.item_view_card, parent, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TestHarvHolder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAdapterItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (holder <span class="keyword">instanceof</span> TestHarvHolder) &#123;</span><br><span class="line">        ((TestHarvHolder) holder).mContentText.setText(data.get(position));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarvHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">    TextView mContentText;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestHarvHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(itemView);</span><br><span class="line">        mContentText = (TextView) itemView.findViewById(R.id.id_text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果图如下面所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/09/RecyclerView下拉刷新上拉加载的封装/recycler_menu_view.png" alt="demo" title="">                </div>                <div class="image-caption">demo</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/09/RecyclerView下拉刷新上拉加载的封装/recycler_refresh_view.png" alt="refresh" title="">                </div>                <div class="image-caption">refresh</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/09/RecyclerView下拉刷新上拉加载的封装/recycler_loadmore_view.png" alt="loadmore" title="">                </div>                <div class="image-caption">loadmore</div>            </figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于下拉刷新和上拉加载框架的封装，主要是异常情况的处理，有无<code>HeaderView</code>，有无<code>FooterView</code>等，以及刷新和加载事件的拦截，以及对于相关设计模式的理解与运用。<br>Github地址：<a href="https://github.com/hjw541988478/RefreshLoadMoreRecyclerView" target="_blank" rel="noopener">https://github.com/hjw541988478/RefreshLoadMoreRecyclerView</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.cnblogs.com/littlepanpc/p/4241575.html?utm_source=tuicool" target="_blank" rel="noopener">关于RecyclerView中Viewholder和View的缓存机制的探究</a></li><li><a href="http://www.grokkingandroid.com/first-glance-androids-recyclerview/" target="_blank" rel="noopener">first-glance-androids-recyclerview</a></li><li><a href="http://www.cnblogs.com/tiantianbyconan/p/4242541.html" target="_blank" rel="noopener">[Android]使用RecyclerView替代ListView（二）</a></li><li>相关Github开源项目<br><a href="https://github.com/Malinskiy/SuperRecyclerView" target="_blank" rel="noopener">SuperRecyclerView</a><br><a href="https://github.com/cymcsg/UltimateRecyclerView" target="_blank" rel="noopener">UltimateRecyclerView</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;初识RecyclerView&quot;&gt;&lt;a href=&quot;#初识RecyclerView&quot; class=&quot;headerlink&quot; title=&quot;初识RecyclerView&quot;&gt;&lt;/a&gt;初识RecyclerView&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;A flexible view for providing a limited window into a large data set.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据Google提供的官方说明，意思是为了解决大量数据子在有限的屏幕中显示的情况，&lt;code&gt;RecyclerView&lt;/code&gt;就是应对这种情况而产生的。&lt;code&gt;RecyclerView&lt;/code&gt;是supportV7包中最新的组件，有着非常高的可定制性和灵活性。使用时需要在&lt;code&gt;build.gradle&lt;/code&gt;文件中配置：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile &amp;apos;com.android.support:recyclerview-v7:22.2.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;ListView&lt;/code&gt;不同的是，&lt;code&gt;RecyclerView&lt;/code&gt;不再负责Item布局绘制等方面的工作，转而拆分成不同的类去管理。作为未来&lt;code&gt;ListView、GridView&lt;/code&gt;等替代的组件，虽然没有它们那么易用，所有的功能都需要自己重新实现，但正是因为这种特性使得&lt;code&gt;RecyclerView&lt;/code&gt;更加Flexible。为了满足各种各样的需求，可能会使用到下面与&lt;code&gt;RecyclerView&lt;/code&gt;相关紧密的类：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="RecyclerView" scheme="https://hjw541988478.github.io/tags/RecyclerView/"/>
    
      <category term="CustomView" scheme="https://hjw541988478.github.io/tags/CustomView/"/>
    
  </entry>
  
  <entry>
    <title>Android传感器编程之摇一摇</title>
    <link href="https://hjw541988478.github.io/2015/08/Android%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%91%87%E4%B8%80%E6%91%87/"/>
    <id>https://hjw541988478.github.io/2015/08/Android传感器编程之摇一摇/</id>
    <published>2015-08-26T11:54:01.000Z</published>
    <updated>2018-08-17T15:30:43.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>摇一摇功能目前在很多Android的应用都有用到，大多数的目的是增强与用户的交互，同时也增加了趣味性。本质上来看，通过对加速传感器感知手机在X轴、Y轴和Z轴上加速度的变化，在三者的值达到设定的阈值的时候，便触发事件，进行业务上的逻辑调用，同时使用振动传感器产生振动事件。<br>对于加速度传感器和振动传感器的使用，需要预先在配置文件中声明权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.hardware.sensor.accelerometer&quot; /&gt; # 加速度传感器</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt;  # 振动传感器</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>同时在应用初始化的时候，获取<code>SensorManager</code>和<code>Vibrator</code>,之后才可以使用振动传感器和加速度传感器进行其他操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SensorManager mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);  </span><br><span class="line">Vibrator mVibrator = (Vibrator) getSystemService(Service.VIBRATOR_SERVICE);</span><br></pre></td></tr></table></figure></p><h2 id="摇晃监听器的实现"><a href="#摇晃监听器的实现" class="headerlink" title="摇晃监听器的实现"></a>摇晃监听器的实现</h2><ul><li>摇晃监听器:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShakeOffListener</span> <span class="keyword">implements</span> <span class="title">SensorEventListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="keyword">private</span> Vibrator mVibrator;</span><br><span class="line">    <span class="keyword">private</span> SensorManager mSensorManager;</span><br><span class="line">    <span class="keyword">private</span> OnShakeListener mListener;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">OnShakeListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onShake</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShakeListener</span><span class="params">(OnShakeListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShakeOffListener</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        mVibrator = (Vibrator) context.</span><br><span class="line">                getSystemService(Context.VIBRATOR_SERVICE);</span><br><span class="line">        mSensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mSensorManager.registerListener(<span class="keyword">this</span>,</span><br><span class="line">                mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER),</span><br><span class="line">                SensorManager.SENSOR_DELAY_NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mVibrator.vibrate(<span class="number">300</span>);</span><br><span class="line">        mSensorManager.unregisterListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传感器值变化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSensorChanged</span><span class="params">(SensorEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> x = event.values[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">float</span> y = event.values[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">float</span> z = event.values[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 达到速度阀值，发出提示</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(x) &gt;= <span class="number">19</span> || Math.abs(y) &gt;= <span class="number">19</span> || Math.abs(z) &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mListener != <span class="keyword">null</span>)</span><br><span class="line">                mListener.onShake();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传感器反应速度值的变化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAccuracyChanged</span><span class="params">(Sensor sensor, <span class="keyword">int</span> accuracy)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在对<code>ShakeOffListener</code>进行初始化时，首先会对传感器进行初始化，同时也在内部定义了<code>OnShakeListener</code>接口，方便在宿主类对事件触发的监听，然后通过对<code>SensorEventListener</code>接口的实现，重新实现了<code>onSensorChanged</code>的回调方法，这里主要完成是对于摇晃功能阈值的设定以及触发条件满足后将事件传给宿主类完成其他操作，同时也定义了<code>resume</code>和<code>pause</code>方法，用来完成摇晃过程的恢复和暂停事件的处理，这样可以更加方便处理摇晃开始、摇晃中和摇晃结束整个流程。</p><h2 id="摇晃监听器的使用及其效果"><a href="#摇晃监听器的使用及其效果" class="headerlink" title="摇晃监听器的使用及其效果"></a>摇晃监听器的使用及其效果</h2><ul><li>在Activity中进行使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ImageView shkePic;</span><br><span class="line">    <span class="keyword">private</span> ShakeOffListener mShakeOffListener;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_test);</span><br><span class="line">        shkePic = (ImageView) findViewById(R.id.id_hand_shake_off);</span><br><span class="line">        mShakeOffListener = <span class="keyword">new</span> ShakeOffListener(<span class="keyword">this</span>);</span><br><span class="line">        mShakeOffListener.setShakeListener(<span class="keyword">new</span> ShakeOffListener.OnShakeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//TODO 处理业务请求</span></span><br><span class="line">                Logger.d(<span class="string">"onShake~"</span>);</span><br><span class="line">                Animation shakeAnim = AnimationUtils.loadAnimation(TestActivity.<span class="keyword">this</span>, R.anim.shake);</span><br><span class="line">                shakeAnim.setAnimationListener(<span class="keyword">new</span> Animation.AnimationListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">                        mShakeOffListener.pause();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">                        mShakeOffListener.resume();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                shkePic.startAnimation(shakeAnim);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mShakeOffListener.resume();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="keyword">if</span> (mShakeOffListener != <span class="keyword">null</span>)&#123;</span><br><span class="line">            mShakeOffListener.pause();</span><br><span class="line">            mShakeOffListener = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在<code>TestActivity</code>中，通过在<code>onCreate</code>方法中，初始化<code>ShakeOffListener</code>同时实现了自定义的摇晃事件接口，巧妙的利用<code>Animation</code>的执行流程的回调方法，防止了摇晃事件的重复触发，摇晃事件的间隔取决于动画的时长，只需要在动画开始和结束使用<code>pause</code>和<code>resume</code>方法便可以暂停和恢复对摇晃事件的监听。最后在<code>Activity</code>被销毁时会回调的<code>onDestroy</code>方法中解除对摇晃监听器的注册，防了止内存泄露。<br>用到的<code>Animation</code>摇晃动画资源文件<code>shake.xml</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">translate</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"500"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromXDelta</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">"@anim/cycle_7"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toXDelta</span>=<span class="string">"50"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>以及使用到的插值器<code>cycle_7.xml</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cycleInterpolator</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:cycles</span>=<span class="string">"5.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>还有在对传感器进行注册的时候，第一个参数是加速度传感器监听器实例，本例中是实现了<code>SensorEventListener</code>接口了的，第二个是加速度传感器实例，实现摇晃功能需要<code>Sensor.TYPE_ACCELEROMETER</code>类型，最后一个参数代表着传感器反应的速度类型，这个有如下几类：</p><ul><li><code>SENSOR_DELAY_NORMAL</code>：默认的获取传感器数据的速度；</li><li><code>SENSOR_DELAY_UI</code>：若使用传感器更新UI，推荐使用；</li><li><code>SENSOR_DELAY_GAME</code>：如果利用传感器开发游戏，建议使用；</li><li><code>SENSOR_DELAY_FASTEST</code>：在特别灵敏的处理下推荐使用，但该模式可能造成手机电力大量消耗；<br>对于摇晃功能的实现，也只需要使用默认的即<code>SENSOR_DELAY_NORMAL</code>便可以满足监听传感器加速度变化的需求：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mSensorManager.registerListener(<span class="keyword">this</span>,</span><br><span class="line">                mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER),</span><br><span class="line">                SensorManager.SENSOR_DELAY_NORMAL);</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/08/Android传感器编程之摇一摇/screenshot_before_shake.png" alt="摇晃前截图" title="">                </div>                <div class="image-caption">摇晃前截图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/08/Android传感器编程之摇一摇/screenshot_after_shake.png" alt="摇晃成功截图" title="">                </div>                <div class="image-caption">摇晃成功截图</div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>摇一摇功能用到的知识点有传感器、动画以及利用动画的执行周期巧妙的实现业务需求，但不得不说的是，对于合理设定摇晃阈值才是整个摇晃功能实现的关键，目前这个版本设定的值是19,对于大多数手机是能够实现功能的，但是相信有更好方法利用X、Y、Z轴加速度的值去处理这个阈值，这个是待完善的地方。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;摇一摇功能目前在很多Android的应用都有用到，大多数的目的是增强与用户的交互，同时也增加了趣味性。本质上来看，通过对加速传感器感知手机在X轴、Y轴和Z轴上加速度的变化，在三者的值达到设定的阈值的时候，便触发事件，进行业务上的逻辑调用，同时使用振动传感器产生振动事件。&lt;br&gt;对于加速度传感器和振动传感器的使用，需要预先在配置文件中声明权限：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;uses-permission android:name=&amp;quot;android.hardware.sensor.accelerometer&amp;quot; /&amp;gt; # 加速度传感器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;uses-permission android:name=&amp;quot;android.permission.VIBRATE&amp;quot;/&amp;gt;  # 振动传感器&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="Sensor" scheme="https://hjw541988478.github.io/tags/Sensor/"/>
    
      <category term="Vibrator" scheme="https://hjw541988478.github.io/tags/Vibrator/"/>
    
  </entry>
  
  <entry>
    <title>Android应用自动检测更新机制的实现</title>
    <link href="https://hjw541988478.github.io/2015/08/Android%E5%BA%94%E7%94%A8%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://hjw541988478.github.io/2015/08/Android应用自动检测更新机制的实现/</id>
    <published>2015-08-25T12:42:39.000Z</published>
    <updated>2018-08-17T15:31:23.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在安卓应用程序中，随着业务的升级或者BUG的修复，往往需要进行版本的迭代与更新。在更新的过程中，选择合理的更新方式显得尤为重要。但大多数思路都是一样，从服务端获取版本号比对当前包的版本号，如果大于当前版本号则提示用户升级，而对于某些需要强制更新的版本号，则不允许用户取消版本的升级，必须强制更新。整个流程大概如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/08/Android应用自动检测更新机制的实现/app_update_flowchart.png" alt="更新流程图" title="">                </div>                <div class="image-caption">更新流程图</div>            </figure><br>可以看到，整个流程的关键在于对VerisonCode版本号的大小比较，VersionCode标识了同一应用的不同版本号，对于修改版本号后打包的安装包便是最新版本的安装包。在AndroidStudio中，VersionCode的配置一般在应用模块的<code>*.build</code>文件中，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    applicationId &quot;com.test.app&quot;</span><br><span class="line">    minSdkVersion 9</span><br><span class="line">    targetSdkVersion 22</span><br><span class="line">    versionCode 6 #这里便是对版本号的设置</span><br><span class="line">    versionName &quot;2.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>对于本地版本号的获取，使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curCode = mActivity.getPackageManager().getPackageInfo(mActivity.getPackageName(), <span class="number">0</span>).versionCode;</span><br></pre></td></tr></table></figure></p><p>便可以获取，然后直接去比较从服务端获取下来的版本号，便可以知晓应用是否需要更新。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>使用<code>Service</code>组件去完成整个功能，鉴于它有着不可见，运行在后台的特性，并使用本地服务，直接<code>startService</code>或者<code>stopService</code>便可以完成服务的启动和停止，整个流程分为3个部分，服务端获取最新版本信息-&gt;下载最新版本，并实时更新UI-&gt;下载完成，覆盖安装。</p><ul><li>服务端获取最新版本<br>通过服务端提供的API或者第三方SDK提供的API实现，在自定义的<code>Application</code>中，应用启动时便异步发起检测更新的请求，这样应用每次启动都能知晓是否需要更新。对于异步请求，可以使用<code>OkHttp、AsyncHttp</code>等知名的第三方库，同时也可以使用<code>AsyncTask</code>类去实现，当然，视项目的网络请求框架而定，直接复用网络框架中的请求即可。</li><li>下载最新版本，更新进度条<br>在获取到服务端返回的结果中，解析最新版本安装包的下载地址URL链接，同时使用<code>NotificationManager</code>去唤起一个新的<code>Notification</code>，对于有进度条需求的，便需要使用自定义的UI，在<code>Notification</code>中获取到视图的ID和引用，这样便可以适时的去更新UI。对于UI更新机制，推荐使用主UI线程的<code>Handler</code>去维护管理消息队列，在下载线程中只需要使用<code>sendMessage</code>方法将相关数据带过去，让<code>Handler</code>去实现具体的UI更新内容。需要注意的时，对于更新频率的控制，在复用<code>Notification</code>时候，更新频率过高的时候，会占用大量内存，可能会引起UI线程的阻塞，从而影响用户体验。</li><li>下载完成，覆盖安装<br>如何监听下载完成的事件呢?其实可以有两种方式实现，即<code>BroadcastReceiver</code>或者<code>EventBus</code>，但无论哪种方式，下载完成的关键便是网络数据已经完全请求完成，也就是下载进度达到了100%。而覆盖安装的关键在于<code>Intent</code>的<code>Flags</code>和<code>DataAndType</code>的设置，根据之前设定好的下载文件的路径，并可以发起调用覆盖安装的请求。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>UpdateService实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 安装包下载地址</span></span><br><span class="line">    <span class="keyword">private</span> String url = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 新的安装包本地存储路径</span></span><br><span class="line">    <span class="keyword">private</span> String filePath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 通知管理器</span></span><br><span class="line">    <span class="keyword">private</span> NotificationManager updateNotificationManager = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 通知</span></span><br><span class="line">    <span class="keyword">private</span> Notification updateNotification = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取传值</span></span><br><span class="line">        url = intent.getStringExtra(<span class="string">"url"</span>);</span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String fileName = url.substring(url.lastIndexOf(<span class="string">"/"</span>));</span><br><span class="line">            File uDir = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory() + <span class="string">"/test/download/"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!uDir.exists() || !uDir.isDirectory()) &#123;</span><br><span class="line">                uDir.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 本地目录存储路径</span></span><br><span class="line">            filePath = uDir + fileName;</span><br><span class="line">            <span class="comment">// 使用AsyncTask执行下载请求</span></span><br><span class="line">            <span class="keyword">new</span> DownloadAsyncTask().execute(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>UpdateService</code>先会把本地存储路径和<code>Notification</code>初始化，然后使用<code>AsyncTask</code>进行新安装包的下载和<code>NotificationUI</code>的更新工作。记得在使用<code>Service</code>前进行动态注册或者在<code>AndroidManifest.xml</code>文件中配置好<code>Service</code>节点。</p><ul><li><code>DownloadAsyncTask</code>实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//构造Notification</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            updateNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">            updateNotification = <span class="keyword">new</span> Notification();</span><br><span class="line">            updateNotification.icon = R.drawable.ic_launcher;</span><br><span class="line">            updateNotification.contentView = <span class="keyword">new</span> RemoteViews(getPackageName(), R.layout.view_notification_download);</span><br><span class="line">            updateNotification.contentView.setProgressBar(R.id.notify_progress, <span class="number">100</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">            updateNotification.contentView.setTextViewText(R.id.notify_title, <span class="string">"已下载:0%"</span>);</span><br><span class="line">            updateNotification.contentIntent = PendingIntent.getActivity(getApplicationContext(), <span class="number">0</span>, <span class="keyword">new</span> Intent(), <span class="number">0</span>);</span><br><span class="line">            updateNotification.flags = Notification.FLAG_AUTO_CANCEL;</span><br><span class="line">            updateNotificationManager.notify(<span class="number">101</span>, updateNotification);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 下载百分比</span></span><br><span class="line">            <span class="keyword">int</span> downPercentage = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 上次缓存文件大小</span></span><br><span class="line">            <span class="keyword">int</span> cachedSize = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 临时文件大小</span></span><br><span class="line">            <span class="keyword">long</span> tmpTotalSize = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 待下载文件总大小</span></span><br><span class="line">            <span class="keyword">int</span> totalSize = <span class="number">0</span>;</span><br><span class="line">            HttpURLConnection httpUrlConn = <span class="keyword">null</span>;</span><br><span class="line">            InputStream httpInputStream = <span class="keyword">null</span>;</span><br><span class="line">            FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                URL url = <span class="keyword">new</span> URL(params[<span class="number">0</span>]);</span><br><span class="line">                httpUrlConn = (HttpURLConnection) url.openConnection();</span><br><span class="line">                <span class="keyword">if</span> (cachedSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 方便以后实现断点续传</span></span><br><span class="line">                    httpUrlConn.setRequestProperty(<span class="string">"RANGE"</span>, <span class="string">"bytes="</span> + cachedSize + <span class="string">"-"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                httpUrlConn.setConnectTimeout(NetworkConfig.CONNECT_TIMEOUT);</span><br><span class="line">                httpUrlConn.setReadTimeout(NetworkConfig.CONNECT_TIMEOUT);</span><br><span class="line">                <span class="comment">// 获取文件总大小</span></span><br><span class="line">                totalSize = httpUrlConn.getContentLength();</span><br><span class="line">                <span class="keyword">if</span> (httpUrlConn.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">                    httpInputStream = httpUrlConn.getInputStream();</span><br><span class="line">                    fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(filePath));</span><br><span class="line">                    <span class="keyword">byte</span> buffer[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">                    <span class="keyword">int</span> bufferSize = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((bufferSize = httpInputStream.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        fileOutputStream.write(buffer, <span class="number">0</span>, bufferSize);</span><br><span class="line">                        tmpTotalSize += bufferSize;</span><br><span class="line">                        <span class="keyword">int</span> tmpDownPercentage = (<span class="keyword">int</span>) (tmpTotalSize * <span class="number">100</span> / totalSize);</span><br><span class="line">                        <span class="keyword">if</span> (tmpDownPercentage - downPercentage &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                            downPercentage += <span class="number">5</span>;</span><br><span class="line">                            publishProgress(tmpDownPercentage);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 下载结束</span></span><br><span class="line">                    publishProgress(<span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                publishProgress(-<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (httpUrlConn != <span class="keyword">null</span>)</span><br><span class="line">                        httpUrlConn.disconnect();</span><br><span class="line">                    <span class="keyword">if</span> (httpInputStream != <span class="keyword">null</span>)</span><br><span class="line">                        httpInputStream.close();</span><br><span class="line">                    <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>)</span><br><span class="line">                        fileOutputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    publishProgress(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (values[<span class="number">0</span>] != -<span class="number">1</span>) &#123;</span><br><span class="line">                updateNotification.contentView.setTextViewText(R.id.notify_title, values[<span class="number">0</span>] &gt;= <span class="number">100</span> ? <span class="string">"已完成下载"</span> : <span class="string">"已下载:"</span> + values[<span class="number">0</span>] + <span class="string">"%"</span>);</span><br><span class="line">                updateNotification.contentView.setProgressBar(R.id.notify_progress, <span class="number">100</span>, values[<span class="number">0</span>] &gt;= <span class="number">100</span> ? <span class="number">100</span> : values[<span class="number">0</span>], <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                updateNotification.contentView.setTextViewText(R.id.notify_title, <span class="string">"下载失败!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            updateNotification.flags = Notification.FLAG_AUTO_CANCEL;</span><br><span class="line">            updateNotificationManager.notify(<span class="number">101</span>, updateNotification);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Void result)</span> </span>&#123;</span><br><span class="line">            Intent installIntent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">            installIntent.addFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            installIntent.setDataAndType(Uri.fromFile(<span class="keyword">new</span> File(filePath)), <span class="string">"application/vnd.android.package-archive"</span>);</span><br><span class="line">            startActivity(installIntent);</span><br><span class="line">            stopSelf();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>DownloadAsyncTask</code>充分利用了<code>AsyncTask</code>的特点，分别在<code>onPreExecute</code>中进行了<code>Notification</code>的构造以及唤醒工作，在<code>doInBackground</code>中进行着网络数据下载工作，然后在数据不断缓存的过程中，当数据缓存的比例大于5%时，则调用<code>publishProgress</code>方法，更新<code>Notification</code>中的进度条，这样做的目的是，在频繁更新<code>Notification</code>并唤醒的过程中，会阻塞UI线程导致ANR，因此一般在进度变化累积到5%的时候再去更新UI，保证应用的流畅性。具体涉及到UI的更新工作放在<code>onProgressUpdate</code>方法中，包括进度和文字提示的更新，其中包含了更新失败的情况，同样也需要提示。最后在<code>onPostExecute</code>方法中进行下载文件的获取和安装，并弹出安装界面指导安装。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/08/Android应用自动检测更新机制的实现/shot_downloading.png" alt="下载中状态" title="">                </div>                <div class="image-caption">下载中状态</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/08/Android应用自动检测更新机制的实现/shot_download_completed.png" alt="下载完成状态" title="">                </div>                <div class="image-caption">下载完成状态</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/08/Android应用自动检测更新机制的实现/shot_update_dialog.png" alt="安装状态" title="">                </div>                <div class="image-caption">安装状态</div>            </figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Andriod应用的更新机制主要使用到的知识点有<code>NotificationManager、Notification、ProgressBar、Service、AsyncTask</code>。通过对上面主要的分析与实现，可以看到涉及到的点还是比较多的，但大多都是基础的知识点，以后在实现复杂功能的时候，也应该通过对业务流程的分析、知识点的理解，综合运用，达到目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;在安卓应用程序中，随着业务的升级或者BUG的修复，往往需要进行版本的迭代与更新。在更新的过程中，选择合理的更新方式显得尤为重要。但大多数思路都是一样，从服务端获取版本号比对当前包的版本号，如果大于当前版本号则提示用户升级，而对于某些需要强制更新的版本号，则不允许用户取消版本的升级，必须强制更新。整个流程大概如下图所示：&lt;br&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;/2015/08/Android应用自动检测更新机制的实现/app_update_flowchart.png&quot; alt=&quot;更新流程图&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;更新流程图&lt;/div&gt;
            &lt;/figure&gt;&lt;br&gt;可以看到，整个流程的关键在于对VerisonCode版本号的大小比较，VersionCode标识了同一应用的不同版本号，对于修改版本号后打包的安装包便是最新版本的安装包。在AndroidStudio中，VersionCode的配置一般在应用模块的&lt;code&gt;*.build&lt;/code&gt;文件中，如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;defaultConfig &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    applicationId &amp;quot;com.test.app&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    minSdkVersion 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    targetSdkVersion 22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    versionCode 6 #这里便是对版本号的设置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    versionName &amp;quot;2.0.0&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="Service" scheme="https://hjw541988478.github.io/tags/Service/"/>
    
      <category term="Handler" scheme="https://hjw541988478.github.io/tags/Handler/"/>
    
      <category term="Notification" scheme="https://hjw541988478.github.io/tags/Notification/"/>
    
  </entry>
  
  <entry>
    <title>PropertyAnimation使用总结</title>
    <link href="https://hjw541988478.github.io/2015/08/PropertyAnimation%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://hjw541988478.github.io/2015/08/PropertyAnimation使用总结/</id>
    <published>2015-08-24T11:27:14.000Z</published>
    <updated>2018-08-17T15:31:06.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h2><ul><li>淡入效果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(tv, <span class="string">"alpha"</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span><br><span class="line">            .setDuration(<span class="number">500</span>)</span><br><span class="line">            .start();</span><br></pre></td></tr></table></figure></li></ul><p><code>ofFloat</code>对应着三个参数值，分别是目标<code>View</code>，动画属性名<code>Property</code>，以及属性值，一个则为终点值，两个对应着起点和终点值，多个则为起点值，将会调用的值和终点值。与<code>ofFloat</code>类似的还有<code>ofInt</code>、<code>ofObject</code>，这些都是用来设置动画动作的元素。<br><a id="more"></a></p><ul><li>同时缩小和淡出效果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator anim = ObjectAnimator</span><br><span class="line">            .ofFloat(view, <span class="string">"hjw"</span>, <span class="number">1.0F</span>,  <span class="number">0.0F</span>)  </span><br><span class="line">            .setDuration(<span class="number">500</span>);  </span><br><span class="line">    anim.start();  </span><br><span class="line">    anim.addUpdateListener(<span class="keyword">new</span> AnimatorUpdateListener()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">float</span> cVal = (Float) animation.getAnimatedValue();  </span><br><span class="line">            view.setAlpha(cVal);  </span><br><span class="line">            view.setScaleX(cVal);  </span><br><span class="line">            view.setScaleY(cVal);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>可以看到，使用这种非常规的方式也可以达到预期的效果，只需要在使用了未知的<code>Property</code>，然后再回调方法中按照时间插值和持续时间计算值，我们自己手动调用实现各个属性的值。</p><h2 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h2><ul><li>抛物线运动效果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator animator = <span class="keyword">new</span> ValueAnimator();</span><br><span class="line">        animator.setDuration(<span class="number">3000</span>);</span><br><span class="line">        animator.setObjectValues(<span class="keyword">new</span> PointF(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        animator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line">        animator.setEvaluator(<span class="keyword">new</span> TypeEvaluator&lt;PointF&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> PointF <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, PointF startValue, PointF endValue)</span> </span>&#123;</span><br><span class="line">                PointF pointF = <span class="keyword">new</span> PointF();</span><br><span class="line">                pointF.x = <span class="number">100</span> * fraction;</span><br><span class="line">                pointF.y = <span class="number">0.5f</span> * (fraction * <span class="number">100</span>) * (fraction * <span class="number">100</span>);</span><br><span class="line">                <span class="keyword">return</span> pointF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        animator.start();</span><br><span class="line">        animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">                PointF point = (PointF) animation.getAnimatedValue();</span><br><span class="line">                circleView.setX(point.x);</span><br><span class="line">                circleView.setY(point.y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>可以看到与<code>ObjectAnimator</code>相比，并没有指定<code>Property</code>的操作，也就是说，<code>ValueAnimator</code>只关心值的变化，但是带来的变化是只需要根据计算好的动画值，重写<code>TypeEvaluator</code>类，在<code>evaluate</code>回调方法中返回任何想要调用的值，类似上面那种非常规的方式，也无需使用到反射。</p><h2 id="AnimationSet"><a href="#AnimationSet" class="headerlink" title="AnimationSet"></a>AnimationSet</h2><ul><li>淡入淡出效果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator alphaOutAnim = <span class="keyword">new</span> ObjectAnimator();</span><br><span class="line">   alphaOutAnim.ofFloat(tv, <span class="string">"alpha"</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">   ObjectAnimator alphaInAnim = <span class="keyword">new</span> ObjectAnimator();</span><br><span class="line">   alphaInAnim.ofFloat(tv, <span class="string">"alpha"</span>, <span class="number">1f</span>, <span class="number">0f</span>);</span><br><span class="line">   AnimatorSet animatorSet = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">   animatorSet.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line">   animatorSet.setDuration(<span class="number">2000</span>);</span><br><span class="line">   animatorSet.playSequentially(alphaOutAnim, alphaInAnim);</span><br><span class="line">   animatorSet.start();</span><br></pre></td></tr></table></figure></li></ul><p><code>AnimationSet</code>主要是用来对多动画的执行顺序进行控制，包括<code>playTogether</code>同时执行、<code>playSequentially</code>顺序执行和<code>after with before</code>等方法控制。</p><h2 id="监听动画变化事件"><a href="#监听动画变化事件" class="headerlink" title="监听动画变化事件"></a>监听动画变化事件</h2><ul><li>监听动画事件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(tv, <span class="string">"alpha"</span>, <span class="number">0.5f</span>);</span><br><span class="line">        anim.addListener(<span class="keyword">new</span> AnimatorListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 动画开始执行</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 动画重复执行</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 动画执行结束</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 取消动画执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        anim.start();</span><br></pre></td></tr></table></figure></li></ul><p>对于常用的开始、重复、结束和取消动画事件都能够被监听到，只需要在回调方法中实现所需要实现的业务即可。</p><h2 id="XML创建PropertyAnimation"><a href="#XML创建PropertyAnimation" class="headerlink" title="XML创建PropertyAnimation"></a>XML创建PropertyAnimation</h2><ul><li>XML方式描述淡出效果<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:propertyName</span>=<span class="string">"alpha"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueFrom</span>=<span class="string">"0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueTo</span>=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueType</span>=<span class="string">"floatType"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectAnimator</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>在<code>res/animator</code>目录下创建<code>alpha.xml</code>文件，然后进行调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animator anim = AnimatorInflater.loadAnimator(this, R.animator.alpha);  </span><br><span class="line">anim.setTarget(mMv);  </span><br><span class="line">anim.start()</span><br></pre></td></tr></table></figure></p><p>如果需要多个动画去执行，只需要在XML文件中增加<code>Set</code>节点：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:ordering</span>=<span class="string">"together"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:propertyName</span>=<span class="string">"scaleX"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueFrom</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"0.5"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">objectAnimator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:propertyName</span>=<span class="string">"scaleY"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueFrom</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"0.5"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">objectAnimator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>通过改变<code>ordering</code>属性的值去控制多个动画之间的执行顺序。</p><h2 id="Layout-Animations-布局动画"><a href="#Layout-Animations-布局动画" class="headerlink" title="Layout Animations(布局动画)"></a>Layout Animations(布局动画)</h2><p>改变<code>ViewGroup</code>的子<code>View</code>移除或者添加的动画效果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LayoutTransition transition = <span class="keyword">new</span> LayoutTransition();</span><br><span class="line">    transition.setAnimator(LayoutTransition.CHANGE_APPEARING,</span><br><span class="line">transition.getAnimator(LayoutTransition.CHANGE_APPEARING));</span><br><span class="line">transition.setAnimator(LayoutTransition.APPEARING,</span><br><span class="line"><span class="keyword">null</span>);</span><br><span class="line">transition.setAnimator(LayoutTransition.DISAPPEARING,</span><br><span class="line"><span class="keyword">null</span>);</span><br><span class="line">transition.setAnimator(LayoutTransition.CHANGE_DISAPPEARING,</span><br><span class="line"><span class="keyword">null</span>);</span><br><span class="line">mLayout.setLayoutTransition(transition);</span><br></pre></td></tr></table></figure></p><p>需要注意的四种类型：</p><ul><li><code>LayoutTransition.APPEARING</code>：当一个<code>View</code>在<code>ViewGroup</code>中出现时，对此<code>View</code>设置的动画；</li><li><code>LayoutTransition.CHANGE_APPEARING</code>： 当一个<code>View</code>在<code>ViewGroup</code>中出现时，此<code>View</code>对其他<code>View</code>位置造成的效果，对其他<code>View</code>设置的动画；</li><li><code>LayoutTransition.DISAPPEARING</code>：当一个<code>View</code>在<code>ViewGroup</code>中消失时，对此<code>View</code>设置的动画；</li><li><code>LayoutTransition.CHANGE_DISAPPEARING</code>：当一个<code>View</code>在<code>ViewGroup</code>中消失时，此<code>View</code>对其他<code>View</code>位置造成效果，对其他<code>View</code>设置的动画；</li><li><code>LayoutTransition.CHANGE</code>：不是由于<code>View</code>出现或消失造成对其他<code>View</code>位置造成效果，对其他<code>View</code>设置的动画。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ObjectAnimator&quot;&gt;&lt;a href=&quot;#ObjectAnimator&quot; class=&quot;headerlink&quot; title=&quot;ObjectAnimator&quot;&gt;&lt;/a&gt;ObjectAnimator&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;淡入效果&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ObjectAnimator.ofFloat(tv, &lt;span class=&quot;string&quot;&gt;&quot;alpha&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.0f&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0f&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .setDuration(&lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .start();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ofFloat&lt;/code&gt;对应着三个参数值，分别是目标&lt;code&gt;View&lt;/code&gt;，动画属性名&lt;code&gt;Property&lt;/code&gt;，以及属性值，一个则为终点值，两个对应着起点和终点值，多个则为起点值，将会调用的值和终点值。与&lt;code&gt;ofFloat&lt;/code&gt;类似的还有&lt;code&gt;ofInt&lt;/code&gt;、&lt;code&gt;ofObject&lt;/code&gt;，这些都是用来设置动画动作的元素。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="Animation" scheme="https://hjw541988478.github.io/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>多行文本的可展开折叠的TextView实现</title>
    <link href="https://hjw541988478.github.io/2015/08/%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E5%8F%AF%E6%8A%98%E5%8F%A0%E5%B1%95%E5%BC%80TextView%E5%AE%9E%E7%8E%B0/"/>
    <id>https://hjw541988478.github.io/2015/08/多行文本可折叠展开TextView实现/</id>
    <published>2015-08-23T11:28:19.000Z</published>
    <updated>2018-08-18T15:44:49.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在实现商家评论区的需求时，对于多行评论的显示，采用的是使用<code>maxLines</code>属性去限定显示的行数，同时使用<code>android:ellipsize=end</code>在限定行数的末尾显示<code>...</code>，这种方式可以很好的避免评论文字过多显示过长的情况。但是对于有价值的评论，有必要显示所有评论文字，采用展开折叠的交互，能够更加的灵活地去应对长文字的多行显示，给用户给好的体验。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，继承<code>LinearLayout</code>，并对文本和标记组件进行一层包装，通过对折叠状态下的行数、展开折叠的动画时长、展开和折叠状态的视图控制，进行可自定义的属性封装。然后对父类的<code>onClick</code>方法进行重写，用户在对组件点击的时候，文本会自动的展开或折叠。然而当文本正在处于折叠或展开过程的动画中时，应该重写<code>onInterceptTouchEvent</code>方法拦截所有的点击事件，防止出现异常。<br><a id="more"></a><br>其次，在整个流程中我们需要了解到文本的真实高度，用来在初始化的时候去判断是否需要进入折叠模式，因此需要重写<code>onMeasure</code>方法，如果组件不需要重新绘制或者组件的可见性为<code>View.GONE</code>，则直接使用父类的<code>onMeasure</code>方法。<br>然后，但是如果组件需要重新绘制，便会初始化组件的状态，并对组件进行测量，判断真实文本的行数，如果小于设置的最大显示行数，则直接显示，否则按最大显示行数显示文本并让展开状态的View可见，保存当前折叠状态下显示的高度。<br>最后，对于视图复用的问题，一般情况下，视图被滑出了屏幕看不见后，这个视图数据便消失了，重新让视图进入屏幕中时，视图会重新初始化，而对于那些展开或者折叠状态的视图也会默认变为折叠模式。因此需要一个标记量去使用额外的标记决定视图显示的位置和状态，这里使用到的是<a href="http://blog.csdn.net/haukey/article/details/8200404" target="_blank" rel="noopener">SparseBooleanArray</a>，实质上基于稀疏矩阵和折半查找的<code>HashMap&lt;Integer,Boolean&gt;</code>的优化版本，<code>key</code>用来记录位置，<code>value</code>用来记录状态。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li><p>通过在<code>attrs.xml</code>中进行属性的自定义，并通过下面的代码去获取在布局文件中配置的自定义的属性值，包括了最多显示行数，展开、折叠资源等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    TypedArray typedArray = getContext().obtainStyledAttributes(attrs, R.styleable.ExpTextView);</span><br><span class="line">    <span class="comment">//最多行数</span></span><br><span class="line">    mMaxLines = typedArray.getInt(R.styleable.Exp_maxCollapsedLines, MAX_COLLAPSED_LINES);</span><br><span class="line">    <span class="comment">//动画时长</span></span><br><span class="line">    mAnimDuration = typedArray.getInt(R.styleable.ExpTextView_animDuration, DEFAULT_ANIM_DURATION);</span><br><span class="line">    <span class="comment">// 动画透明度渐变初始值</span></span><br><span class="line">    mAnimAlphaStart = typedArray.getFloat(R.styleable.ExpTextView_animAlphaStart, DEFAULT_ANIM_ALPHA_START);</span><br><span class="line">    mExpandDrawable = typedArray.getDrawable(R.styleable.ExpTextView_expandDrawable);</span><br><span class="line">    mCollapseDrawable = typedArray.getDrawable(R.styleable.ExpTextView_collapseDrawable);</span><br><span class="line">    <span class="keyword">if</span> (mExpandDrawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mExpandDrawable = getDrawable(getContext(), );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mCollapseDrawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCollapseDrawable = getDrawable(getContext(), R.drawable.ic_mer_detail_collapse);</span><br><span class="line">    &#125;</span><br><span class="line">    typedArray.recycle();</span><br><span class="line">    <span class="comment">//只能是垂直布局</span></span><br><span class="line">    setOrientation(LinearLayout.VERTICAL);</span><br><span class="line">    <span class="comment">//默认是不显示的</span></span><br><span class="line">    setVisibility(GONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写<code>onMeasure</code>方法，目的是判断当前文本的状态和初始化在不同状态下必要的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有改变直接返回当前状态</span></span><br><span class="line">    <span class="keyword">if</span> (!mRelayout || getVisibility() == View.GONE) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mRelayout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 初始化默认状态</span></span><br><span class="line">    mButton.setVisibility(View.GONE);</span><br><span class="line">    mTv.setMaxLines(Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">// 测量控件尺寸</span></span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="comment">// 文本显示的行数小于限定值，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mTv.getLineCount() &lt;= mMaxCollapsedLines) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得文本的真实高度</span></span><br><span class="line">    mTextHeightWithMaxLines = getRealTextViewHeight(mTv);</span><br><span class="line">    <span class="comment">// 处于折叠模式中，只显示限定值的行数</span></span><br><span class="line">    <span class="keyword">if</span> (mCollapsed) &#123;</span><br><span class="line">        mTv.setMaxLines(mMaxCollapsedLines);</span><br><span class="line">    &#125;</span><br><span class="line">    mButton.setVisibility(View.VISIBLE);</span><br><span class="line">    <span class="comment">// 重新测量控件尺寸</span></span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (mCollapsed) &#123;</span><br><span class="line">        <span class="comment">// 获得文本与容器的外间距值</span></span><br><span class="line">        mTv.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mMarginBetweenTxtAndBottom = getHeight() - mTv.getHeight();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 保存当前测量值的高度</span></span><br><span class="line">        mCollapsedHeight = getMeasuredHeight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取<code>TextView</code>真实高度的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRealTextViewHeight</span><span class="params">(TextView textView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> textHeight = textView.getLayout().getLineTop(textView.getLineCount());</span><br><span class="line">        <span class="keyword">int</span> padding = textView.getCompoundPaddingTop() + textView.getCompoundPaddingBottom();</span><br><span class="line">        <span class="keyword">return</span> textHeight + padding;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>重写<code>onClick</code>方法，处理点击事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mButton.getVisibility() != View.VISIBLE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 折叠模式状态值与上次相反</span></span><br><span class="line">    mCollapsed = !mCollapsed;</span><br><span class="line">    mButton.setImageDrawable(mCollapsed ? mExpandDrawable : mCollapseDrawable);</span><br><span class="line">    <span class="keyword">if</span> (mCollapsedStatus != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 存放状态值</span></span><br><span class="line">        mCollapsedStatus.put(mPosition, mCollapsed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动画播放标记置true</span></span><br><span class="line">    mAnimating = <span class="keyword">true</span>;</span><br><span class="line">    Animation animation;</span><br><span class="line">    <span class="keyword">if</span> (mCollapsed) &#123;</span><br><span class="line">        animation = <span class="keyword">new</span> ExpandCollapseAnimation(<span class="keyword">this</span>, getHeight(), mCollapsedHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        animation = <span class="keyword">new</span> ExpandCollapseAnimation(<span class="keyword">this</span>, getHeight(), getHeight() +</span><br><span class="line">                mTextHeightWithMaxLines - mTv.getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保持动画后的状态</span></span><br><span class="line">    animation.setFillAfter(<span class="keyword">true</span>);</span><br><span class="line">    animation.setAnimationListener(<span class="keyword">new</span> Animation.AnimationListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">            applyAlphaAnimation(mTv, mAnimAlphaStart);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 防止多次调用applyTransformation()</span></span><br><span class="line">            clearAnimation();</span><br><span class="line">            <span class="comment">// 动画播放标记置false</span></span><br><span class="line">            mAnimating = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果外部有设置监听事件，则触发监听事件</span></span><br><span class="line">            <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mListener.onExpandStateChanged(mTv, !mCollapsed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    clearAnimation();</span><br><span class="line">    startAnimation(animation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>展开折叠动画类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpandCollapseAnimation</span> <span class="keyword">extends</span> <span class="title">Animation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> View mTargetView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mStartHeight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mEndHeight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExpandCollapseAnimation</span><span class="params">(View view, <span class="keyword">int</span> startHeight, <span class="keyword">int</span> endHeight)</span> </span>&#123;</span><br><span class="line">        mTargetView = view;</span><br><span class="line">        mStartHeight = startHeight;</span><br><span class="line">        mEndHeight = endHeight;</span><br><span class="line">        setDuration(mAnimationDuration);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyTransformation</span><span class="params">(<span class="keyword">float</span> interpolatedTime, Transformation t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newHeight = (<span class="keyword">int</span>) ((mEndHeight - mStartHeight) * interpolatedTime + mStartHeight);</span><br><span class="line">        mTv.setMaxHeight(newHeight - mMarginBetweenTxtAndBottom);</span><br><span class="line">        <span class="keyword">if</span> (Float.compare(mAnimAlphaStart, <span class="number">1.0f</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            applyAlphaAnimation(mTv, mAnimAlphaStart + interpolatedTime * (<span class="number">1.0f</span> - mAnimAlphaStart));</span><br><span class="line">        &#125;</span><br><span class="line">        mTargetView.getLayoutParams().height = newHeight;</span><br><span class="line">        mTargetView.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> parentWidth, <span class="keyword">int</span> parentHeight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.initialize(width, height, parentWidth, parentHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">willChangeBounds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其他必要重写的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果动画正在播放就不分发触摸时间给子View</span></span><br><span class="line">    <span class="keyword">return</span> mAnimating;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 结束加载时初始化控件ID</span></span><br><span class="line">    findViews();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/08/多行文本可折叠展开TextView实现/pic_expandable_state.png" alt="多行文本展开状态效果图" title="">                </div>                <div class="image-caption">多行文本展开状态效果图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/08/多行文本可折叠展开TextView实现/pic_collapse_state.png" alt="多行文本收缩状态效果图" title="">                </div>                <div class="image-caption">多行文本收缩状态效果图</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;在实现商家评论区的需求时，对于多行评论的显示，采用的是使用&lt;code&gt;maxLines&lt;/code&gt;属性去限定显示的行数，同时使用&lt;code&gt;android:ellipsize=end&lt;/code&gt;在限定行数的末尾显示&lt;code&gt;...&lt;/code&gt;，这种方式可以很好的避免评论文字过多显示过长的情况。但是对于有价值的评论，有必要显示所有评论文字，采用展开折叠的交互，能够更加的灵活地去应对长文字的多行显示，给用户给好的体验。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;首先，继承&lt;code&gt;LinearLayout&lt;/code&gt;，并对文本和标记组件进行一层包装，通过对折叠状态下的行数、展开折叠的动画时长、展开和折叠状态的视图控制，进行可自定义的属性封装。然后对父类的&lt;code&gt;onClick&lt;/code&gt;方法进行重写，用户在对组件点击的时候，文本会自动的展开或折叠。然而当文本正在处于折叠或展开过程的动画中时，应该重写&lt;code&gt;onInterceptTouchEvent&lt;/code&gt;方法拦截所有的点击事件，防止出现异常。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="CustomView" scheme="https://hjw541988478.github.io/tags/CustomView/"/>
    
  </entry>
  
</feed>
