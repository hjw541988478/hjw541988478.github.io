<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Garvin 杂记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hjw541988478.github.io/"/>
  <updated>2018-08-17T09:25:58.039Z</updated>
  <id>https://hjw541988478.github.io/</id>
  
  <author>
    <name>Garvin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MaterialDesign设计探索使用</title>
    <link href="https://hjw541988478.github.io/MaterialDesign%E8%AE%BE%E8%AE%A1%E6%8E%A2%E7%B4%A2%E4%BD%BF%E7%94%A8/"/>
    <id>https://hjw541988478.github.io/MaterialDesign设计探索使用/</id>
    <published>2015-09-09T11:24:14.000Z</published>
    <updated>2018-08-17T09:25:58.039Z</updated>
    
    <content type="html"><![CDATA[<p>在Android5.0之后，Google就开始推崇一门新的设计语言MaterialDesign，它更加新鲜和简洁，且能够非常有效的激发应用开发者的创作热情，也能够降低开发者自主开发设计UI的难度，对于MD风格的实现，Google后续完善了下面几个库，一步步的实现MD标准的交互效果。<br>需要在AndroidStudio引入的库：</p><p>compile ‘com.android.support:design:23.0.0’<br>compile ‘com.android.support:appcompat-v7:23.0.0’<br>compile ‘com.android.support:recyclerview-v7:23.0.0’<br>compile ‘com.android.support:cardview-v7:23.0.0’<br>新的UI组件<br>CoordinatorLayout<br>CoordinatorLayout在android.support.deisgn中，是一种增强型的FrameLayout，主要有以下两大基础性作用：</p><p>作为顶级应用的装饰器；<br>作为给多个子View之间进行特定交互的协调器；<br>通过对子View的Behaviors的指定，可以实现子View之间的通信，从而确定它们具体的交互行为。</p><p>Behavior<br>官方提供的Behavior<br>Behaivor是CoordinatorLayout子View之间进行交互的插件，包括了一种或多种交互行为，如拖拉、滑动、下拉等各种手势。已知的子类有AppBarLayout.Behavior，AppBarLayout.ScrollingViewBehavior， FloatingActionButton.Behavior和SwipeDismissBehavior<v extends="" view="">,这些可以直接使用@string/**的形式在layout_behavior属性中使用。<br>自定义Behavior<br>自定义的Behavior需要重新实现的回调方法有：<br>public boolean layoutDependsOn (CoordinatorLayout parent, View child, View dependency)<br>该方法确定是否有另一个指定的兄弟View作为依赖布局，并且作为对布局请求的响应，至少会调用一次。如果指定的child和dependency返回为true,父ViewCoordinatorLayout可能会做以下两件事：<br>不管子View的命令，始终在dependencyView后展示child；<br>当dependency视图布局或位置发生变化时，调用onDepentViewChanged方法；<br>public boolean onDependentViewChanged (CoordinatorLayout parent, View child, View dependency)<br>无论dependency尺寸或者布局改变，该方法都会被调用。Behavor可能会合适地使用该方法来更新视图以此作为回应。当layoutDependsOn被调用时或者child设置了以一个锚视图，dependency也会改变。如果Behavor改变了child的位置或者大小，则返回true。<br>NestingScrolling<br>原始触摸事件分发<br>目前的触摸事件的分发机制都是从父View传递给子View，会经历dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent，但是如果触摸事件分发给子View的时候，而子View想根据实际情况将事件向上层传递给父View，而这个时候子View并没有办法通知父View，只能将事件抛弃。</v></p><p>嵌套滑动处理流程<br>在行的嵌套滑动机制中，可以使用到supportv4包中NestedScrollingChild类，包括下面几个关键的方法：</p><p>public boolean startNestedScroll(int axes)<br>子View寻找能够接受嵌套滑动事件的ParentView，然后通知父View，配合处理触摸事件；<br>public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow)<br>在子View中的onInterceptTouch或者onTouch事件中，通过调用该方法通知父View滑动的距离。其中第三个参数父View消费掉的滑动长度，第四个参数返回子View的窗体偏移量。由于窗体进行了移动，为了下一次触摸事件计算正确，还需要根据第四个参数来计算偏移量。整个方法返回的值是根据父View是否有接受子View滚动参数的消费来决定返回true或者false；<br>public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)<br>在子View进行了scroll后，如果父View接受到了它的滚动参数并进行了消费，则返回true，否则返回false；<br>public void stopNestedScroll()<br>整个嵌套处理流程结束。<br>AppBarLayout<br>AppBarLayout是实现了众多MD设计概念特性的垂直方向的LinearLayout，其中一个很重要的概念就是滚动手势。子View可以通过方法setScrollFlags(int)或者XML属性app:layout_scrollFlags去提供期望的滚动行为。该布局应该直接放在CoordinateLayout节点下，同时也需要兄弟View去决定何时滚动，但必须是AppBarLayout.ScrollingViewBehavior的实例。</p><p>layout_scrollFlags<br>作为触发特定交互事件的标志，主要有四种：</p><p>SCROLL_FLAG_ENTER_ALWAYS<br>这个flag让任意向下的滚动使得View可见；<br>SCROLL_FLAG_ENTER_ALWAYS_COLLAPSED<br>当View既设置了minHeight属性又设置了此flag，只有滚动到顶部的时候才会时View可见；<br>SCROLL_FLAG_EXIT_UNTIL_COLLAPSED<br>当View离开屏幕时，保持折叠的状态；<br>SCROLL_FLAG_SCROLL<br>View会直接离开屏幕。<br>常用属性<br>属性名    解释<br>layout_scrollFlags    设置滚动出发事件的标志<br>layout_scrollInterpolator    设置滚动发生时的插值器<br>CollapsingToolbarLayout<br>CollapsingToolbarLayout是实现了折叠的ToolBar的包装，它用来设计作为AppBarLayout的直接子View，可以用来设置众多属性，包括折叠状态的标题、位置等。</p><p>常用属性<br>属性名    解释<br>collapsedTitleGravity    指定折叠状态的标题如何放置，可选值:top、bottom等<br>collapsedTitleTextAppearance    指定折叠状态标题文字的样貌<br>contentScrim    指定CollapsingToolbarLayout完全被滚出到屏幕外时的ColorDrawable<br>expandedTitleGravity    指定展开状态的标题如何放置<br>title    指定标题文本<br>titleEnabled    指定是否显示标题文本<br>toolbarId    指定与之关联的ToolBar，如果未指定则默认使用第一个被发现的ToolBar子View<br>layout_collapseMode    COLLAPSE_MODE_OFF:View表现的像没有折叠行为一样； COLLAPSE_MODE_PARALLAX：View会以视差的样式滚动；<br>COLLAPSE_MODE_PIN：View会直到达到CollapsingToolbarLayout底部的时候固定；</p><p>实例<br>特性<br>新的UI组件：Toolbar、DrawerLayout、DrawerNavigationView、SwipeRefreshLayout、RecyclerView、TabLayout、CollapsingToolbarLayout、AppBarLayout、CoordinateLayout、FloatingActionButton、SnackBar、CardView;<br>已实现效果<br>下拉刷新<br>抽屉菜单导航<br>Tab选项卡导航<br>视差折叠Toolbar<br>效果图<br>抽屉菜单和Tab布局效果图<br>视差效果图</p><p>实现过程<br>下拉刷新<br>布局</p><p>&lt;android.support.v4.widget.SwipeRefreshLayout<br>    android:id=”@+id/id_refresh”<br>    android:layout_width=”match_parent”<br>    android:layout_height=”match_parent”&gt;<br>    &lt;android.support.v7.widget.RecyclerView<br>        android:id=”@+id/id_list”<br>        android:layout_width=”match_parent”<br>        android:layout_height=”match_parent” /&gt;<br>&lt;/android.support.v4.widget.SwipeRefreshLayout&gt;<br>代码</p><p>// 视图初始化设置刷新监听和适配器<br>RecyclerView recyclerView = (RecyclerView) root.findViewById(R.id.id_list);<br>        final SwipeRefreshLayout swipeRefresh = (SwipeRefreshLayout) root.findViewById(R.id.id_refresh);<br>        swipeRefresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {<br>            @Override<br>            public void onRefresh() {<br>                adapter.data.add(0, “onRefresh”);<br>                adapter.notifyDataSetChanged();<br>                swipeRefresh.setRefreshing(false);<br>            }<br>        });<br>        recyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));<br>        recyclerView.setHasFixedSize(true);<br>        recyclerView.setAdapter(adapter);<br>// 适配器<br>class RecyclerViewListAdapter extends RecyclerView.Adapter&lt;RecyclerViewListAdapter.MyViewHolder&gt; {<br>        private List<string> data = new ArrayList&lt;&gt;();<br>        public RecyclerViewListAdapter(List<string> data) {<br>            this.data.clear();<br>            this.data.addAll(data);<br>        }<br>        @Override<br>        public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {<br>            View itemView = LayoutInflater.from(parent.getContext())<br>                    .inflate(R.layout.item_fragment_list, parent, false);<br>            return new MyViewHolder(itemView);<br>        }<br>        @Override<br>        public void onBindViewHolder(MyViewHolder holder, final int position) {<br>            holder.itemText.setText(data.get(position));<br>            holder.rootView.setOnClickListener(new View.OnClickListener() {<br>                @Override<br>                public void onClick(View v) {<br>                    Intent intent = new Intent(v.getContext(), DetailActivity.class);<br>                    intent.putExtra(“title”, data.get(position));<br>                    v.getContext().startActivity(intent);<br>                }<br>            });<br>        }<br>        @Override<br>        public int getItemCount() {<br>            return data.size();<br>        }<br>        class MyViewHolder extends RecyclerView.ViewHolder {<br>            @Bind(R.id.id_item_text)<br>            TextView itemText;<br>            View rootView;</string></string></p><pre><code>        public MyViewHolder(View itemView) {            super(itemView);            rootView = itemView;            ButterKnife.bind(this, itemView);        }    }}</code></pre><p>关于下拉刷新部分的详细实现可参考上一篇博文：HarvestRecyclerView-RecyclerView下拉刷新上拉加载的封装 。</p><p>抽屉菜单导航<br>布局</p><p>&lt;android.support.v4.widget.DrawerLayout xmlns:android=”<a href="http://schemas.android.com/apk/res/android&quot;" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android&quot;</a><br>    xmlns:app=”<a href="http://schemas.android.com/apk/res-auto&quot;" target="_blank" rel="noopener">http://schemas.android.com/apk/res-auto&quot;</a><br>    android:id=”@+id/id_drawer_layout”<br>    android:layout_width=”match_parent”<br>    android:layout_height=”match_parent”<br>    android:fitsSystemWindows=”true”&gt;<br>    <include layout="..."><br>    &lt;android.support.design.widget.NavigationView<br>        android:id=”@+id/id_drawer_nav_view”<br>        android:layout_width=”wrap_content”<br>        android:layout_height=”match_parent”<br>        android:layout_gravity=”start”<br>        android:fitsSystemWindows=”true”<br>        app:headerLayout=”@layout/nav_header”<br>        app:menu=”@menu/menu_drawer” /&gt;<br>&lt;/android.support.v4.widget.DrawerLayout&gt;<br>需要注意的是，对于抽屉菜单，分为头布局和菜单两部分，头布局是layout资源，而菜单是menu资源，极大地降低了使用的难度，降低了各自的耦合度。<br>抽屉菜单分解图<br>nav_header.xml</include></p><p><relativelayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="200dp" android:background="?attr/colorPrimaryDark" android:padding="16dp"><br>    <textview android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centervertical="true" android:text="Hi, Doge!" android:textcolor="@android:color/white"><br>    <imageview android:layout_width="120dp" android:layout_height="120dp" android:layout_centerinparent="true" android:scaletype="centerCrop" android:src="@mipmap/doge_head"><br></imageview></textview></relativelayout><br>menu_drawer.xml</p><p><menu xmlns:android="http://schemas.android.com/apk/res/android"><br>    <group android:checkablebehavior="single"><br>        <item android:icon="@mipmap/ic_dashboard" android:title="Home"><br>        <item android:icon="@mipmap/ic_forum" android:title="Setting"><br>        <item android:icon="@mipmap/ic_event" android:title="Like"><br>        <item android:icon="@mipmap/ic_headset" android:title="Music"><br>    </item></item></item></item></group><br></menu><br>布局中android:layout_gravity=”start”属性代表着抽屉菜单放在左边，此时通过设置抽屉菜单视图选中的监听器，可以边缘右滑和左上角的菜单图标打开抽屉，点击空白区域或者选中菜单项便可以关闭菜单。</p><p>navView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {<br>            @Override<br>            public boolean onNavigationItemSelected(MenuItem menuItem) {<br>                menuItem.setCheckable(true);<br>                navDrawer.closeDrawers();<br>                return true;<br>            }<br>        });<br>@Override<br>public boolean onOptionsItemSelected(MenuItem item) {<br>    int id = item.getItemId();<br>    if (id == android.R.id.home) {<br>        navDrawer.openDrawer(GravityCompat.START);<br>        return true;<br>    }<br>    return super.onOptionsItemSelected(item);<br>}<br>Tab选项卡导航<br>布局</p><p>&lt;android.support.design.widget.CoordinatorLayout<br>    android:layout_width=”match_parent”<br>    android:layout_height=”match_parent”&gt;<br>    &lt;android.support.design.widget.AppBarLayout<br>        android:layout_width=”match_parent”<br>        android:layout_height=”wrap_content”<br>        android:theme=”@style/ThemeOverlay.AppCompat.Dark.ActionBar”&gt;<br>        &lt;android.support.v7.widget.Toolbar<br>            android:id=”@+id/id_toolbar”<br>            android:layout_width=”match_parent”<br>            android:layout_height=”?attr/actionBarSize”<br>            android:background=”?attr/colorPrimary”<br>            app:layout_scrollFlags=”scroll|enterAlways”<br>            app:popupTheme=”@style/ThemeOverlay.AppCompat.Light” /&gt;<br>        &lt;android.support.design.widget.TabLayout<br>            android:id=”@+id/id_tabs”<br>            android:layout_width=”match_parent”<br>            android:layout_height=”wrap_content” /&gt;<br>    &lt;/android.support.design.widget.AppBarLayout&gt;<br>    &lt;android.support.v4.view.ViewPager<br>        android:id=”@+id/id_pager”<br>        android:layout_width=”match_parent”<br>        android:layout_height=”match_parent”<br>        app:layout_behavior=”@string/appbar_scrolling_view_behavior” /&gt;<br>    &lt;android.support.design.widget.FloatingActionButton<br>        android:id=”@+id/id_fab”<br>        android:layout_width=”wrap_content”<br>        android:layout_height=”wrap_content”<br>        android:layout_gravity=”end|bottom”<br>        android:layout_margin=”16dp”<br>        android:src=”@mipmap/ic_done”<br>        app:layout_behavior=”.QuickReturnFooterBehavior” /&gt;<br>&lt;/android.support.design.widget.CoordinatorLayout&gt;<br>布局中使用到了CoordinateLayout作为根节点，辅以ViewPager作为事件行为触发器，再通过AppBarLayout的嵌套，便可以实现了向下滑动自动隐藏Toolbar，上滑恢复显示的功能，这里FloatingActionButton同时也用到了一个自定义的Behavior，可以实现自动隐藏与出现的功能，整个过程显得协调一致。<br>TabLayout一般是与ViewPager一起使用的，在ViewPager初始化并设置了适配器后，让TabLayout与之联动，最后达到一致的工作的效果。<br>TabLayout实现效果图</p><p>这里只实现了3个Tab栏，按照实际情况需要可以通过对ViewPager适配器，来控制Tab栏的标题和个数。</p><p>pager.setAdapter(new ListPagerAdapter(getSupportFragmentManager(), initData()));<br>tabs.setupWithViewPager(pager);<br>此外TabLayout还有一些其他可在布局文件自定义的属性，如下：</p><!--Tab被选中字体的颜色--><p>app:tabSelectedTextColor=@android:color/holo_blue_bright<br><!--Tab未被选中字体的颜色--><br>app:tabTextColor=@android:color/black<br><!--Tab指示器下标的颜色--><br>app:tabIndicatorColor=@android:color/holo_blue_bright<br>视差折叠效果视图<br>布局</p><p>&lt;android.support.design.widget.CollapsingToolbarLayout<br>        android:id=”@+id/collapsing_toolbar”<br>        android:layout_width=”match_parent”<br>        android:layout_height=”match_parent”<br>        android:fitsSystemWindows=”true”<br>        app:contentScrim=”?attr/colorPrimary”<br>        app:expandedTitleMarginEnd=”64dp”<br>        app:expandedTitleMarginStart=”48dp”<br>        app:layout_scrollFlags=”scroll|exitUntilCollapsed”<br>        app:title=”doge”&gt;</p><pre><code>    &lt;ImageView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:fitsSystemWindows=&quot;true&quot;        android:scaleType=&quot;centerCrop&quot;        android:src=&quot;@mipmap/doge&quot;        app:layout_collapseMode=&quot;parallax&quot; /&gt;    &lt;android.support.v7.widget.Toolbar        android:id=&quot;@+id/toolbar&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;?attr/actionBarSize&quot;        app:layout_collapseMode=&quot;pin&quot;        app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;&lt;/android.support.design.widget.CollapsingToolbarLayout&gt;</code></pre><p>CollapsingToolbarLayout直面意思就是可折叠的Toolbar布局，通过向下滚动可以使图片逐渐变大，向下滚动使得逐渐以视差效果的形式逐渐变小，最后只剩下Toolbar，在5.0(v21)版本上，通过Style的设置，可以让状态栏也变得透明，让图片和状态栏融为一体。</p><p><style name="AppTheme" parent="BaseAppTheme"><br>    <item name="android:windowDrawsSystemBarBackgrounds">true</item><br>    <item name="android:statusBarColor">@android:color/transparent</item><br></style><br>展开状态</p><p>折叠状态</p><p>具体实现的关键点在于对layout_collapseMode、layout_scrollFlags和layout_behavior属性的设置，具体设置模式上面有说。</p><p>综合使用范例<br>Google有给出的使用范例：</p><p>&lt;android.support.design.widget.CoordinatorLayout<br>     xmlns:android=”<a href="http://schemas.android.com/apk/res/android&quot;" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android&quot;</a><br>     xmlns:app=”<a href="http://schemas.android.com/apk/res-auto&quot;" target="_blank" rel="noopener">http://schemas.android.com/apk/res-auto&quot;</a><br>     android:layout_width=”match_parent”<br>     android:layout_height=”match_parent”&gt;<br> &lt;android.support.v4.widget.NestedScrollView<br>         android:layout_width=”match_parent”<br>         android:layout_height=”match_parent”<br>         app:layout_behavior=”@string/appbar_scrolling_view_behavior”&gt;<br>     <!-- Your scrolling content --><br> &lt;/android.support.v4.widget.NestedScrollView&gt;<br> &lt;android.support.design.widget.AppBarLayout<br>         android:layout_height=”wrap_content”<br>         android:layout_width=”match_parent”&gt;<br>     &lt;android.support.v7.widget.Toolbar<br>             …<br>             app:layout_scrollFlags=”scroll|enterAlways”/&gt;<br>     &lt;android.support.design.widget.TabLayout<br>             …<br>             app:layout_scrollFlags=”scroll|enterAlways”/&gt;<br> &lt;/android.support.design.widget.AppBarLayout&gt;<br>&lt;/android.support.design.widget.CoordinatorLayout&gt;<br>其他组件<br>CardView<br>布局</p><p>&lt;android.support.v7.widget.CardView<br>    android:layout_width=”match_parent”<br>    android:layout_height=”wrap_content”<br>    android:layout_margin=”8dp”<br>    app:cardElevation=”8dp”<br>    app:contentPadding=”16dp”&gt;<br>    <textview android:layout_width="match_parent" android:layout_height="wrap_content" android:text="这只可爱的柴犬叫Kabosu（かぼす，一种类似于日本柚子的水果，果汁很酸却有种独特的芳香，经常被用作烤鱼或生鱼片的调料）"><br>&lt;/android.support.v7.widget.CardView&gt;<br>item即为卡片视图<br>CardView继承于Framelayout，所以Framelayout的属性都有，同时也有其它可自定义的属性，app:cardElevation表示在Z轴上的阴影，app:contentPadding表示卡片内容的内边距，app:cardCornerRadius表示卡片四个角的圆角矩形的程度。</textview></p><p>Toolbar<br>布局</p><p>&lt;android.support.v7.widget.Toolbar<br>    android:id=”@+id/toolbar”<br>    android:layout_width=”match_parent”<br>    android:layout_height=”?attr/actionBarSize”<br>    app:layout_collapseMode=”pin”<br>    app:popupTheme=”@style/ThemeOverlay.AppCompat.Light” /&gt;<br>作为未来ActionBar的替代品，Google为了统一MD设计的风格和AppBar的设计规范，Toolbar是为了更灵活的ActionBar而生的。通过Style设置NoActionBar，然后再代码中使用setSupportedActionBar方法来使用Toolbar替代ActionBar,此外还可以对其他属性，如标题，背景，LOGO等进行自定义的设置，但请记得要取得ActionBar，请使用getSupportedActionBar方法。</p><p>FloatingActionButton<br>布局</p><p>&lt;android.support.design.widget.FloatingActionButton<br>    android:layout_width=”wrap_content”<br>    android:layout_height=”wrap_content”<br>    android:layout_margin=”16dp”<br>    android:clickable=”true”<br>    android:src=”@mipmap/ic_heart_outline_white_24dp”<br>    app:layout_anchor=”@id/appbar”<br>    app:layout_anchorGravity=”bottom|right|end|center_vertical” /&gt;<br>上面的布局代码在设置完其基本属性后，同时还配置了layout_anchor和layout_anchorGravity属性，表示固定在某个视图上，同时也确定了在视图上的位置。</p><p>SnackBar<br>使用<br>Snackbar.make(fab, “hey , it’s SnackBar”, Snackbar.LENGTH_SHORT).setAction(“Dismiss”, null).show();<br>SnackBar的用法与Toast很类似，但是它可以构造一个动作，监听动作后接受回调，执行自定义的事件。</p><p>总结<br>目前对于MaterialDesign设计的实现，Google官方已经提供了足够多的第三方库了，而且使用起来相对灵活的自由，可以根据需求，适时使用一些新的特性，对于开发来说也减少了设计成本，能够提高开发效率和统一风格。<br>已将代码上传至Github：<a href="https://github.com/hjw541988478/materialdeisgn_tutorial" target="_blank" rel="noopener">https://github.com/hjw541988478/materialdeisgn_tutorial</a></p><p>参考<br>Material Design 中文版<br>Material Design 原版(需FQ)<br>直接拿来用!十大Material Design开源项目-CSDN.NET<br>Android Support Design 中 CoordinatorLayout 与 Behaviors 初探<br>android：ToolBar详解<br>Android的材料设计兼容库（Design Support Library）<br>Github库<br>MaterialDesignLibrary<br>MaterialDesign</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android5.0之后，Google就开始推崇一门新的设计语言MaterialDesign，它更加新鲜和简洁，且能够非常有效的激发应用开发者的创作热情，也能够降低开发者自主开发设计UI的难度，对于MD风格的实现，Google后续完善了下面几个库，一步步的实现MD标准的交
      
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="MaterialDesign" scheme="https://hjw541988478.github.io/tags/MaterialDesign/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView下拉刷新上拉加载的封装</title>
    <link href="https://hjw541988478.github.io/RecyclerView%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>https://hjw541988478.github.io/RecyclerView下拉刷新上拉加载的封装/</id>
    <published>2015-09-02T11:04:23.000Z</published>
    <updated>2018-08-17T15:13:02.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识RecyclerView"><a href="#初识RecyclerView" class="headerlink" title="初识RecyclerView"></a>初识RecyclerView</h2><blockquote><p>A flexible view for providing a limited window into a large data set.</p></blockquote><p>根据Google提供的官方说明，意思是为了解决大量数据子在有限的屏幕中显示的情况，<code>RecyclerView</code>就是应对这种情况而产生的。<code>RecyclerView</code>是supportV7包中最新的组件，有着非常高的可定制性和灵活性。使用时需要在<code>build.gradle</code>文件中配置：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.android.support:recyclerview-v7:22.2.1'</span></span><br></pre></td></tr></table></figure></p><p>与<code>ListView</code>不同的是，<code>RecyclerView</code>不再负责Item布局绘制等方面的工作，转而拆分成不同的类去管理。作为未来<code>ListView、GridView</code>等替代的组件，虽然没有它们那么易用，所有的功能都需要自己重新实现，但正是因为这种特性使得<code>RecyclerView</code>更加Flexible。为了满足各种各样的需求，可能会使用到下面与<code>RecyclerView</code>相关紧密的类：<br><a id="more"></a></p><h3 id="RecyclerView-Adapter"><a href="#RecyclerView-Adapter" class="headerlink" title="RecyclerView.Adapter"></a>RecyclerView.Adapter</h3><p><code>Adapter</code>与在此前用到过的<code>BaseAdapter</code>很相似，准确的说是做了缓存优化的<code>BaseAdapter</code>，它负责为Item创建合适的视图同时为这些视图通过<code>ViewHolder</code>去绑定数据，以下3个方法是必须重写的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent,<span class="keyword">int</span> viewType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder,<span class="keyword">int</span> position)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><h3 id="RecyclerView-ViewHolder"><a href="#RecyclerView-ViewHolder" class="headerlink" title="RecyclerView.ViewHolder"></a>RecyclerView.ViewHolder</h3><p><code>ViewHolder</code>早前在<code>ListView</code>的使用时就推荐用来做性能优化，只不过在<code>RecyclerView.Adapter</code>中变成了必须实现的一部分。它保存着Item中所需要使用到的视图ID，方便在绑定数据的时候使用，使用的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewHolder</span> <span class="keyword">extends</span> <span class="title">ViewHolder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewHolder</span><span class="params">(View itemView)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(itemView);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="RecyclerView-LayoutManager"><a href="#RecyclerView-LayoutManager" class="headerlink" title="RecyclerView.LayoutManager"></a>RecyclerView.LayoutManager</h3><p><code>LayoutManager</code>是用来确定<code>RecyclerView</code>的布局方式的，目前有三种可选，分别是：</p><ul><li><code>LinearLayoutManager</code><br>线性布局，提供横向和纵向布局，实现ListView的选择</li><li><code>GridLayoutManager</code><br>表格布局，初始化时需要提供列的数目，与GridView初始化时类似</li><li><code>StaggeredGridLayoutManager</code><br>实现瀑布流效果必备，错乱的网格布局，提供横向和纵向布局<br>对于实现上拉加载的时候，也需要使用到这个类，辅助性的获取一些数据，主要方法有：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findFirstVisibleItemPosition</span><span class="params">()</span> <span class="comment">// 返回第一个可见Item在Adapter中的位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findFirstCompletelyVisibleItemPosition</span><span class="params">()</span> <span class="comment">// 返回第一个完全可见Item在Adapter中的位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLastVisibleItemPosition</span><span class="params">()</span> <span class="comment">// 返回最后一个可见Item在Adapter中的位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLastCompletelyVisibleItemPosition</span><span class="params">()</span> <span class="comment">// 返回最后一个完全可见Item在Adapter中的位置</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="RecyclerView-ItemDecoration"><a href="#RecyclerView-ItemDecoration" class="headerlink" title="RecyclerView.ItemDecoration"></a>RecyclerView.ItemDecoration</h3><p><code>ItemDecoration</code>类似<code>ListtView</code>中的<code>Divider</code>，让Item可以分隔开，但并不是必备的，在MaterialDesign设计中，推荐<code>RecyclerView</code>与<code>CardView</code>结合在一起使用，但是实际项目开发中，可以根据需要绘制<code>ItemDecoration</code>，实现不同风格的间隔线。实现自定义的<code>ItemDecoration</code>需要实现的方法有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c,RecyclerView parent,RecyclerView.State state)</span> <span class="comment">// 绘制视图</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getItemOffset</span><span class="params">(Rect outRect,<span class="keyword">int</span> itemPosition,RecyclerView parent)</span> <span class="comment">// 在绘制视图时会调用此方法计算每一个Item的合适的尺寸</span></span></span><br></pre></td></tr></table></figure></p><h3 id="RecyclerView-ItemAnimator"><a href="#RecyclerView-ItemAnimator" class="headerlink" title="RecyclerView.ItemAnimator"></a>RecyclerView.ItemAnimator</h3><p>当Item的状态改变的时候，<code>ItemAnimator</code>会根据实际情况提供不同的动画效果，主要有 </p><ul><li>Item被删除时</li><li>Item被添加时</li><li>Item被移动时<br>在未给<code>RecyclerView</code>设置<code>ItemAnimator</code>的时候，会使用默认的<code>DefaultItemAnimator</code>，以前我们都是使用<code>notifyDataSetChanged</code>方法去更新视图，现在我们可以使用带有动画效果的<code>notifyItemInserted、notifyItemRemoved</code>方法去更新视图。主要使用到的有：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notifyItemInserted</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="comment">// 插入时的动画效果</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notifyItemRemoved</span><span class="params">(<span class="keyword">int</span> position)</span> <span class="comment">// 移除时的动画效果</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="框架封装思路"><a href="#框架封装思路" class="headerlink" title="框架封装思路"></a>框架封装思路</h2><h3 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h3><p>下拉刷新采用supportv4包中原生的下拉组件<code>SwipeRefreshlayout</code>，直接在布局文件中作为容器包裹<code>RecyclerView</code>，然后在视图初始化的时候，对组件设置<code>onRefershListener</code>，在其回调方法<code>onRefresh</code>中拦截下拉刷新事件，使用自定义的刷新监听器，根据实际情况分发刷新事件。其中使下拉刷新事件控制的相关方法有<code>setEnabled</code>和<code>setRerefreshing</code>，分别的作用是是否允许下拉刷新以及下拉刷新UI是否运行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许下拉刷新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onRefreshListener 刷新回调接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableRefresh</span><span class="params">(<span class="keyword">final</span> OnRefreshListener onRefreshListener)</span> </span>&#123;</span><br><span class="line">    swipeRefreshLayout.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">    mOnRefreshListener = <span class="keyword">new</span> SwipeRefreshLayout.OnRefreshListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (onRefreshListener != <span class="keyword">null</span>)</span><br><span class="line">                onRefreshListener.onRefresh();</span><br><span class="line">            <span class="keyword">if</span> (swipeRefreshLayout.isRefreshing())</span><br><span class="line">                swipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    swipeRefreshLayout.setOnRefreshListener(mOnRefreshListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是对刷新事件的拦截和处理过程，若是允许下拉刷新并且下拉监听器不为空，则将事件向上级传递，执行业务代码，若是刷新事件执行完毕后，将刷新组件的状态自动设置为默认状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 禁止下拉刷新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disableRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    swipeRefreshLayout.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (manager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (adapter != <span class="keyword">null</span> &amp;&amp; adapter.getItemCount() != <span class="number">0</span>)</span><br><span class="line">            manager.scrollToPosition(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若是不允许下拉刷新，直接将组件<code>setEnabled</code>为false便可，同时数据不为空的时候，讲焦点移动到第一个Item的位置。</p><h3 id="上拉加载"><a href="#上拉加载" class="headerlink" title="上拉加载"></a>上拉加载</h3><p>上拉加载的实现依赖于<code>OnScrollListener</code>，当滑动到最后一个Item的时候并且<code>RecyclerView</code>处于<code>SCROLL_STATE_IDLE</code>状态，便可以得知视图已经拉到底部，此时便触发自定义的上拉加载监听器并执行回调，同时在上拉加载完成后，若视图处于刷新状态，则将视图切换到默认状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 允许上拉加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onLoadMoreListener</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableLoadMore</span><span class="params">(<span class="keyword">final</span> OnLoadMoreListener onLoadMoreListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOnLoadMoreListener != <span class="keyword">null</span>)</span><br><span class="line">        recyclerView.removeOnScrollListener(mOnLoadMoreListener);</span><br><span class="line">    <span class="keyword">if</span> (adapter != <span class="keyword">null</span>)</span><br><span class="line">        adapter.setIsNeedLoadMore(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">final</span> LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();</span><br><span class="line">    mOnLoadMoreListener = <span class="keyword">new</span> RecyclerView.OnScrollListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mLastVisibleItemPosition + <span class="number">1</span> == adapter.getItemCount()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (onLoadMoreListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    onLoadMoreListener.onLoadMore();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (swipeRefreshLayout.isRefreshing())</span><br><span class="line">                    swipeRefreshLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrolled</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onScrolled(recyclerView, dx, dy);</span><br><span class="line">            mLastVisibleItemPosition = layoutManager.findLastVisibleItemPosition();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    recyclerView.addOnScrollListener(mOnLoadMoreListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过调用<code>enableLoadMore</code>方法，便完成了上拉加载的设置。若是上次的监听器不为空，则移除上一个<code>OnScrollListener</code>，同时设置新的监听器并在<code>Adapter</code>中切换<code>LoadMoreView</code>的状态，这样可以让最后一个Item的视图变成Loading状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 禁止上拉加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disableLoadMore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        adapter.setIsNeedLoadMore(<span class="keyword">false</span>);</span><br><span class="line">        adapter.setFooterView(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mOnLoadMoreListener != <span class="keyword">null</span>)</span><br><span class="line">        recyclerView.removeOnScrollListener(mOnLoadMoreListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若是调用禁止上拉加载方法，则直接移除上拉加载监听器，同时将<code>Adapter</code>中的<code>FooterView</code>置空以及上拉加载的标志位置false。</p><h3 id="抽象适配器"><a href="#抽象适配器" class="headerlink" title="抽象适配器"></a>抽象适配器</h3><blockquote><p>对扩展开放，对修改关闭</p></blockquote><p>由于需要对<code>HeaderView</code>以及<code>FooterView</code>处理，根据开闭原则，显然不能交给使用者自己去实现，因此我们需要封装完善，讲<code>Adapter</code>抽象，然后交由使用者继承已封装好的<code>Adpter</code>，使用者只用关心业务Item，从而更加简便灵活的使用。尽管我们不允许外部改变<code>HeaderView</code>和<code>FooterView</code>的实现逻辑，但是保留接口让使用者决定是否持有或者修改<code>FooterView</code>和<code>HeaderView</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置底部视图</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadMoreView  加载中视图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endFooterView 加载完成视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFooterView</span><span class="params">(View loadMoreView, View endFooterView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadMoreView = loadMoreView;</span><br><span class="line">    <span class="keyword">this</span>.endFooterView = endFooterView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置头部视图</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> headerView 头部视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeaderView</span><span class="params">(View headerView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.headerView = headerView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 总视图个数 = 普通Item个数 + 头视图 + 尾视图</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getAdapterItemCount() + (hasHeaderView() ? <span class="number">1</span> : <span class="number">0</span>) + (isNeedLoadMore ? hasLoadMoreFooterView() ? <span class="number">1</span> : <span class="number">0</span> : hasEndFooterView() ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据不同的类型返回不同的ViewHolder</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> viewType</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> VH <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (viewType == TYPE_LOADMORE_FOOTER) &#123;</span><br><span class="line">        <span class="keyword">return</span> (VH) <span class="keyword">new</span> RecyclerView.ViewHolder(loadMoreView) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (viewType == TYPE_END_FOOTER) &#123;</span><br><span class="line">        <span class="keyword">return</span> (VH) <span class="keyword">new</span> RecyclerView.ViewHolder(endFooterView) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (viewType == TYPE_HEADER) &#123;</span><br><span class="line">        <span class="keyword">return</span> (VH) <span class="keyword">new</span> RecyclerView.ViewHolder(headerView) &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> onCreateViewHolder(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于需要根据实际情况获得的数据，我们使用抽象的方法让子类去实现，Item的数量，类型视图也是由此决定的。需要子类实现的相关方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通Item的视图交由子类去处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> VH <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通Item的视图个数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getAdapterItemCount</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><h2 id="使用方法和效果图"><a href="#使用方法和效果图" class="headerlink" title="使用方法和效果图"></a>使用方法和效果图</h2><p>在使用本框架的时候，使用者只需要在初始化View后，设置后下拉刷新、上拉加载监听器和适配器后，然后使用相关接口决定是否刷新和加载，对于整个UI效果是无需关心的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    initViews();</span><br><span class="line">    <span class="comment">// 再进行网络请求的时候，可设置Loading视图</span></span><br><span class="line">    mRecyclerView.showLoading();</span><br><span class="line">    <span class="keyword">new</span> Handler().postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            bindData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mToolBar = (Toolbar) findViewById(R.id.id_toolbar);</span><br><span class="line">    <span class="keyword">if</span> (mToolBar != <span class="keyword">null</span>)</span><br><span class="line">        setSupportActionBar(mToolBar);</span><br><span class="line">    mRecyclerView = (HarvestRecyclerView) findViewById(R.id.id_harvest_recyclerview);</span><br><span class="line">    manager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">    mRecyclerView.setHasFixedSize(<span class="keyword">true</span>);</span><br><span class="line">    mRecyclerView.setLayoutManager(manager);</span><br><span class="line">    mRecyclerView.setEmptyView(getResources().getDrawable(R.drawable.ic_results_empty), <span class="string">"No data Here."</span>, <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            adapter.data.add(<span class="string">"onRefresh"</span> + refreshNum++);</span><br><span class="line">            adapter.notifyDataSetChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    onRefreshListener = <span class="keyword">new</span> HarvestRecyclerView.OnRefreshListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (refreshNum &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">                adapter.data.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                adapter.data.add(<span class="number">0</span>, <span class="string">"onRefresh"</span> + refreshNum++);</span><br><span class="line">            adapter.notifyDataSetChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    onLoadMoreListener = <span class="keyword">new</span> HarvestRecyclerView.OnLoadMoreListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadMore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (loadMoreNum &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">                mRecyclerView.setLoadMoreEnabled(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                adapter.data.add(<span class="string">"onLoadMore"</span> + loadMoreNum++);</span><br><span class="line">            adapter.notifyDataSetChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继承<code>HarvestRecyclerViewAdpter</code>，实现相关抽象的方法以及业务所需要的相关功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TestHarvHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent)</span> </span>&#123;</span><br><span class="line">    View root = LayoutInflater.from(parent.getContext())</span><br><span class="line">            .inflate(R.layout.item_view_card, parent, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TestHarvHolder(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAdapterItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (holder <span class="keyword">instanceof</span> TestHarvHolder) &#123;</span><br><span class="line">        ((TestHarvHolder) holder).mContentText.setText(data.get(position));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarvHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">    TextView mContentText;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestHarvHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(itemView);</span><br><span class="line">        mContentText = (TextView) itemView.findViewById(R.id.id_text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果图如下面所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/RecyclerView下拉刷新上拉加载的封装/recycler_menu_view.png" alt="demo" title="">                </div>                <div class="image-caption">demo</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/RecyclerView下拉刷新上拉加载的封装/recycler_refresh_view.png" alt="refresh" title="">                </div>                <div class="image-caption">refresh</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/RecyclerView下拉刷新上拉加载的封装/recycler_loadmore_view.png" alt="loadmore" title="">                </div>                <div class="image-caption">loadmore</div>            </figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于下拉刷新和上拉加载框架的封装，主要是异常情况的处理，有无<code>HeaderView</code>，有无<code>FooterView</code>等，以及刷新和加载事件的拦截，以及对于相关设计模式的理解与运用。<br>Github地址：<a href="https://github.com/hjw541988478/RefreshLoadMoreRecyclerView" target="_blank" rel="noopener">https://github.com/hjw541988478/RefreshLoadMoreRecyclerView</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.cnblogs.com/littlepanpc/p/4241575.html?utm_source=tuicool" target="_blank" rel="noopener">关于RecyclerView中Viewholder和View的缓存机制的探究</a></li><li><a href="http://www.grokkingandroid.com/first-glance-androids-recyclerview/" target="_blank" rel="noopener">first-glance-androids-recyclerview</a></li><li><a href="http://www.cnblogs.com/tiantianbyconan/p/4242541.html" target="_blank" rel="noopener">[Android]使用RecyclerView替代ListView（二）</a></li><li>相关Github开源项目<br><a href="https://github.com/Malinskiy/SuperRecyclerView" target="_blank" rel="noopener">SuperRecyclerView</a><br><a href="https://github.com/cymcsg/UltimateRecyclerView" target="_blank" rel="noopener">UltimateRecyclerView</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;初识RecyclerView&quot;&gt;&lt;a href=&quot;#初识RecyclerView&quot; class=&quot;headerlink&quot; title=&quot;初识RecyclerView&quot;&gt;&lt;/a&gt;初识RecyclerView&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;A flexible view for providing a limited window into a large data set.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据Google提供的官方说明，意思是为了解决大量数据子在有限的屏幕中显示的情况，&lt;code&gt;RecyclerView&lt;/code&gt;就是应对这种情况而产生的。&lt;code&gt;RecyclerView&lt;/code&gt;是supportV7包中最新的组件，有着非常高的可定制性和灵活性。使用时需要在&lt;code&gt;build.gradle&lt;/code&gt;文件中配置：&lt;br&gt;&lt;figure class=&quot;highlight gradle&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;compile&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;com.android.support:recyclerview-v7:22.2.1&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;ListView&lt;/code&gt;不同的是，&lt;code&gt;RecyclerView&lt;/code&gt;不再负责Item布局绘制等方面的工作，转而拆分成不同的类去管理。作为未来&lt;code&gt;ListView、GridView&lt;/code&gt;等替代的组件，虽然没有它们那么易用，所有的功能都需要自己重新实现，但正是因为这种特性使得&lt;code&gt;RecyclerView&lt;/code&gt;更加Flexible。为了满足各种各样的需求，可能会使用到下面与&lt;code&gt;RecyclerView&lt;/code&gt;相关紧密的类：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="PullDownToRefresh" scheme="https://hjw541988478.github.io/tags/PullDownToRefresh/"/>
    
      <category term="PullUpToRefresh" scheme="https://hjw541988478.github.io/tags/PullUpToRefresh/"/>
    
      <category term="RecyclerView" scheme="https://hjw541988478.github.io/tags/RecyclerView/"/>
    
      <category term="CustomView" scheme="https://hjw541988478.github.io/tags/CustomView/"/>
    
      <category term="Components" scheme="https://hjw541988478.github.io/tags/Components/"/>
    
  </entry>
  
  <entry>
    <title>Android传感器编程之摇一摇</title>
    <link href="https://hjw541988478.github.io/Android%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%91%87%E4%B8%80%E6%91%87/"/>
    <id>https://hjw541988478.github.io/Android传感器编程之摇一摇/</id>
    <published>2015-08-26T11:54:01.000Z</published>
    <updated>2018-08-17T15:30:43.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>摇一摇功能目前在很多Android的应用都有用到，大多数的目的是增强与用户的交互，同时也增加了趣味性。本质上来看，通过对加速传感器感知手机在X轴、Y轴和Z轴上加速度的变化，在三者的值达到设定的阈值的时候，便触发事件，进行业务上的逻辑调用，同时使用振动传感器产生振动事件。<br>对于加速度传感器和振动传感器的使用，需要预先在配置文件中声明权限：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:<span class="built_in">name</span>=<span class="string">"android.hardware.sensor.accelerometer"</span> /&gt; <span class="comment"># 加速度传感器</span></span><br><span class="line">&lt;uses-permission android:<span class="built_in">name</span>=<span class="string">"android.permission.VIBRATE"</span>/&gt;  <span class="comment"># 振动传感器</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>同时在应用初始化的时候，获取<code>SensorManager</code>和<code>Vibrator</code>,之后才可以使用振动传感器和加速度传感器进行其他操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SensorManager mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);  </span><br><span class="line">Vibrator mVibrator = (Vibrator) getSystemService(Service.VIBRATOR_SERVICE);</span><br></pre></td></tr></table></figure></p><h2 id="摇晃监听器的实现"><a href="#摇晃监听器的实现" class="headerlink" title="摇晃监听器的实现"></a>摇晃监听器的实现</h2><ul><li>摇晃监听器:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShakeOffListener</span> <span class="keyword">implements</span> <span class="title">SensorEventListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="keyword">private</span> Vibrator mVibrator;</span><br><span class="line">    <span class="keyword">private</span> SensorManager mSensorManager;</span><br><span class="line">    <span class="keyword">private</span> OnShakeListener mListener;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">OnShakeListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onShake</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShakeListener</span><span class="params">(OnShakeListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShakeOffListener</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        mVibrator = (Vibrator) context.</span><br><span class="line">                getSystemService(Context.VIBRATOR_SERVICE);</span><br><span class="line">        mSensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mSensorManager.registerListener(<span class="keyword">this</span>,</span><br><span class="line">                mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER),</span><br><span class="line">                SensorManager.SENSOR_DELAY_NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mVibrator.vibrate(<span class="number">300</span>);</span><br><span class="line">        mSensorManager.unregisterListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传感器值变化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSensorChanged</span><span class="params">(SensorEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> x = event.values[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">float</span> y = event.values[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">float</span> z = event.values[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 达到速度阀值，发出提示</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(x) &gt;= <span class="number">19</span> || Math.abs(y) &gt;= <span class="number">19</span> || Math.abs(z) &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mListener != <span class="keyword">null</span>)</span><br><span class="line">                mListener.onShake();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传感器反应速度值的变化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAccuracyChanged</span><span class="params">(Sensor sensor, <span class="keyword">int</span> accuracy)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在对<code>ShakeOffListener</code>进行初始化时，首先会对传感器进行初始化，同时也在内部定义了<code>OnShakeListener</code>接口，方便在宿主类对事件触发的监听，然后通过对<code>SensorEventListener</code>接口的实现，重新实现了<code>onSensorChanged</code>的回调方法，这里主要完成是对于摇晃功能阈值的设定以及触发条件满足后将事件传给宿主类完成其他操作，同时也定义了<code>resume</code>和<code>pause</code>方法，用来完成摇晃过程的恢复和暂停事件的处理，这样可以更加方便处理摇晃开始、摇晃中和摇晃结束整个流程。</p><h2 id="摇晃监听器的使用及其效果"><a href="#摇晃监听器的使用及其效果" class="headerlink" title="摇晃监听器的使用及其效果"></a>摇晃监听器的使用及其效果</h2><ul><li>在Activity中进行使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ImageView shkePic;</span><br><span class="line">    <span class="keyword">private</span> ShakeOffListener mShakeOffListener;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_test);</span><br><span class="line">        shkePic = (ImageView) findViewById(R.id.id_hand_shake_off);</span><br><span class="line">        mShakeOffListener = <span class="keyword">new</span> ShakeOffListener(<span class="keyword">this</span>);</span><br><span class="line">        mShakeOffListener.setShakeListener(<span class="keyword">new</span> ShakeOffListener.OnShakeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//TODO 处理业务请求</span></span><br><span class="line">                Logger.d(<span class="string">"onShake~"</span>);</span><br><span class="line">                Animation shakeAnim = AnimationUtils.loadAnimation(TestActivity.<span class="keyword">this</span>, R.anim.shake);</span><br><span class="line">                shakeAnim.setAnimationListener(<span class="keyword">new</span> Animation.AnimationListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">                        mShakeOffListener.pause();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">                        mShakeOffListener.resume();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                shkePic.startAnimation(shakeAnim);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mShakeOffListener.resume();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="keyword">if</span> (mShakeOffListener != <span class="keyword">null</span>)&#123;</span><br><span class="line">            mShakeOffListener.pause();</span><br><span class="line">            mShakeOffListener = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在<code>TestActivity</code>中，通过在<code>onCreate</code>方法中，初始化<code>ShakeOffListener</code>同时实现了自定义的摇晃事件接口，巧妙的利用<code>Animation</code>的执行流程的回调方法，防止了摇晃事件的重复触发，摇晃事件的间隔取决于动画的时长，只需要在动画开始和结束使用<code>pause</code>和<code>resume</code>方法便可以暂停和恢复对摇晃事件的监听。最后在<code>Activity</code>被销毁时会回调的<code>onDestroy</code>方法中解除对摇晃监听器的注册，防了止内存泄露。<br>用到的<code>Animation</code>摇晃动画资源文件<code>shake.xml</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">translate</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"500"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromXDelta</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">"@anim/cycle_7"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toXDelta</span>=<span class="string">"50"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>以及使用到的插值器<code>cycle_7.xml</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cycleInterpolator</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:cycles</span>=<span class="string">"5.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>还有在对传感器进行注册的时候，第一个参数是加速度传感器监听器实例，本例中是实现了<code>SensorEventListener</code>接口了的，第二个是加速度传感器实例，实现摇晃功能需要<code>Sensor.TYPE_ACCELEROMETER</code>类型，最后一个参数代表着传感器反应的速度类型，这个有如下几类：</p><ul><li><code>SENSOR_DELAY_NORMAL</code>：默认的获取传感器数据的速度；</li><li><code>SENSOR_DELAY_UI</code>：若使用传感器更新UI，推荐使用；</li><li><code>SENSOR_DELAY_GAME</code>：如果利用传感器开发游戏，建议使用；</li><li><code>SENSOR_DELAY_FASTEST</code>：在特别灵敏的处理下推荐使用，但该模式可能造成手机电力大量消耗；<br>对于摇晃功能的实现，也只需要使用默认的即<code>SENSOR_DELAY_NORMAL</code>便可以满足监听传感器加速度变化的需求：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mSensorManager.registerListener(<span class="keyword">this</span>,</span><br><span class="line">                mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER),</span><br><span class="line">                SensorManager.SENSOR_DELAY_NORMAL);</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Android传感器编程之摇一摇/screenshot_before_shake.png" alt="摇晃前截图" title="">                </div>                <div class="image-caption">摇晃前截图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Android传感器编程之摇一摇/screenshot_after_shake.png" alt="摇晃成功截图" title="">                </div>                <div class="image-caption">摇晃成功截图</div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>摇一摇功能用到的知识点有传感器、动画以及利用动画的执行周期巧妙的实现业务需求，但不得不说的是，对于合理设定摇晃阈值才是整个摇晃功能实现的关键，目前这个版本设定的值是19,对于大多数手机是能够实现功能的，但是相信有更好方法利用X、Y、Z轴加速度的值去处理这个阈值，这个是待完善的地方。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;摇一摇功能目前在很多Android的应用都有用到，大多数的目的是增强与用户的交互，同时也增加了趣味性。本质上来看，通过对加速传感器感知手机在X轴、Y轴和Z轴上加速度的变化，在三者的值达到设定的阈值的时候，便触发事件，进行业务上的逻辑调用，同时使用振动传感器产生振动事件。&lt;br&gt;对于加速度传感器和振动传感器的使用，需要预先在配置文件中声明权限：&lt;br&gt;&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;uses-permission android:&lt;span class=&quot;built_in&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;android.hardware.sensor.accelerometer&quot;&lt;/span&gt; /&amp;gt; &lt;span class=&quot;comment&quot;&gt;# 加速度传感器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;uses-permission android:&lt;span class=&quot;built_in&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;android.permission.VIBRATE&quot;&lt;/span&gt;/&amp;gt;  &lt;span class=&quot;comment&quot;&gt;# 振动传感器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="Sensor" scheme="https://hjw541988478.github.io/tags/Sensor/"/>
    
      <category term="Vibrator" scheme="https://hjw541988478.github.io/tags/Vibrator/"/>
    
  </entry>
  
  <entry>
    <title>Android应用自动检测更新机制的实现</title>
    <link href="https://hjw541988478.github.io/Android%E5%BA%94%E7%94%A8%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://hjw541988478.github.io/Android应用自动检测更新机制的实现/</id>
    <published>2015-08-25T12:42:39.000Z</published>
    <updated>2018-08-17T15:31:23.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在安卓应用程序中，随着业务的升级或者BUG的修复，往往需要进行版本的迭代与更新。在更新的过程中，选择合理的更新方式显得尤为重要。但大多数思路都是一样，从服务端获取版本号比对当前包的版本号，如果大于当前版本号则提示用户升级，而对于某些需要强制更新的版本号，则不允许用户取消版本的升级，必须强制更新。整个流程大概如下图所示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Android应用自动检测更新机制的实现/app_update_flowchart.png" alt="更新流程图" title="">                </div>                <div class="image-caption">更新流程图</div>            </figure><br>可以看到，整个流程的关键在于对VerisonCode版本号的大小比较，VersionCode标识了同一应用的不同版本号，对于修改版本号后打包的安装包便是最新版本的安装包。在AndroidStudio中，VersionCode的配置一般在应用模块的<code>*.build</code>文件中，如下：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    applicationId <span class="string">"com.test.app"</span></span><br><span class="line">    minSdkVersion 9</span><br><span class="line">    targetSdkVersion 22</span><br><span class="line">    <span class="keyword">version</span>Code 6 <span class="comment">#这里便是对版本号的设置</span></span><br><span class="line">    <span class="keyword">version</span>Name <span class="string">"2.0.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>对于本地版本号的获取，使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curCode = mActivity.getPackageManager().getPackageInfo(mActivity.getPackageName(), <span class="number">0</span>).versionCode;</span><br></pre></td></tr></table></figure></p><p>便可以获取，然后直接去比较从服务端获取下来的版本号，便可以知晓应用是否需要更新。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>使用<code>Service</code>组件去完成整个功能，鉴于它有着不可见，运行在后台的特性，并使用本地服务，直接<code>startService</code>或者<code>stopService</code>便可以完成服务的启动和停止，整个流程分为3个部分，服务端获取最新版本信息-&gt;下载最新版本，并实时更新UI-&gt;下载完成，覆盖安装。</p><ul><li>服务端获取最新版本<br>通过服务端提供的API或者第三方SDK提供的API实现，在自定义的<code>Application</code>中，应用启动时便异步发起检测更新的请求，这样应用每次启动都能知晓是否需要更新。对于异步请求，可以使用<code>OkHttp、AsyncHttp</code>等知名的第三方库，同时也可以使用<code>AsyncTask</code>类去实现，当然，视项目的网络请求框架而定，直接复用网络框架中的请求即可。</li><li>下载最新版本，更新进度条<br>在获取到服务端返回的结果中，解析最新版本安装包的下载地址URL链接，同时使用<code>NotificationManager</code>去唤起一个新的<code>Notification</code>，对于有进度条需求的，便需要使用自定义的UI，在<code>Notification</code>中获取到视图的ID和引用，这样便可以适时的去更新UI。对于UI更新机制，推荐使用主UI线程的<code>Handler</code>去维护管理消息队列，在下载线程中只需要使用<code>sendMessage</code>方法将相关数据带过去，让<code>Handler</code>去实现具体的UI更新内容。需要注意的时，对于更新频率的控制，在复用<code>Notification</code>时候，更新频率过高的时候，会占用大量内存，可能会引起UI线程的阻塞，从而影响用户体验。</li><li>下载完成，覆盖安装<br>如何监听下载完成的事件呢?其实可以有两种方式实现，即<code>BroadcastReceiver</code>或者<code>EventBus</code>，但无论哪种方式，下载完成的关键便是网络数据已经完全请求完成，也就是下载进度达到了100%。而覆盖安装的关键在于<code>Intent</code>的<code>Flags</code>和<code>DataAndType</code>的设置，根据之前设定好的下载文件的路径，并可以发起调用覆盖安装的请求。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>UpdateService实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 安装包下载地址</span></span><br><span class="line">    <span class="keyword">private</span> String url = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 新的安装包本地存储路径</span></span><br><span class="line">    <span class="keyword">private</span> String filePath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 通知管理器</span></span><br><span class="line">    <span class="keyword">private</span> NotificationManager updateNotificationManager = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 通知</span></span><br><span class="line">    <span class="keyword">private</span> Notification updateNotification = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取传值</span></span><br><span class="line">        url = intent.getStringExtra(<span class="string">"url"</span>);</span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String fileName = url.substring(url.lastIndexOf(<span class="string">"/"</span>));</span><br><span class="line">            File uDir = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory() + <span class="string">"/test/download/"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!uDir.exists() || !uDir.isDirectory()) &#123;</span><br><span class="line">                uDir.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 本地目录存储路径</span></span><br><span class="line">            filePath = uDir + fileName;</span><br><span class="line">            <span class="comment">// 使用AsyncTask执行下载请求</span></span><br><span class="line">            <span class="keyword">new</span> DownloadAsyncTask().execute(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>UpdateService</code>先会把本地存储路径和<code>Notification</code>初始化，然后使用<code>AsyncTask</code>进行新安装包的下载和<code>NotificationUI</code>的更新工作。记得在使用<code>Service</code>前进行动态注册或者在<code>AndroidManifest.xml</code>文件中配置好<code>Service</code>节点。</p><ul><li><code>DownloadAsyncTask</code>实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//构造Notification</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            updateNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">            updateNotification = <span class="keyword">new</span> Notification();</span><br><span class="line">            updateNotification.icon = R.drawable.ic_launcher;</span><br><span class="line">            updateNotification.contentView = <span class="keyword">new</span> RemoteViews(getPackageName(), R.layout.view_notification_download);</span><br><span class="line">            updateNotification.contentView.setProgressBar(R.id.notify_progress, <span class="number">100</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">            updateNotification.contentView.setTextViewText(R.id.notify_title, <span class="string">"已下载:0%"</span>);</span><br><span class="line">            updateNotification.contentIntent = PendingIntent.getActivity(getApplicationContext(), <span class="number">0</span>, <span class="keyword">new</span> Intent(), <span class="number">0</span>);</span><br><span class="line">            updateNotification.flags = Notification.FLAG_AUTO_CANCEL;</span><br><span class="line">            updateNotificationManager.notify(<span class="number">101</span>, updateNotification);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 下载百分比</span></span><br><span class="line">            <span class="keyword">int</span> downPercentage = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 上次缓存文件大小</span></span><br><span class="line">            <span class="keyword">int</span> cachedSize = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 临时文件大小</span></span><br><span class="line">            <span class="keyword">long</span> tmpTotalSize = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 待下载文件总大小</span></span><br><span class="line">            <span class="keyword">int</span> totalSize = <span class="number">0</span>;</span><br><span class="line">            HttpURLConnection httpUrlConn = <span class="keyword">null</span>;</span><br><span class="line">            InputStream httpInputStream = <span class="keyword">null</span>;</span><br><span class="line">            FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                URL url = <span class="keyword">new</span> URL(params[<span class="number">0</span>]);</span><br><span class="line">                httpUrlConn = (HttpURLConnection) url.openConnection();</span><br><span class="line">                <span class="keyword">if</span> (cachedSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 方便以后实现断点续传</span></span><br><span class="line">                    httpUrlConn.setRequestProperty(<span class="string">"RANGE"</span>, <span class="string">"bytes="</span> + cachedSize + <span class="string">"-"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                httpUrlConn.setConnectTimeout(NetworkConfig.CONNECT_TIMEOUT);</span><br><span class="line">                httpUrlConn.setReadTimeout(NetworkConfig.CONNECT_TIMEOUT);</span><br><span class="line">                <span class="comment">// 获取文件总大小</span></span><br><span class="line">                totalSize = httpUrlConn.getContentLength();</span><br><span class="line">                <span class="keyword">if</span> (httpUrlConn.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">                    httpInputStream = httpUrlConn.getInputStream();</span><br><span class="line">                    fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(filePath));</span><br><span class="line">                    <span class="keyword">byte</span> buffer[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">                    <span class="keyword">int</span> bufferSize = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((bufferSize = httpInputStream.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        fileOutputStream.write(buffer, <span class="number">0</span>, bufferSize);</span><br><span class="line">                        tmpTotalSize += bufferSize;</span><br><span class="line">                        <span class="keyword">int</span> tmpDownPercentage = (<span class="keyword">int</span>) (tmpTotalSize * <span class="number">100</span> / totalSize);</span><br><span class="line">                        <span class="keyword">if</span> (tmpDownPercentage - downPercentage &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                            downPercentage += <span class="number">5</span>;</span><br><span class="line">                            publishProgress(tmpDownPercentage);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 下载结束</span></span><br><span class="line">                    publishProgress(<span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                publishProgress(-<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (httpUrlConn != <span class="keyword">null</span>)</span><br><span class="line">                        httpUrlConn.disconnect();</span><br><span class="line">                    <span class="keyword">if</span> (httpInputStream != <span class="keyword">null</span>)</span><br><span class="line">                        httpInputStream.close();</span><br><span class="line">                    <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>)</span><br><span class="line">                        fileOutputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    publishProgress(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (values[<span class="number">0</span>] != -<span class="number">1</span>) &#123;</span><br><span class="line">                updateNotification.contentView.setTextViewText(R.id.notify_title, values[<span class="number">0</span>] &gt;= <span class="number">100</span> ? <span class="string">"已完成下载"</span> : <span class="string">"已下载:"</span> + values[<span class="number">0</span>] + <span class="string">"%"</span>);</span><br><span class="line">                updateNotification.contentView.setProgressBar(R.id.notify_progress, <span class="number">100</span>, values[<span class="number">0</span>] &gt;= <span class="number">100</span> ? <span class="number">100</span> : values[<span class="number">0</span>], <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                updateNotification.contentView.setTextViewText(R.id.notify_title, <span class="string">"下载失败!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            updateNotification.flags = Notification.FLAG_AUTO_CANCEL;</span><br><span class="line">            updateNotificationManager.notify(<span class="number">101</span>, updateNotification);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Void result)</span> </span>&#123;</span><br><span class="line">            Intent installIntent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">            installIntent.addFlags(Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            installIntent.setDataAndType(Uri.fromFile(<span class="keyword">new</span> File(filePath)), <span class="string">"application/vnd.android.package-archive"</span>);</span><br><span class="line">            startActivity(installIntent);</span><br><span class="line">            stopSelf();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>DownloadAsyncTask</code>充分利用了<code>AsyncTask</code>的特点，分别在<code>onPreExecute</code>中进行了<code>Notification</code>的构造以及唤醒工作，在<code>doInBackground</code>中进行着网络数据下载工作，然后在数据不断缓存的过程中，当数据缓存的比例大于5%时，则调用<code>publishProgress</code>方法，更新<code>Notification</code>中的进度条，这样做的目的是，在频繁更新<code>Notification</code>并唤醒的过程中，会阻塞UI线程导致ANR，因此一般在进度变化累积到5%的时候再去更新UI，保证应用的流畅性。具体涉及到UI的更新工作放在<code>onProgressUpdate</code>方法中，包括进度和文字提示的更新，其中包含了更新失败的情况，同样也需要提示。最后在<code>onPostExecute</code>方法中进行下载文件的获取和安装，并弹出安装界面指导安装。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Android应用自动检测更新机制的实现/shot_downloading.png" alt="下载中状态" title="">                </div>                <div class="image-caption">下载中状态</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Android应用自动检测更新机制的实现/shot_download_completed.png" alt="下载完成状态" title="">                </div>                <div class="image-caption">下载完成状态</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Android应用自动检测更新机制的实现/shot_update_dialog.png" alt="安装状态" title="">                </div>                <div class="image-caption">安装状态</div>            </figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Andriod应用的更新机制主要使用到的知识点有<code>NotificationManager、Notification、ProgressBar、Service、AsyncTask</code>。通过对上面主要的分析与实现，可以看到涉及到的点还是比较多的，但大多都是基础的知识点，以后在实现复杂功能的时候，也应该通过对业务流程的分析、知识点的理解，综合运用，达到目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;在安卓应用程序中，随着业务的升级或者BUG的修复，往往需要进行版本的迭代与更新。在更新的过程中，选择合理的更新方式显得尤为重要。但大多数思路都是一样，从服务端获取版本号比对当前包的版本号，如果大于当前版本号则提示用户升级，而对于某些需要强制更新的版本号，则不允许用户取消版本的升级，必须强制更新。整个流程大概如下图所示：&lt;br&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;/Android应用自动检测更新机制的实现/app_update_flowchart.png&quot; alt=&quot;更新流程图&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;更新流程图&lt;/div&gt;
            &lt;/figure&gt;&lt;br&gt;可以看到，整个流程的关键在于对VerisonCode版本号的大小比较，VersionCode标识了同一应用的不同版本号，对于修改版本号后打包的安装包便是最新版本的安装包。在AndroidStudio中，VersionCode的配置一般在应用模块的&lt;code&gt;*.build&lt;/code&gt;文件中，如下：&lt;br&gt;&lt;figure class=&quot;highlight jboss-cli&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;defaultConfig &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    applicationId &lt;span class=&quot;string&quot;&gt;&quot;com.test.app&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    minSdkVersion 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    targetSdkVersion 22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;version&lt;/span&gt;Code 6 &lt;span class=&quot;comment&quot;&gt;#这里便是对版本号的设置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;version&lt;/span&gt;Name &lt;span class=&quot;string&quot;&gt;&quot;2.0.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="Service" scheme="https://hjw541988478.github.io/tags/Service/"/>
    
      <category term="Handler" scheme="https://hjw541988478.github.io/tags/Handler/"/>
    
      <category term="Notification" scheme="https://hjw541988478.github.io/tags/Notification/"/>
    
  </entry>
  
  <entry>
    <title>PropertyAnimation使用总结</title>
    <link href="https://hjw541988478.github.io/PropertyAnimation%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://hjw541988478.github.io/PropertyAnimation使用总结/</id>
    <published>2015-08-24T11:27:14.000Z</published>
    <updated>2018-08-17T15:31:06.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h2><ul><li>淡入效果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(tv, <span class="string">"alpha"</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span><br><span class="line">            .setDuration(<span class="number">500</span>)</span><br><span class="line">            .start();</span><br></pre></td></tr></table></figure></li></ul><p><code>ofFloat</code>对应着三个参数值，分别是目标<code>View</code>，动画属性名<code>Property</code>，以及属性值，一个则为终点值，两个对应着起点和终点值，多个则为起点值，将会调用的值和终点值。与<code>ofFloat</code>类似的还有<code>ofInt</code>、<code>ofObject</code>，这些都是用来设置动画动作的元素。<br><a id="more"></a></p><ul><li>同时缩小和淡出效果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator anim = ObjectAnimator</span><br><span class="line">            .ofFloat(view, <span class="string">"hjw"</span>, <span class="number">1.0F</span>,  <span class="number">0.0F</span>)  </span><br><span class="line">            .setDuration(<span class="number">500</span>);  </span><br><span class="line">    anim.start();  </span><br><span class="line">    anim.addUpdateListener(<span class="keyword">new</span> AnimatorUpdateListener()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">float</span> cVal = (Float) animation.getAnimatedValue();  </span><br><span class="line">            view.setAlpha(cVal);  </span><br><span class="line">            view.setScaleX(cVal);  </span><br><span class="line">            view.setScaleY(cVal);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>可以看到，使用这种非常规的方式也可以达到预期的效果，只需要在使用了未知的<code>Property</code>，然后再回调方法中按照时间插值和持续时间计算值，我们自己手动调用实现各个属性的值。</p><h2 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h2><ul><li>抛物线运动效果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator animator = <span class="keyword">new</span> ValueAnimator();</span><br><span class="line">        animator.setDuration(<span class="number">3000</span>);</span><br><span class="line">        animator.setObjectValues(<span class="keyword">new</span> PointF(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        animator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line">        animator.setEvaluator(<span class="keyword">new</span> TypeEvaluator&lt;PointF&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> PointF <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, PointF startValue, PointF endValue)</span> </span>&#123;</span><br><span class="line">                PointF pointF = <span class="keyword">new</span> PointF();</span><br><span class="line">                pointF.x = <span class="number">100</span> * fraction;</span><br><span class="line">                pointF.y = <span class="number">0.5f</span> * (fraction * <span class="number">100</span>) * (fraction * <span class="number">100</span>);</span><br><span class="line">                <span class="keyword">return</span> pointF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        animator.start();</span><br><span class="line">        animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">                PointF point = (PointF) animation.getAnimatedValue();</span><br><span class="line">                circleView.setX(point.x);</span><br><span class="line">                circleView.setY(point.y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>可以看到与<code>ObjectAnimator</code>相比，并没有指定<code>Property</code>的操作，也就是说，<code>ValueAnimator</code>只关心值的变化，但是带来的变化是只需要根据计算好的动画值，重写<code>TypeEvaluator</code>类，在<code>evaluate</code>回调方法中返回任何想要调用的值，类似上面那种非常规的方式，也无需使用到反射。</p><h2 id="AnimationSet"><a href="#AnimationSet" class="headerlink" title="AnimationSet"></a>AnimationSet</h2><ul><li>淡入淡出效果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator alphaOutAnim = <span class="keyword">new</span> ObjectAnimator();</span><br><span class="line">   alphaOutAnim.ofFloat(tv, <span class="string">"alpha"</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">   ObjectAnimator alphaInAnim = <span class="keyword">new</span> ObjectAnimator();</span><br><span class="line">   alphaInAnim.ofFloat(tv, <span class="string">"alpha"</span>, <span class="number">1f</span>, <span class="number">0f</span>);</span><br><span class="line">   AnimatorSet animatorSet = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">   animatorSet.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line">   animatorSet.setDuration(<span class="number">2000</span>);</span><br><span class="line">   animatorSet.playSequentially(alphaOutAnim, alphaInAnim);</span><br><span class="line">   animatorSet.start();</span><br></pre></td></tr></table></figure></li></ul><p><code>AnimationSet</code>主要是用来对多动画的执行顺序进行控制，包括<code>playTogether</code>同时执行、<code>playSequentially</code>顺序执行和<code>after with before</code>等方法控制。</p><h2 id="监听动画变化事件"><a href="#监听动画变化事件" class="headerlink" title="监听动画变化事件"></a>监听动画变化事件</h2><ul><li>监听动画事件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(tv, <span class="string">"alpha"</span>, <span class="number">0.5f</span>);</span><br><span class="line">        anim.addListener(<span class="keyword">new</span> AnimatorListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 动画开始执行</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 动画重复执行</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 动画执行结束</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 取消动画执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        anim.start();</span><br></pre></td></tr></table></figure></li></ul><p>对于常用的开始、重复、结束和取消动画事件都能够被监听到，只需要在回调方法中实现所需要实现的业务即可。</p><h2 id="XML创建PropertyAnimation"><a href="#XML创建PropertyAnimation" class="headerlink" title="XML创建PropertyAnimation"></a>XML创建PropertyAnimation</h2><ul><li>XML方式描述淡出效果<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:propertyName</span>=<span class="string">"alpha"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueFrom</span>=<span class="string">"0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueTo</span>=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueType</span>=<span class="string">"floatType"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectAnimator</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>在<code>res/animator</code>目录下创建<code>alpha.xml</code>文件，然后进行调用：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animator anim = AnimatorInflater.loadAnimator(<span class="keyword">this</span>, R.animator.alpha);  </span><br><span class="line">anim.setTarget(mMv);  </span><br><span class="line">anim.start()</span><br></pre></td></tr></table></figure></p><p>如果需要多个动画去执行，只需要在XML文件中增加<code>Set</code>节点：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:ordering</span>=<span class="string">"together"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:propertyName</span>=<span class="string">"scaleX"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueFrom</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"0.5"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">objectAnimator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:propertyName</span>=<span class="string">"scaleY"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueFrom</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:valueTo</span>=<span class="string">"0.5"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">objectAnimator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>通过改变<code>ordering</code>属性的值去控制多个动画之间的执行顺序。</p><h2 id="Layout-Animations-布局动画"><a href="#Layout-Animations-布局动画" class="headerlink" title="Layout Animations(布局动画)"></a>Layout Animations(布局动画)</h2><p>改变<code>ViewGroup</code>的子<code>View</code>移除或者添加的动画效果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LayoutTransition transition = <span class="keyword">new</span> LayoutTransition();</span><br><span class="line">    transition.setAnimator(LayoutTransition.CHANGE_APPEARING,</span><br><span class="line">transition.getAnimator(LayoutTransition.CHANGE_APPEARING));</span><br><span class="line">transition.setAnimator(LayoutTransition.APPEARING,</span><br><span class="line"><span class="keyword">null</span>);</span><br><span class="line">transition.setAnimator(LayoutTransition.DISAPPEARING,</span><br><span class="line"><span class="keyword">null</span>);</span><br><span class="line">transition.setAnimator(LayoutTransition.CHANGE_DISAPPEARING,</span><br><span class="line"><span class="keyword">null</span>);</span><br><span class="line">mLayout.setLayoutTransition(transition);</span><br></pre></td></tr></table></figure></p><p>需要注意的四种类型：</p><ul><li><code>LayoutTransition.APPEARING</code>：当一个<code>View</code>在<code>ViewGroup</code>中出现时，对此<code>View</code>设置的动画；</li><li><code>LayoutTransition.CHANGE_APPEARING</code>： 当一个<code>View</code>在<code>ViewGroup</code>中出现时，此<code>View</code>对其他<code>View</code>位置造成的效果，对其他<code>View</code>设置的动画；</li><li><code>LayoutTransition.DISAPPEARING</code>：当一个<code>View</code>在<code>ViewGroup</code>中消失时，对此<code>View</code>设置的动画；</li><li><code>LayoutTransition.CHANGE_DISAPPEARING</code>：当一个<code>View</code>在<code>ViewGroup</code>中消失时，此<code>View</code>对其他<code>View</code>位置造成效果，对其他<code>View</code>设置的动画；</li><li><code>LayoutTransition.CHANGE</code>：不是由于<code>View</code>出现或消失造成对其他<code>View</code>位置造成效果，对其他<code>View</code>设置的动画。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ObjectAnimator&quot;&gt;&lt;a href=&quot;#ObjectAnimator&quot; class=&quot;headerlink&quot; title=&quot;ObjectAnimator&quot;&gt;&lt;/a&gt;ObjectAnimator&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;淡入效果&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ObjectAnimator.ofFloat(tv, &lt;span class=&quot;string&quot;&gt;&quot;alpha&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.0f&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0f&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .setDuration(&lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .start();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ofFloat&lt;/code&gt;对应着三个参数值，分别是目标&lt;code&gt;View&lt;/code&gt;，动画属性名&lt;code&gt;Property&lt;/code&gt;，以及属性值，一个则为终点值，两个对应着起点和终点值，多个则为起点值，将会调用的值和终点值。与&lt;code&gt;ofFloat&lt;/code&gt;类似的还有&lt;code&gt;ofInt&lt;/code&gt;、&lt;code&gt;ofObject&lt;/code&gt;，这些都是用来设置动画动作的元素。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="Animation" scheme="https://hjw541988478.github.io/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>多行文本的可展开折叠的TextView实现</title>
    <link href="https://hjw541988478.github.io/%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E5%8F%AF%E6%8A%98%E5%8F%A0%E5%B1%95%E5%BC%80TextView%E5%AE%9E%E7%8E%B0/"/>
    <id>https://hjw541988478.github.io/多行文本可折叠展开TextView实现/</id>
    <published>2015-08-23T11:28:19.000Z</published>
    <updated>2018-08-17T15:30:20.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>在实现商家评论区的需求时，对于多行评论的显示，采用的是使用<code>maxLines</code>属性去限定显示的行数，同时使用<code>android:ellipsize=end</code>在限定行数的末尾显示<code>...</code>，这种方式可以很好的避免评论文字过多显示过长的情况。但是对于有价值的评论，有必要显示所有评论文字，采用展开折叠的交互，能够更加的灵活地去应对长文字的多行显示，给用户给好的体验。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，继承<code>LinearLayout</code>，并对文本和标记组件进行一层包装，通过对折叠状态下的行数、展开折叠的动画时长、展开和折叠状态的视图控制，进行可自定义的属性封装。然后对父类的<code>onClick</code>方法进行重写，用户在对组件点击的时候，文本会自动的展开或折叠。然而当文本正在处于折叠或展开过程的动画中时，应该重写<code>onInterceptTouchEvent</code>方法拦截所有的点击事件，防止出现异常。<br><a id="more"></a><br>其次，在整个流程中我们需要了解到文本的真实高度，用来在初始化的时候去判断是否需要进入折叠模式，因此需要重写<code>onMeasure</code>方法，如果组件不需要重新绘制或者组件的可见性为<code>View.GONE</code>，则直接使用父类的<code>onMeasure</code>方法。<br>然后，但是如果组件需要重新绘制，便会初始化组件的状态，并对组件进行测量，判断真实文本的行数，如果小于设置的最大显示行数，则直接显示，否则按最大显示行数显示文本并让展开状态的View可见，保存当前折叠状态下显示的高度。<br>最后，对于视图复用的问题，一般情况下，视图被滑出了屏幕看不见后，这个视图数据便消失了，重新让视图进入屏幕中时，视图会重新初始化，而对于那些展开或者折叠状态的视图也会默认变为折叠模式。因此需要一个标记量去使用额外的标记决定视图显示的位置和状态，这里使用到的是<a href="http://blog.csdn.net/haukey/article/details/8200404" target="_blank" rel="noopener">SparseBooleanArray</a>，实质上基于稀疏矩阵和折半查找的<code>HashMap&lt;Integer,Boolean&gt;</code>的优化版本，<code>key</code>用来记录位置，<code>value</code>用来记录状态。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li><p>通过在<code>attrs.xml</code>中进行属性的自定义，并通过下面的代码去获取在布局文件中配置的自定义的属性值，包括了最多显示行数，展开、折叠资源等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    TypedArray typedArray = getContext().obtainStyledAttributes(attrs, R.styleable.ExpTextView);</span><br><span class="line">    <span class="comment">//最多行数</span></span><br><span class="line">    mMaxLines = typedArray.getInt(R.styleable.Exp_maxCollapsedLines, MAX_COLLAPSED_LINES);</span><br><span class="line">    <span class="comment">//动画时长</span></span><br><span class="line">    mAnimDuration = typedArray.getInt(R.styleable.ExpTextView_animDuration, DEFAULT_ANIM_DURATION);</span><br><span class="line">    <span class="comment">// 动画透明度渐变初始值</span></span><br><span class="line">    mAnimAlphaStart = typedArray.getFloat(R.styleable.ExpTextView_animAlphaStart, DEFAULT_ANIM_ALPHA_START);</span><br><span class="line">    mExpandDrawable = typedArray.getDrawable(R.styleable.ExpTextView_expandDrawable);</span><br><span class="line">    mCollapseDrawable = typedArray.getDrawable(R.styleable.ExpTextView_collapseDrawable);</span><br><span class="line">    <span class="keyword">if</span> (mExpandDrawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mExpandDrawable = getDrawable(getContext(), );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mCollapseDrawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCollapseDrawable = getDrawable(getContext(), R.drawable.ic_mer_detail_collapse);</span><br><span class="line">    &#125;</span><br><span class="line">    typedArray.recycle();</span><br><span class="line">    <span class="comment">//只能是垂直布局</span></span><br><span class="line">    setOrientation(LinearLayout.VERTICAL);</span><br><span class="line">    <span class="comment">//默认是不显示的</span></span><br><span class="line">    setVisibility(GONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写<code>onMeasure</code>方法，目的是判断当前文本的状态和初始化在不同状态下必要的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有改变直接返回当前状态</span></span><br><span class="line">    <span class="keyword">if</span> (!mRelayout || getVisibility() == View.GONE) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mRelayout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 初始化默认状态</span></span><br><span class="line">    mButton.setVisibility(View.GONE);</span><br><span class="line">    mTv.setMaxLines(Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">// 测量控件尺寸</span></span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="comment">// 文本显示的行数小于限定值，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mTv.getLineCount() &lt;= mMaxCollapsedLines) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得文本的真实高度</span></span><br><span class="line">    mTextHeightWithMaxLines = getRealTextViewHeight(mTv);</span><br><span class="line">    <span class="comment">// 处于折叠模式中，只显示限定值的行数</span></span><br><span class="line">    <span class="keyword">if</span> (mCollapsed) &#123;</span><br><span class="line">        mTv.setMaxLines(mMaxCollapsedLines);</span><br><span class="line">    &#125;</span><br><span class="line">    mButton.setVisibility(View.VISIBLE);</span><br><span class="line">    <span class="comment">// 重新测量控件尺寸</span></span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (mCollapsed) &#123;</span><br><span class="line">        <span class="comment">// 获得文本与容器的外间距值</span></span><br><span class="line">        mTv.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mMarginBetweenTxtAndBottom = getHeight() - mTv.getHeight();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 保存当前测量值的高度</span></span><br><span class="line">        mCollapsedHeight = getMeasuredHeight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取<code>TextView</code>真实高度的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRealTextViewHeight</span><span class="params">(TextView textView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> textHeight = textView.getLayout().getLineTop(textView.getLineCount());</span><br><span class="line">        <span class="keyword">int</span> padding = textView.getCompoundPaddingTop() + textView.getCompoundPaddingBottom();</span><br><span class="line">        <span class="keyword">return</span> textHeight + padding;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>重写<code>onClick</code>方法，处理点击事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mButton.getVisibility() != View.VISIBLE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 折叠模式状态值与上次相反</span></span><br><span class="line">    mCollapsed = !mCollapsed;</span><br><span class="line">    mButton.setImageDrawable(mCollapsed ? mExpandDrawable : mCollapseDrawable);</span><br><span class="line">    <span class="keyword">if</span> (mCollapsedStatus != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 存放状态值</span></span><br><span class="line">        mCollapsedStatus.put(mPosition, mCollapsed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动画播放标记置true</span></span><br><span class="line">    mAnimating = <span class="keyword">true</span>;</span><br><span class="line">    Animation animation;</span><br><span class="line">    <span class="keyword">if</span> (mCollapsed) &#123;</span><br><span class="line">        animation = <span class="keyword">new</span> ExpandCollapseAnimation(<span class="keyword">this</span>, getHeight(), mCollapsedHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        animation = <span class="keyword">new</span> ExpandCollapseAnimation(<span class="keyword">this</span>, getHeight(), getHeight() +</span><br><span class="line">                mTextHeightWithMaxLines - mTv.getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保持动画后的状态</span></span><br><span class="line">    animation.setFillAfter(<span class="keyword">true</span>);</span><br><span class="line">    animation.setAnimationListener(<span class="keyword">new</span> Animation.AnimationListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">            applyAlphaAnimation(mTv, mAnimAlphaStart);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 防止多次调用applyTransformation()</span></span><br><span class="line">            clearAnimation();</span><br><span class="line">            <span class="comment">// 动画播放标记置false</span></span><br><span class="line">            mAnimating = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果外部有设置监听事件，则触发监听事件</span></span><br><span class="line">            <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mListener.onExpandStateChanged(mTv, !mCollapsed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    clearAnimation();</span><br><span class="line">    startAnimation(animation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>展开折叠动画类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpandCollapseAnimation</span> <span class="keyword">extends</span> <span class="title">Animation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> View mTargetView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mStartHeight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mEndHeight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExpandCollapseAnimation</span><span class="params">(View view, <span class="keyword">int</span> startHeight, <span class="keyword">int</span> endHeight)</span> </span>&#123;</span><br><span class="line">        mTargetView = view;</span><br><span class="line">        mStartHeight = startHeight;</span><br><span class="line">        mEndHeight = endHeight;</span><br><span class="line">        setDuration(mAnimationDuration);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyTransformation</span><span class="params">(<span class="keyword">float</span> interpolatedTime, Transformation t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newHeight = (<span class="keyword">int</span>) ((mEndHeight - mStartHeight) * interpolatedTime + mStartHeight);</span><br><span class="line">        mTv.setMaxHeight(newHeight - mMarginBetweenTxtAndBottom);</span><br><span class="line">        <span class="keyword">if</span> (Float.compare(mAnimAlphaStart, <span class="number">1.0f</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            applyAlphaAnimation(mTv, mAnimAlphaStart + interpolatedTime * (<span class="number">1.0f</span> - mAnimAlphaStart));</span><br><span class="line">        &#125;</span><br><span class="line">        mTargetView.getLayoutParams().height = newHeight;</span><br><span class="line">        mTargetView.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> parentWidth, <span class="keyword">int</span> parentHeight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.initialize(width, height, parentWidth, parentHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">willChangeBounds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其他必要重写的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果动画正在播放就不分发触摸时间给子View</span></span><br><span class="line">    <span class="keyword">return</span> mAnimating;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 结束加载时初始化控件ID</span></span><br><span class="line">    findViews();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/多行文本可折叠展开TextView实现/pic_expandable_state.png" alt="多行文本展开状态效果图" title="">                </div>                <div class="image-caption">多行文本展开状态效果图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/多行文本可折叠展开TextView实现/pic_collapse_state.png" alt="多行文本收缩状态效果图" title="">                </div>                <div class="image-caption">多行文本收缩状态效果图</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;在实现商家评论区的需求时，对于多行评论的显示，采用的是使用&lt;code&gt;maxLines&lt;/code&gt;属性去限定显示的行数，同时使用&lt;code&gt;android:ellipsize=end&lt;/code&gt;在限定行数的末尾显示&lt;code&gt;...&lt;/code&gt;，这种方式可以很好的避免评论文字过多显示过长的情况。但是对于有价值的评论，有必要显示所有评论文字，采用展开折叠的交互，能够更加的灵活地去应对长文字的多行显示，给用户给好的体验。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;首先，继承&lt;code&gt;LinearLayout&lt;/code&gt;，并对文本和标记组件进行一层包装，通过对折叠状态下的行数、展开折叠的动画时长、展开和折叠状态的视图控制，进行可自定义的属性封装。然后对父类的&lt;code&gt;onClick&lt;/code&gt;方法进行重写，用户在对组件点击的时候，文本会自动的展开或折叠。然而当文本正在处于折叠或展开过程的动画中时，应该重写&lt;code&gt;onInterceptTouchEvent&lt;/code&gt;方法拦截所有的点击事件，防止出现异常。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://hjw541988478.github.io/categories/Android/"/>
    
    
      <category term="CustomView" scheme="https://hjw541988478.github.io/tags/CustomView/"/>
    
  </entry>
  
</feed>
